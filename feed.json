{"title":"付四凯的博客","description":null,"language":"en","link":"http://linthan.github.io/blog","pubDate":"Tue, 21 Jul 2020 00:00:00 GMT","lastBuildDate":"Thu, 18 Mar 2021 03:47:51 GMT","generator":"hexo-generator-json-feed","webMaster":"付四凯","items":[{"title":"图解redis五种数据结构底层实现","link":"http://linthan.github.io/blog/2020/07/21/tech/redis/daiery-220-0721-0800/","description":"redis 有五种基本数据结构：字符串、hash、set、zset、list。但是你知道构成这五种结构的底层数据结构是怎样的吗？今天我们来花费五分钟的时间了解一下。","pubDate":"Tue, 21 Jul 2020 00:00:00 GMT","guid":"http://linthan.github.io/blog/2020/07/21/tech/redis/daiery-220-0721-0800/","category":"技术,redis"},{"title":"深入浅出一致性Hash原理","link":"http://linthan.github.io/blog/2020/07/20/tech/algorithm/daiery-2020-0720-2000/","description":"一、前言在解决分布式系统中负载均衡的问题时候可以使用 Hash 算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡的作用。 但是普通的余数 hash（hash(比如用户 id)%服务器机器数）算法伸缩性很差，当新增或者下线服务器机器时候，用户 id 与服务器的映射关系会大量失效。一致性 hash 则利用 hash 环对其进行了改进。 为了能直观的理解一致性 hash 原理，这里结合一个简单的例子来讲解，假设有 4 台服务器，地址为 ip1,ip2,ip3,ip4。 一致性 hash 是首先计算四个 ip 地址对应的 hash 值hash(ip1),hash(ip2),hash(ip3),hash(ip3)，计算出来的 hash 值是 0~最大正整数直接的一个值，这四个值在一致性 hash 环上呈现如下图：","pubDate":"Mon, 20 Jul 2020 02:00:00 GMT","guid":"http://linthan.github.io/blog/2020/07/20/tech/algorithm/daiery-2020-0720-2000/","category":"技术,算法,面试"},{"title":"分布式锁之Redis实现","link":"http://linthan.github.io/blog/2020/07/17/tech/redis/daiery-2020-0717-1100/","description":"在 Java 中，关于锁我想大家都很熟悉。在并发编程中，我们通过锁，来避免由于竞争而造成的数据不一致问题。通常，我们以 synchronized 、Lock 来使用它。 但是 Java 中的锁，只能保证在同一个 JVM 进程内中执行。如果在分布式集群环境下呢？","pubDate":"Fri, 17 Jul 2020 03:00:00 GMT","guid":"http://linthan.github.io/blog/2020/07/17/tech/redis/daiery-2020-0717-1100/","category":"技术,redis"},{"title":"几率大的Redis面试题（","link":"http://linthan.github.io/blog/2020/07/17/tech/redis/daiery-2020-0717-1000/","description":"本文的面试题如下：Redis 持久化机制缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题热点数据和冷数据是什么Memcache 与 Redis 的区别都有哪些？单线程的 redis 为什么这么快redis 的数据类型，以及每种数据类型的使用场景，Redis 内部结构redis 的过期策略以及内存淘汰机制【～】Redis 为什么是单线程的，优点如何解决 redis 的并发竞争 key 问题Redis 集群方案应该怎么做？都有哪些方案？有没有尝试进行多机 redis 的部署？如何保证数据一致的？对于大量的请求怎么样处理Redis 常见性能问题和解决方案？讲解下 Redis 线程模型为什么 Redis 的操作是原子性的，怎么保证原子性的？Redis 事务Redis 实现分布式锁","pubDate":"Fri, 17 Jul 2020 02:00:00 GMT","guid":"http://linthan.github.io/blog/2020/07/17/tech/redis/daiery-2020-0717-1000/","category":"技术,redis"},{"title":"用Go撸一个二叉搜索树","link":"http://linthan.github.io/blog/2020/07/17/tech/algorithm/daiery-2020-07-17-900/","description":"前几天 Redis 的作者 antirez 说他朋友面试的时候考到排序问题，然后他说要是他也会考实现一个二叉搜索树，我说在中国某公司，据说面试直接就撸一个红黑树。不是说你技术渣，试问在座的各位有几个现在直接裸写出红黑树？ 红黑树太过偏门，但是常用的二叉搜索树你能写出来吗？快排呢？堆排序呢？ 什么是二叉搜索树二叉搜索树(binary search tree,BST)也叫排序的二叉树，根节点比左边子树的所有节点都大，比右边子树上的所有节点都小，如下图就是一个二叉搜索树: 要实现一个二叉搜索树， 我们需要实现节点的插入和删除，要实现节点的查找(搜索)，要实现前序遍历、中序遍历和后序遍历，要实现最大节点和最小节点的查找。 下面就让我们实现这个二叉搜索树。","pubDate":"Fri, 17 Jul 2020 02:00:00 GMT","guid":"http://linthan.github.io/blog/2020/07/17/tech/algorithm/daiery-2020-07-17-900/","category":"技术,算法,面试"},{"title":"http协议里的keep-alive","link":"http://linthan.github.io/blog/2020/07/16/tech/http/daiery-2020-0717-2000/","description":"http 是现在 web 领域极其普遍的应用层传输协议， 目前常见的使用版本则是 http1.1， 当然最先版本是 http2.0。 传统的 Http 应用里都是一次 TCP 连接一次 request。","pubDate":"Thu, 16 Jul 2020 14:00:00 GMT","guid":"http://linthan.github.io/blog/2020/07/16/tech/http/daiery-2020-0717-2000/","category":"技术,面试"},{"title":"http常见的状态码，400,401,403状态码分别代表什么？","link":"http://linthan.github.io/blog/2020/07/16/tech/interview/daiery-2020-0716-2000/","description":"2XX 成功200 OK，表示从客户端发来的请求在服务器端被正确处理204 No content，表示请求成功，但响应报文不含实体的主体部分206 Partial Content，进行范围请求","pubDate":"Thu, 16 Jul 2020 14:00:00 GMT","guid":"http://linthan.github.io/blog/2020/07/16/tech/interview/daiery-2020-0716-2000/","category":"技术,面试"},{"title":"图解Golang的内存分配","link":"http://linthan.github.io/blog/2020/07/16/tech/golang/daiery-2020-07-16-2030/","description":"一般程序的内存分配在讲 Golang 的内存分配之前，让我们先来看看一般程序的内存分布情况：","pubDate":"Thu, 16 Jul 2020 11:30:00 GMT","guid":"http://linthan.github.io/blog/2020/07/16/tech/golang/daiery-2020-07-16-2030/","category":"技术,golang"},{"title":"mysql 四种隔离级别","link":"http://linthan.github.io/blog/2020/07/16/tech/database/daiery-2020-0716-1009/","description":"事务的 四个特征（ACID）事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。 1 、原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做 2 、一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。 3 、隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。 4 、持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。 Mysql 的四种隔离级别SQL 标准定义了 4 类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。 Read Uncommitted（读取未提交内容） 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。 Read Committed（读取提交内容） 这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的 commit，所以同一 select 可能返回不同结果。 Repeatable Read（可重读） 这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB 和 Falcon 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。 Serializable（可串行化） 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 出现问题 这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如： 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个 RollBack 了操作，则后一个事务所读取的数据就会是不正确的。 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。 在 MySQL 中，实现了这四种隔离级别，分别有可能产生问题如下所示： 参考","pubDate":"Thu, 16 Jul 2020 02:30:00 GMT","guid":"http://linthan.github.io/blog/2020/07/16/tech/database/daiery-2020-0716-1009/","category":"技术,数据库"},{"title":"死锁产生的原因和解锁的方法","link":"http://linthan.github.io/blog/2020/07/16/tech/os/daiery-2020-0716-1000/","description":"产生死锁的四个必要条件： （1） 互斥条件：一个资源每次只能被一个进程使用。 （2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 （3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 （4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。","pubDate":"Thu, 16 Jul 2020 02:00:00 GMT","guid":"http://linthan.github.io/blog/2020/07/16/tech/os/daiery-2020-0716-1000/","category":"技术,面试,操作系统"},{"title":"线程共享内容和独享内容","link":"http://linthan.github.io/blog/2020/07/16/tech/os/daiery-2020-0716-2030/","description":"线程共享的内容包括： 1.进程代码段 2.进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯) 3.进程打开的文件描述符、 4.信号的处理器、 5.进程的当前目录和 6.进程用户 ID 与进程组 ID线程独有的内容包括： 1.线程 ID 2.寄存器组的值 3.线程的堆栈 4.错误返回码 5.线程的信号屏蔽码","pubDate":"Thu, 16 Jul 2020 02:00:00 GMT","guid":"http://linthan.github.io/blog/2020/07/16/tech/os/daiery-2020-0716-2030/","category":"技术,面试,操作系统"},{"title":"数据库索引原理，及MySQL索引类型","link":"http://linthan.github.io/blog/2020/07/16/tech/database/daiery-2020-0716-0830/","description":"MySQL 索引类型一览 让 MySQL 高效运行起来本文介绍了七种 MySQL 索引类型。在数据库表中，对字段建立索引可以大大提高查询速度。通过善用这些索引，可以令 MySQL 的查询和运行更加高效。","pubDate":"Thu, 16 Jul 2020 00:30:00 GMT","guid":"http://linthan.github.io/blog/2020/07/16/tech/database/daiery-2020-0716-0830/","category":"技术,数据库"},{"title":"图解Go的channel底层实现","link":"http://linthan.github.io/blog/2020/07/16/tech/golang/daiery-2020-07-16-0700/","description":"废话不多说，直奔主题。 channel 的整体结构图简单说明： buf 是有缓冲的 channel 所特有的结构，用来存储缓存数据。是个循环链表 sendx 和 recvx 用于记录 buf 这个循环链表中的发送或者接收的 index lock 是个互斥锁。 recvq 和 sendq 分别是接收(&lt;-channel)或者发送(channel &lt;- xxx)的 goroutine 抽象出来的结构体(sudog)的队列。是个双向链表","pubDate":"Wed, 15 Jul 2020 23:30:00 GMT","guid":"http://linthan.github.io/blog/2020/07/16/tech/golang/daiery-2020-07-16-0700/","category":"技术,golang"},{"title":"Http get与pos、HEAD的区别","link":"http://linthan.github.io/blog/2020/07/15/tech/interview/daiery-2020-0715-2300/","description":"Http get 与 pos 的区别 GET 和 POST 是 HTTP 请求的两种基本方法，要说它们的区别，接触过 WEB 开发的人都能说出一二。 最直观的区别就是 GET 把参数包含在 URL 中，POST 通过 request body 传递参数。 你可能自己写过无数个 GET 和 POST 请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。","pubDate":"Wed, 15 Jul 2020 15:00:00 GMT","guid":"http://linthan.github.io/blog/2020/07/15/tech/interview/daiery-2020-0715-2300/","category":"技术,面试,golang"},{"title":"几大排序的稳定性","link":"http://linthan.github.io/blog/2020/07/15/tech/algorithm/daiery-2020-07-15-2200/","description":"以前看人利用口诀记忆排序的稳定性：考研好痛苦，一堆（堆排序）专业课，情绪不稳定（不稳定排序），快（快速排序）来选（选择排序）一些（希尔排序）朋友聊聊天吧，剩下的都是稳定的。 感觉不错。。。。。。 接下来是八大排序总结","pubDate":"Wed, 15 Jul 2020 14:00:00 GMT","guid":"http://linthan.github.io/blog/2020/07/15/tech/algorithm/daiery-2020-07-15-2200/","category":"技术,算法,面试"},{"title":"GoLang Context包详解","link":"http://linthan.github.io/blog/2020/07/15/tech/golang/daiery-2020-07-15-2130/","description":"简介Context 是一个在 go 中经常用到的程序包，谷歌官方开发。特别常见的一个应用场景是有一个请求衍生出来的各个 goroutine 之间需要满足一定的约束条件，以实现一些诸如有效期、终止 routline 树、传递请求全局变量之类的功能。使用 Context 实现上下文功能约定需要在你的方法中传入参数的第一个传入 context.Context 类型的变量，我们将通过源码的阅读和一些示例代码来说明 context 的用法。","pubDate":"Wed, 15 Jul 2020 13:30:00 GMT","guid":"http://linthan.github.io/blog/2020/07/15/tech/golang/daiery-2020-07-15-2130/","category":"技术,golang"},{"title":"图解Go select语句原理","link":"http://linthan.github.io/blog/2020/07/10/tech/golang/daiery-2020-0710-0801/","description":"GolangGo 的 select 语句是一种仅能用于 channl 发送和接收消息的专用语句，此语句运行期间是阻塞的；当 select 中没有 case 语句的时候，会阻塞当前的 groutine。所以，有人也会说 select 是用来阻塞监听 goroutine 的。还有人说：select 是 Golang 在语言层面提供的 I/O 多路复用的机制，其专门用来检测多个 channel 是否准备完毕：可读或可写。 以上说法都正确。","pubDate":"Fri, 10 Jul 2020 00:00:00 GMT","guid":"http://linthan.github.io/blog/2020/07/10/tech/golang/daiery-2020-0710-0801/","category":"技术,golang,基础原理"},{"title":"Go语言之defer","link":"http://linthan.github.io/blog/2020/07/07/tech/interview/daiery-2020-0707-1600/","description":"来自 定义defer 语句被用于预定对一个函数的调用。我们把这类被 defer 语句调用的函数称为延迟函数。","pubDate":"Tue, 07 Jul 2020 08:40:00 GMT","guid":"http://linthan.github.io/blog/2020/07/07/tech/interview/daiery-2020-0707-1600/","category":"技术,面试,golang"},{"title":"Golang中的struct能不能比较","link":"http://linthan.github.io/blog/2020/07/07/tech/interview/daiery-2020-0707-1538/","description":"来自","pubDate":"Tue, 07 Jul 2020 07:38:00 GMT","guid":"http://linthan.github.io/blog/2020/07/07/tech/interview/daiery-2020-0707-1538/","category":"技术,面试,golang"},{"title":"2020 腾讯社招Golang后端面试经验分享","link":"http://linthan.github.io/blog/2020/07/07/tech/interview/daiery-2020-0707-1536/","description":"来自","pubDate":"Tue, 07 Jul 2020 07:19:00 GMT","guid":"http://linthan.github.io/blog/2020/07/07/tech/interview/daiery-2020-0707-1536/","category":"技术,面试,golang"},{"title":"图解各路分布式ID生成算法","link":"http://linthan.github.io/blog/2020/07/06/tech/algorithm/daiery-2020-07-06-1331/","description":"在分布式系统中，通常会用到分布式 ID 来标注数据的唯一性，而分布式 ID 的生成方式又多种多样，今天我们就来讨论一下主流的分布式 ID 生成策略。","pubDate":"Mon, 06 Jul 2020 05:31:00 GMT","guid":"http://linthan.github.io/blog/2020/07/06/tech/algorithm/daiery-2020-07-06-1331/","category":"技术,算法,面试"},{"title":"Golang 垃圾回收剖析","link":"http://linthan.github.io/blog/2020/07/06/tech/golang/daiery-2020-0706-1300/","description":"Golang 从第一个版本以来，GC 一直是大家诟病最多的。但是每一个版本的发布基本都伴随着 GC 的改进。下面列出一些比较重要的改动。 以下是 Golang GC 算法的里程碑： v1.1 STW v1.3 Mark STW, Sweep 并行 v1.5 三色标记法 v1.8 hybrid write barrier","pubDate":"Mon, 06 Jul 2020 05:00:00 GMT","guid":"http://linthan.github.io/blog/2020/07/06/tech/golang/daiery-2020-0706-1300/","category":"技术,面试,golang"},{"title":"图解Golang的GC算法","link":"http://linthan.github.io/blog/2020/07/06/tech/golang/daiery-2020-0706-1021/","description":"虽然 Golang 的 GC 自打一开始，就被人所诟病，但是经过这么多年的发展，Golang 的 GC 已经改善了非常多，变得非常优秀了。","pubDate":"Mon, 06 Jul 2020 02:21:00 GMT","guid":"http://linthan.github.io/blog/2020/07/06/tech/golang/daiery-2020-0706-1021/","category":"技术,面试,golang"},{"title":"epoll的本质","link":"http://linthan.github.io/blog/2020/07/01/tech/os/daiery-2020-0701-2100/","description":"从事服务端开发，少不了要接触网络编程。epoll 作为 linux 下高性能网络服务器的必备技术至关重要，nginx、redis、skynet 和大部分游戏服务器都使用到这一多路复用技术。","pubDate":"Wed, 01 Jul 2020 13:00:00 GMT","guid":"http://linthan.github.io/blog/2020/07/01/tech/os/daiery-2020-0701-2100/","category":"技术,操作系统"},{"title":"IO多路复用的三种机制Select，Poll，Epoll","link":"http://linthan.github.io/blog/2020/07/01/tech/os/daiery-2020-0701-1600/","description":"I/O 多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲 I/O 数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作","pubDate":"Wed, 01 Jul 2020 08:00:00 GMT","guid":"http://linthan.github.io/blog/2020/07/01/tech/os/daiery-2020-0701-1600/","category":"技术,操作系统"}]}