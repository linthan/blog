<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>付四凯的博客</title>
  <icon>https://www.gravatar.com/avatar/dcbfb12735f186e09f9fb089ae9eb0a0</icon>
  <subtitle>双手合十，潜心修炼</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://linthan.github.io/blog/"/>
  <updated>2020-07-23T08:46:03.341Z</updated>
  <id>http://linthan.github.io/blog/</id>
  
  <author>
    <name>付四凯</name>
    <email>445366464@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图解redis五种数据结构底层实现</title>
    <link href="http://linthan.github.io/blog/2020/07/21/tech/redis/daiery-220-0721-0800/"/>
    <id>http://linthan.github.io/blog/2020/07/21/tech/redis/daiery-220-0721-0800/</id>
    <published>2020-07-21T00:00:00.000Z</published>
    <updated>2020-07-23T08:46:03.341Z</updated>
    
    <content type="html"><![CDATA[<p>redis 有五种基本数据结构：字符串、hash、set、zset、list。但是你知道构成这五种结构的底层数据结构是怎样的吗？<br>今天我们来花费五分钟的时间了解一下。</p><a id="more"></a><h2 id="动态字符串-SDS"><a href="#动态字符串-SDS" class="headerlink" title="动态字符串 SDS"></a>动态字符串 SDS</h2><p>SDS 是”simple dynamic string”的缩写。<br>redis 中所有场景中出现的字符串，基本都是由 SDS 来实现的</p><ul><li>所有非数字的 key。例如 set msg “hello world” 中的 key msg.</li><li>字符串数据类型的值。例如<code></code> set msg “hello world”中的 msg 的值”hello wolrd”</li><li>非字符串数据类型中的“字符串值”。例如 RPUSH fruits “apple” “banana” “cherry”中的”apple” “banana” “cherry”</li></ul><p>SDS 长这样：<br><img src="/blog/assets/database/redis/sds.png" alt="sds"></p><p>free:还剩多少空间<br>len:字符串长度<br>buf:存放的字符数组</p><p>空间预分配<br>为减少修改字符串带来的内存重分配次数，sds 采用了“一次管够”的策略：</p><ul><li>若修改之后 sds 长度小于 1MB,则多分配现有 len 长度的空间</li><li>若修改之后 sds 长度大于等于 1MB，则扩充除了满足修改之后的长度外，额外多 1MB 空间<br><img src="/blog/assets/database/redis/sds1.gif" alt="sds1"></li></ul><p>惰性空间释放<br>为避免缩短字符串时候的内存重分配操作，sds 在数据减少时，并不立刻释放空间。<br><img src="/blog/assets/database/redis/sds_free.gif" alt="sds_free"><br>int<br>就是 redis 中存放的各种数字<br>包括一下这种，故意加引号“”的<br><img src="/blog/assets/database/redis/int.png" alt="int"><br><strong>双向链表</strong><br>长这样：<br><img src="/blog/assets/database/redis/linklist.png" alt="linklist"></p><p>分两部分，一部分是“统筹部分”：橘黄色，一部分是“具体实施方“：蓝色。</p><p>主体”统筹部分“：</p><ul><li>head 指向具体双向链表的头</li><li>tail 指向具体双向链表的尾</li><li>len 双向链表的长度</li></ul><p>具体”实施方”：一目了然的双向链表结构，有前驱 pre 有后继 next</p><p>由 list 和 listNode 两个数据结构构成。</p><p><strong>ziplist</strong></p><p>压缩列表。<br>redis 的列表键和哈希键的底层实现之一。此数据结构是为了节约内存而开发的。和各种语言的数组类似，它是由连续的内存块组成的，这样一来，由于内存是连续的，就减少了很多内存碎片和指针的内存占用，进而节约了内存。<br><img src="/blog/assets/database/redis/ziplist_total.png" alt="ziplist_total"></p><p>然后文中的 entry 的结构是这样的：<br><img src="/blog/assets/database/redis/ziplist_entry.png" alt="ziplist_entry"><br>元素的遍历<br>先找到列表尾部元素：<br><img src="/blog/assets/database/redis/ziplist_bianli1.gif" alt="ziplist_bianli1"><br>然后再根据 ziplist 节点元素中的 previous_entry_length 属性，来逐个遍历:<br><img src="/blog/assets/database/redis/ziplist_bianli2.gif" alt="ziplist_bianli2"></p><p><strong>连锁更新</strong><br>再次看看 entry 元素的结构，有一个 previous_entry_length 字段，他的长度要么都是 1 个字节，要么都是 5 个字节：</p><ul><li>前一节点的长度小于 254 字节，则 previous_entry_length 长度为 1 字节</li><li>前一节点的长度小于 254 字节，则 previous_entry_length 长度为 5 字节</li></ul><p>假设现在存在一组压缩列表，长度都在 250 字节至 253 字节之间，突然新增一新节点 new，<br>长度大于等于 254 字节，会出现：<br><img src="/blog/assets/database/redis/ziplist_refresh.gif" alt="ziplist_refresh"></p><p>程序需要不断的对压缩列表进行空间重分配工作，直到结束。</p><p>除了增加操作，删除操作也有可能带来“连锁更新”。<br>请看下图，ziplist 中所有 entry 节点的长度都在 250 字节至 253 字节之间，big 节点长度大于 254 字节，small 节点小于 254 字节。<br><img src="/blog/assets/database/redis/ziplist_sub_refresh.gif" alt="ziplist_sub_refresh"></p><p><strong>哈希表</strong><br>哈希表略微有点复杂。哈希表的制作方法一般有两种，一种是：开放寻址法，一种是拉链法。redis 的哈希表的制作使用的是拉链法。<br>整体结构如下图：<br><img src="/blog/assets/database/redis/hash1.png" alt="hash1"><br>也是分为两部分：左边橘黄色部分和右边蓝色部分，同样，也是”统筹“和”实施“的关系。<br>具体哈希表的实现，都是在蓝色部分实现的。<br>先来看看蓝色部分：<br><img src="/blog/assets/database/redis/hash2.png" alt="hash2"><br>这也分为左右两边“统筹”和“实施”的两部分。</p><p>右边部分很容易理解：就是通常拉链表实现的哈希表的样式；数组就是 bucket，一般不同的 key 首先会定位到不同的 bucket，若 key 重复，就用链表把冲突的 key 串起来。</p><p>新建 key 的过程：<br><img src="/blog/assets/database/redis/hash_key.gif" alt="hash_key"><br>假如重复了:<br><img src="/blog/assets/database/redis/hash_key_dup.gif" alt="hash_key_dup"></p><p><strong>rehash</strong><br>再来看看哈希表总体图中左边橘黄色的“统筹”部分，其中有两个关键的属性：ht 和 rehashidx。<br>ht 是一个数组，有且只有俩元素 ht[0]和 ht[1];其中，ht[0]存放的是 redis 中使用的哈希表，而 ht[1]和 rehashidx 和哈希表的 rehash 有关。</p><p>rehash 指的是重新计算键的哈希值和索引值，然后将键值对重排的过程。</p><p>加载因子（load factor） = ht[0].used / ht[0].size。</p><p>扩容：</p><ul><li>第一个大于等于 ht[0].used * 2 的 2^n(2 的 n 次方幂)。</li></ul><p>收缩：</p><ul><li>第一个大于等于 ht[0].used 的 2^n(2 的 n 次方幂)。</li></ul><p>(以下部分属于细节分析，可以跳过直接看扩容步骤)<br>对于收缩，我当时陷入了疑虑：收缩标准是加载因子小于 0.1 的时候，也就是说假如哈希表中有 4 个元素的话，哈希表的长度只要大于 40，就会进行收缩，假如有一个长度大于 40，但是存在的元素为 4 即(ht[0].used 为 4)的哈希表，进行收缩，那收缩后的值为多少？</p><p>我想了一下：按照前文所讲的内容，应该是 4。<br>但是，假如是 4，存在和收缩后的长度相等，是不是又该扩容？<br>翻开源码看看：</p><p>收缩具体函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span>     <span class="comment">//缩小字典d</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minimal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果dict_can_resize被设置成0，表示不能进行rehash，或正在进行rehash，返回出错标志DICT_ERR</span></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;            <span class="comment">//获得已经有的节点数量作为最小限度minimal</span></span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)<span class="comment">//但是minimal不能小于最低值DICT_HT_INITIAL_SIZE（4）</span></span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);      <span class="comment">//用minimal调整字典d的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span>     <span class="comment">//根据size调整或创建字典d的哈希表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictht n;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size);  <span class="comment">//获得一个最接近2^n的realsize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size) <span class="comment">//正在rehash或size不够大返回出错标志</span></span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].size) <span class="keyword">return</span> DICT_ERR; <span class="comment">//如果新的realsize和原本的size一样则返回出错标志</span></span><br><span class="line">    <span class="comment">/* Allocate the new hash table and initialize all pointers to NULL */</span></span><br><span class="line">    <span class="comment">//初始化新的哈希表的成员</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is this the first initialization? If so it's not really a rehashing</span></span><br><span class="line"><span class="comment">     * we just set the first hash table so that it can accept keys. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;   <span class="comment">//如果ht[0]哈希表为空，则将新的哈希表n设置为ht[0]</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;           <span class="comment">//如果ht[0]非空，则需要rehash</span></span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;       <span class="comment">//设置rehash标志位为0，开始渐进式rehash（incremental rehashing）</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _dictNextPower(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = DICT_HT_INITIAL_SIZE; <span class="comment">//DICT_HT_INITIAL_SIZE 为 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX) <span class="keyword">return</span> LONG_MAX + <span class="number">1L</span>U;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码我们可以看到，假如收缩后长度为 4，不仅不会收缩，甚至还会报错。(😝)</p><p>我们回过头来再看看设定：题目可能成立吗？<br>哈希表的扩容都是 2 倍增长的，最小是 4，<br>4 ===》 8 ====》 16 =====》 32 ======》 64 ====》 128</p><p>也就是说：不存在长度为 40 多的情况，只能是 64。但是如果是 64 的话，64 X 0.1（收缩界限）= 6.4 ，也就是说在减少到 6 的时候，哈希表就会收缩，会缩小到多少呢？是 8。此时，再继续减少到 4，也不会再收缩了。所以，根本不存在一个长度大于 40，但是存在的元素为 4 的哈希表的。</p><p><strong>扩容步骤</strong><br><img src="/blog/assets/database/redis/hash_refresh_release.gif" alt="hash_refresh_release"></p><p><strong>收缩步骤</strong><br><img src="/blog/assets/database/redis/hash_refresh_release1.gif" alt="hash_refresh_release1"></p><p>渐进式 refresh<br>在”扩容步骤”和”收缩步骤” 两幅动图中每幅图的第四步骤“将 ht[0]中的数据利用哈希函数重新计算，rehash 到 ht[1]”，并不是一步完成的，而是分成 N 多步，循序渐进的完成的。<br>因为 hash 中有可能存放几千万甚至上亿个 key，毕竟 Redis 中每个 hash 中可以存 2^32 - 1 键值对（40 多亿），假如一次性将这些键值 rehash 的话，可能会导致服务器在一段时间内停止服务，毕竟哈希函数就得计算一阵子呢((#^.^#))。</p><p>哈希表的 refresh 是分多次、渐进式进行的。</p><p>渐进式 refresh 和下图中左边橘黄色的“统筹”部分中的 rehashidx 密切相关：</p><ul><li>rehashidx 的数值就是现在 rehash 的元素位置</li><li>rehashidx 等于 -1 的时候说明没有在进行 refresh</li></ul><p><img src="/blog/assets/database/redis/rehashidx.png" alt="rehashidx"></p><p>甚至在进行期间，每次对哈希表的增删改查操作，除了正常执行之外，还会顺带将 ht[0]哈希表相关键值对 rehash 到 ht[1]。</p><p>以扩容步骤为例：<br><img src="/blog/assets/database/redis/hash_refresh_slow.gif" alt="hash_refresh_slow"></p><p><strong>intset</strong><br>整数集合是集合键的底层实现方式之一。<br><img src="/blog/assets/database/redis/inset.png" alt="inset"></p><p><strong>跳表</strong><br>跳表这种数据结构长这样：<br><img src="/blog/assets/database/redis/skiplist.png" alt="skiplist"></p><h2 id="redis-中把跳表抽象成如下所示："><a href="#redis-中把跳表抽象成如下所示：" class="headerlink" title="redis 中把跳表抽象成如下所示："></a>redis 中把跳表抽象成如下所示：</h2><p><img src="/blog/assets/database/redis/skiplist1.png" alt="skiplist1"></p><p>看这个图，左边“统筹”，右边实现。<br>统筹部分有以下几点说明：</p><ul><li>header: 跳表表头</li><li>tail:跳表表尾</li><li>level:层数最大的那个节点的层数</li><li>length：跳表的长度</li></ul><p>实现部分有以下几点说明：</p><ul><li>表头：是链表的哨兵节点，不记录主体数据。</li><li>是个双向链表</li><li>分值是有顺序的</li><li>o1、o2、o3 是节点所保存的成员，是一个指针，可以指向一个 SDS 值。</li><li>层级高度最高是 32。没每次创建一个新的节点的时候，程序都会随机生成一个介于 1 和 32 之间的值作为 level 数组的大小，这个大小就是“高度”</li></ul><p><strong>redis 五种数据结构的实现</strong><br>redis 对象<br>redis 中并没有直接使用以上所说的各种数据结构来实现键值数据库，而是基于一种对象，对象底层再间接的引用上文所说的具体的数据结构。</p><p>结构如下图：<br><img src="/blog/assets/database/redis/object_ptr.png" alt="object_ptr"></p><p>字符串<br><img src="/blog/assets/database/redis/object_string.png" alt="object_string"></p><p>其中：embstr 和 raw 都是由 SDS 动态字符串构成的。唯一区别是：raw 是分配内存的时候，redisobject 和 sds 各分配一块内存，而 embstr 是 redisobject 和 raw 在一块儿内存中。</p><p><strong>列表</strong><br><img src="/blog/assets/database/redis/object_list.png" alt="object_list"></p><p><strong>hash</strong><br><img src="/blog/assets/database/redis/object_hash.png" alt="object_hash"></p><p><strong>set</strong><br><img src="/blog/assets/database/redis/object_set.png" alt="object_set"></p><p><strong>zset</strong><br><img src="/blog/assets/database/redis/object_zset.png" alt="object_zset"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://throwsnew.com/2017/09/12/%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%BD%BF%E7%94%A8ziplist%E8%83%BD%E8%8A%82%E7%9C%81%E5%86%85%E5%AD%98/" target="_blank" rel="noopener">https://throwsnew.com/2017/09/12/%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%BD%BF%E7%94%A8ziplist%E8%83%BD%E8%8A%82%E7%9C%81%E5%86%85%E5%AD%98/</a></li><li>《redis 设计与实现》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis 有五种基本数据结构：字符串、hash、set、zset、list。但是你知道构成这五种结构的底层数据结构是怎样的吗？&lt;br&gt;今天我们来花费五分钟的时间了解一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="redis" scheme="http://linthan.github.io/blog/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出一致性Hash原理</title>
    <link href="http://linthan.github.io/blog/2020/07/20/tech/algorithm/daiery-2020-0720-2000/"/>
    <id>http://linthan.github.io/blog/2020/07/20/tech/algorithm/daiery-2020-0720-2000/</id>
    <published>2020-07-20T02:00:00.000Z</published>
    <updated>2020-07-20T13:29:30.657Z</updated>
    
    <content type="html"><![CDATA[<p>一、前言<br>在解决分布式系统中负载均衡的问题时候可以使用 Hash 算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡的作用。</p><p>但是普通的余数 hash（hash(比如用户 id)%服务器机器数）算法伸缩性很差，当新增或者下线服务器机器时候，用户 id 与服务器的映射关系会大量失效。一致性 hash 则利用 hash 环对其进行了改进。</p><p>为了能直观的理解一致性 hash 原理，这里结合一个简单的例子来讲解，假设有 4 台服务器，地址为 ip1,ip2,ip3,ip4。</p><p>一致性 hash 是首先计算四个 ip 地址对应的 hash 值<br>hash(ip1),hash(ip2),hash(ip3),hash(ip3)，计算出来的 hash 值是 0~最大正整数直接的一个值，这四个值在一致性 hash 环上呈现如下图：</p><p><img src="/blog/assets/algorithm/chash.webp" alt="chash"></p><a id="more"></a><p>hash 环上顺时针从整数 0 开始，一直到最大正整数，我们根据四个 ip 计算的 hash 值肯定会落到这个 hash 环上的某一个点，至此我们把服务器的四个 ip 映射到了一致性 hash 环</p><p>当用户在客户端进行请求时候，首先根据 hash(用户 id)计算路由规则（hash 值），然后看 hash 值落到了 hash 环的那个地方，根据 hash 值在 hash 环上的位置顺时针找距离最近的 ip 作为路由 ip.<br><img src="/blog/assets/algorithm/chash1.webp" alt="chash1"></p><p>如上图可知 user1,user2 的请求会落到服务器 ip2 进行处理，User3 的请求会落到服务器 ip3 进行处理，user4 的请求会落到服务器 ip4 进行处理，user5,user6 的请求会落到服务器 ip1 进行处理。</p><p>下面考虑当 ip2 的服务器挂了的时候会出现什么情况？<br>当 ip2 的服务器挂了的时候，一致性 hash 环大致如下图：<br><img src="/blog/assets/algorithm/chash2.webp" alt="chash2"></p><p>根据顺时针规则可知 user1,user2 的请求会被服务器 ip3 进行处理，而其它用户的请求对应的处理服务器不变，也就是只有之前被 ip2 处理的一部分用户的映射关系被破坏了，并且其负责处理的请求被顺时针下一个节点委托处理。</p><p>下面考虑当新增机器的时候会出现什么情况？<br>当新增一个 ip5 的服务器后，一致性 hash 环大致如下图：<br><img src="/blog/assets/algorithm/chash3.webp" alt="chash3"></p><p>根据顺时针规则可知之前 user5 的请求应该被 ip5 服务器处理，现在被新增的 ip5 服务器处理，其他用户的请求处理服务器不变，也就是新增的服务器顺时针最近的服务器的一部分请求会被新增的服务器所替代。</p><h2 id="三、一致性-hash-的特性"><a href="#三、一致性-hash-的特性" class="headerlink" title="三、一致性 hash 的特性"></a>三、一致性 hash 的特性</h2><ul><li><p>单调性(Monotonicity)，单调性是指如果已经有一些请求通过哈希分派到了相应的服务器进行处理，又有新的服务器加入到系统中时候，应保证原有的请求可以被映射到原有的或者新的服务器中去，而不会被映射到原来的其它服务器上去。 这个通过上面新增服务器 ip5 可以证明，新增 ip5 后，原来被 ip1 处理的 user6 现在还是被 ip1 处理，原来被 ip1 处理的 user5 现在被新增的 ip5 处理。</p></li><li><p>分散性(Spread)：分布式环境中，客户端请求时候可能不知道所有服务器的存在，可能只知道其中一部分服务器，在客户端看来他看到的部分服务器会形成一个完整的 hash 环。如果多个客户端都把部分服务器作为一个完整 hash 环，那么可能会导致，同一个用户的请求被路由到不同的服务器进行处理。这种情况显然是应该避免的，因为它不能保证同一个用户的请求落到同一个服务器。所谓分散性是指上述情况发生的严重程度。好的哈希算法应尽量避免尽量降低分散性。 一致性 hash 具有很低的分散性</p></li><li><p>平衡性(Balance)：平衡性也就是说负载均衡，是指客户端 hash 后的请求应该能够分散到不同的服务器上去。一致性 hash 可以做到每个服务器都进行处理请求，但是不能保证每个服务器处理的请求的数量大致相同，如下图<br><img src="/blog/assets/algorithm/chash4.webp" alt="chash4"><br>服务器 ip1,ip2,ip3 经过 hash 后落到了一致性 hash 环上，从图中 hash 值分布可知 ip1 会负责处理大概 80%的请求，而 ip2 和 ip3 则只会负责处理大概 20%的请求，虽然三个机器都在处理请求，但是明显每个机器的负载不均衡，这样称为一致性 hash 的倾斜，虚拟节点的出现就是为了解决这个问题。</p></li></ul><h2 id="五、虚拟节点"><a href="#五、虚拟节点" class="headerlink" title="五、虚拟节点"></a>五、虚拟节点</h2><p>当服务器节点比较少的时候会出现上节所说的一致性 hash 倾斜的问题，一个解决方法是多加机器，但是加机器是有成本的，那么就加虚拟节点，比如上面三个机器，每个机器引入 1 个虚拟节点后的一致性 hash 环的图如下：<br><img src="/blog/assets/algorithm/chash5.webp" alt="chash5"></p><p>其中 ip1-1 是 ip1 的虚拟节点，ip2-1 是 ip2 的虚拟节点，ip3-1 是 ip3 的虚拟节点。<br>可知当物理机器数目为 M，虚拟节点为 N 的时候，实际 hash 环上节点个数为 M*N。比如当客户端计算的 hash 值处于 ip2 和 ip3 或者处于 ip2-1 和 ip3-1 之间时候使用 ip3 服务器进行处理。</p><h2 id="六、均匀一致性-hash"><a href="#六、均匀一致性-hash" class="headerlink" title="六、均匀一致性 hash"></a>六、均匀一致性 hash</h2><p>上节我们使用虚拟节点后的图看起来比较均衡，但是如果生成虚拟节点的算法不够好很可能会得到下面的环：<br><img src="/blog/assets/algorithm/chash6.webp" alt="chash6"><br>可知每个服务节点引入 1 个虚拟节点后，情况相比没有引入前均衡性有所改善，但是并不均衡。</p><p>均衡的一致性 hash 应该是如下图：<br><img src="/blog/assets/algorithm/chash7.webp" alt="chash7"></p><p>均匀一致性 hash 的目标是如果服务器有 N 台，客户端的 hash 值有 M 个，那么每个服务器应该处理大概 M/N 个用户的。也就是每台服务器负载尽量均衡</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>在分布式系统中一致性 hash 起着不可忽略的地位，无论是分布式缓存，还是分布式 Rpc 框架的负载均衡策略都有所使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、前言&lt;br&gt;在解决分布式系统中负载均衡的问题时候可以使用 Hash 算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡的作用。&lt;/p&gt;
&lt;p&gt;但是普通的余数 hash（hash(比如用户 id)%服务器机器数）算法伸缩性很差，当新增或者下线服务器机器时候，用户 id 与服务器的映射关系会大量失效。一致性 hash 则利用 hash 环对其进行了改进。&lt;/p&gt;
&lt;p&gt;为了能直观的理解一致性 hash 原理，这里结合一个简单的例子来讲解，假设有 4 台服务器，地址为 ip1,ip2,ip3,ip4。&lt;/p&gt;
&lt;p&gt;一致性 hash 是首先计算四个 ip 地址对应的 hash 值&lt;br&gt;hash(ip1),hash(ip2),hash(ip3),hash(ip3)，计算出来的 hash 值是 0~最大正整数直接的一个值，这四个值在一致性 hash 环上呈现如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/assets/algorithm/chash.webp&quot; alt=&quot;chash&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="算法" scheme="http://linthan.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="面试" scheme="http://linthan.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁之Redis实现</title>
    <link href="http://linthan.github.io/blog/2020/07/17/tech/redis/daiery-2020-0717-1100/"/>
    <id>http://linthan.github.io/blog/2020/07/17/tech/redis/daiery-2020-0717-1100/</id>
    <published>2020-07-17T03:00:00.000Z</published>
    <updated>2020-07-17T03:33:39.543Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 中，关于锁我想大家都很熟悉。在并发编程中，我们通过锁，来避免由于竞争而造成的数据不一致问题。通常，我们以 synchronized 、Lock 来使用它。</p><p>但是 Java 中的锁，只能保证在同一个 JVM 进程内中执行。如果在分布式集群环境下呢？</p><a id="more"></a><h2 id="一、分布式锁"><a href="#一、分布式锁" class="headerlink" title="一、分布式锁"></a>一、分布式锁</h2><p>分布式锁，是一种思想，它的实现方式有很多。比如，我们将沙滩当做分布式锁的组件，那么它看起来应该是这样的：</p><p>加锁<br>在沙滩上踩一脚，留下自己的脚印，就对应了加锁操作。其他进程或者线程，看到沙滩上已经有脚印，证明锁已被别人持有，则等待。</p><p>解锁<br>把脚印从沙滩上抹去，就是解锁的过程。</p><p>锁超时<br>为了避免死锁，我们可以设置一阵风，在单位时间后刮起，将脚印自动抹去。</p><p>分布式锁的实现有很多，比如基于数据库、memcached、Redis、系统文件、zookeeper 等。它们的核心的理念跟上面的过程大致相同。</p><h2 id="二、redis"><a href="#二、redis" class="headerlink" title="二、redis"></a>二、redis</h2><p>我们先来看如何通过单节点 Redis 实现一个简单的分布式锁。</p><h2 id="1、加锁"><a href="#1、加锁" class="headerlink" title="1、加锁"></a>1、加锁</h2><p>加锁实际上就是在 redis 中，给 Key 键设置一个值，为避免死锁，并给定一个过期时间。</p><p>SET lock_key random_value NX PX 5000</p><p>值得注意的是：<br>random_value 是客户端生成的唯一的字符串。<br>NX 代表只在键不存在时，才对键进行设置操作。<br>PX 5000 设置键的过期时间为 5000 毫秒。</p><p>这样，如果上面的命令执行成功，则证明客户端获取到了锁。</p><h2 id="2、解锁"><a href="#2、解锁" class="headerlink" title="2、解锁"></a>2、解锁</h2><p>解锁的过程就是将 Key 键删除。但也不能乱删，不能说客户端 1 的请求将客户端 2 的锁给删除掉。这时候 random_value 的作用就体现出来。</p><p>为了保证解锁操作的原子性，我们用 LUA 脚本完成这一操作。先判断当前锁的字符串是否与传入的值相等，是的话就删除 Key，解锁成功。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">'get'</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">return</span> redis.call(<span class="string">'del'</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h1><p>首先，我们在 pom 文件中，引入 Jedis。在这里，笔者用的是最新版本，注意由于版本的不同，API 可能有所差异。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>加锁的过程很简单，就是通过 SET 指令来设置值，成功则返回；否则就循环等待，在 timeout 时间内仍未获取到锁，则获取失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lock_key = <span class="string">"redis_lock"</span>; <span class="comment">//锁键</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> internalLockLeaseTime = <span class="number">30000</span>;<span class="comment">//锁过期时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout = <span class="number">999999</span>; <span class="comment">//获取锁的超时时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//SET命令的参数</span></span><br><span class="line">    SetParams params = SetParams.setParams().nx().px(internalLockLeaseTime);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        Jedis jedis = jedisPool.getResource();</span><br><span class="line">        Long start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                <span class="comment">//SET命令返回OK ，则证明获取锁成功</span></span><br><span class="line">                String lock = jedis.set(lock_key, id, params);</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"OK"</span>.equals(lock))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则循环等待，在timeout时间内仍未获取到锁，则获取失败</span></span><br><span class="line">                <span class="keyword">long</span> l = System.currentTimeMillis() - start;</span><br><span class="line">                <span class="keyword">if</span> (l&gt;=timeout) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解锁我们通过 jedis.eval 来执行一段 LUA 就可以。将锁的 Key 键和生成的字符串当做参数传进来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        Jedis jedis = jedisPool.getResource();</span><br><span class="line">        String script =</span><br><span class="line">                <span class="string">"if redis.call('get',KEYS[1]) == ARGV[1] then"</span> +</span><br><span class="line">                        <span class="string">"   return redis.call('del',KEYS[1]) "</span> +</span><br><span class="line">                        <span class="string">"else"</span> +</span><br><span class="line">                        <span class="string">"   return 0 "</span> +</span><br><span class="line">                        <span class="string">"end"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object result = jedis.eval(script, Collections.singletonList(lock_key),</span><br><span class="line">                                    Collections.singletonList(id));</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"1"</span>.equals(result.toString()))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后，我们可以在多线程环境下测试一下。我们开启 1000 个线程，对 count 进行累加。调用的时候，关键是唯一字符串的生成。这里，笔者使用的是 Snowflake 算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisLock redisLock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> clientcount =<span class="number">1000</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientcount);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(clientcount);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;clientcount;i++)&#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//通过Snowflake算法获取唯一的ID字符串</span></span><br><span class="line">                String id = IdUtil.getId();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    redisLock.lock(id);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    redisLock.unlock(id);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="string">"执行线程数:&#123;&#125;,总耗时:&#123;&#125;,count数为:&#123;&#125;"</span>,clientcount,end-start,count);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，单节点 Redis 的分布式锁的实现就已经完成了。比较简单，但是问题也比较大，最重要的一点是，锁不具有可重入性。</p><h2 id="三、redisson"><a href="#三、redisson" class="headerlink" title="三、redisson"></a>三、redisson</h2><p>Redisson 是架设在 Redis 基础上的一个 Java 驻内存数据网格（In-Memory Data Grid）。充分的利用了 Redis 键值数据库提供的一系列优势，基于 Java 实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。</p><p>相对于 Jedis 而言，Redisson 强大的一批。当然了，随之而来的就是它的复杂性。它里面也实现了分布式锁，而且包含多种类型的锁，更多请参阅<a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8" target="_blank" rel="noopener">分布式锁和同步器</a></p><h3 id="1、可重入锁"><a href="#1、可重入锁" class="headerlink" title="1、可重入锁"></a>1、可重入锁</h3><p>上面我们自己实现的 Redis 分布式锁，其实不具有可重入性。那么下面我们先来看看 Redisson 中如何调用可重入锁。</p><p>在这里，笔者使用的是它的最新版本，3.10.1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.10.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>首先，通过配置获取 RedissonClient 客户端的实例，然后 getLock 获取锁的实例，进行操作即可。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Config config = <span class="built_in">new</span> Config();</span><br><span class="line">    config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6379"</span>);</span><br><span class="line">    config.useSingleServer().setPassword(<span class="string">"redis1234"</span>);</span><br><span class="line"></span><br><span class="line">    final RedissonClient client = Redisson.create(config);</span><br><span class="line">    RLock lock = client.getLock(<span class="string">"lock1"</span>);</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、获取锁实例"><a href="#2、获取锁实例" class="headerlink" title="2、获取锁实例"></a>2、获取锁实例</h3><p>我们先来看 RLock lock = client.getLock(“lock1”); 这句代码就是为了获取锁的实例，然后我们可以看到它返回的是一个 RedissonLock 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RLock <span class="title">getLock</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedissonLock(connectionManager.getCommandExecutor(), name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 RedissonLock 构造方法中，主要初始化一些属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedissonLock</span><span class="params">(CommandAsyncExecutor commandExecutor, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(commandExecutor, name);</span><br><span class="line">    <span class="comment">//命令执行器</span></span><br><span class="line">    <span class="keyword">this</span>.commandExecutor = commandExecutor;</span><br><span class="line">    <span class="comment">//UUID字符串</span></span><br><span class="line">    <span class="keyword">this</span>.id = commandExecutor.getConnectionManager().getId();</span><br><span class="line">    <span class="comment">//内部锁过期时间</span></span><br><span class="line">    <span class="keyword">this</span>.internalLockLeaseTime = commandExecutor.</span><br><span class="line">                getConnectionManager().getCfg().getLockWatchdogTimeout();</span><br><span class="line">    <span class="keyword">this</span>.entryName = id + <span class="string">":"</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、加锁"><a href="#3、加锁" class="headerlink" title="3、加锁"></a>3、加锁</h3><p>当我们调用 lock 方法，定位到 lockInterruptibly。在这里，完成了加锁的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前线程ID</span></span><br><span class="line">    <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">//尝试获取锁</span></span><br><span class="line">    Long ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">    <span class="comment">// 如果ttl为空，则证明获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果获取锁失败，则订阅到对应这个锁的channel</span></span><br><span class="line">    RFuture&lt;RedissonLockEntry&gt; future = subscribe(threadId);</span><br><span class="line">    commandExecutor.syncSubscription(future);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//再次尝试获取锁</span></span><br><span class="line">            ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">            <span class="comment">//ttl为空，说明成功获取锁，返回</span></span><br><span class="line">            <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ttl大于0 则等待ttl时间后继续尝试获取</span></span><br><span class="line">            <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                getEntry(threadId).getLatch().acquire();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//取消对channel的订阅</span></span><br><span class="line">        unsubscribe(future, threadId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get(lockAsync(leaseTime, unit));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，就是加锁的全过程。先调用 tryAcquire 来获取锁，如果返回值 ttl 为空，则证明加锁成功，返回；如果不为空，则证明加锁失败。这时候，它会订阅这个锁的 Channel，等待锁释放的消息，然后重新尝试获取锁。流程如下：<br><img src="/blog/assets/database/redis/redis_lock.webp" alt="redis_lock"></p><h3 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h3><p>获取锁的过程是怎样的呢？接下来就要看 tryAcquire 方法。在这里，它有两种处理方式，一种是带有过期时间的锁，一种是不带过期时间的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果带有过期时间，则按照普通方式获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先按照30秒的过期时间来执行获取锁的方法</span></span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(</span><br><span class="line">        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果还持有这个锁，则开启定时任务不断刷新该锁的过期时间</span></span><br><span class="line">    ttlRemainingFuture.addListener(<span class="keyword">new</span> FutureListener&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Long&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Long ttlRemaining = future.getNow();</span><br><span class="line">            <span class="comment">// lock acquired</span></span><br><span class="line">            <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduleExpirationRenewal(threadId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着往下看，tryLockInnerAsync 方法是真正执行获取锁的逻辑，它是一段 LUA 脚本代码。在这里，它使用的是 hash 数据结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//过期时间</span></span><br><span class="line">        internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">                  <span class="comment">//如果锁不存在，则通过hset设置它的值，并设置过期时间</span></span><br><span class="line">                  <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><br><span class="line">                      <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                      <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                      <span class="string">"return nil; "</span> +</span><br><span class="line">                  <span class="string">"end; "</span> +</span><br><span class="line">                  <span class="comment">//如果锁已存在，并且锁的是当前线程，则通过hincrby给数值递增1</span></span><br><span class="line">                  <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><br><span class="line">                      <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                      <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                      <span class="string">"return nil; "</span> +</span><br><span class="line">                  <span class="string">"end; "</span> +</span><br><span class="line">                  <span class="comment">//如果锁已存在，但并非本线程，则返回过期时间ttl</span></span><br><span class="line">                  <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span><br><span class="line">        Collections.&lt;Object&gt;singletonList(getName()),</span><br><span class="line">                internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段 LUA 代码看起来并不复杂，有三个判断：</p><p>通过 exists 判断，如果锁不存在，则设置值和过期时间，加锁成功<br>通过 hexists 判断，如果锁已存在，并且锁的是当前线程，则证明是重入锁，加锁成功<br>如果锁已存在，但锁的不是当前线程，则证明有其他线程持有锁。返回当前锁的过期时间，加锁失败<br><img src="/blog/assets/database/redis/redis_lock_dual.webp" alt="redis_lock_dual"><br>加锁成功后，在 redis 的内存数据中，就有一条 hash 结构的数据。Key 为锁的名称；field 为随机字符串+线程 ID；值为 1。如果同一线程多次调用 lock 方法，值递增 1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall lock1</span><br><span class="line">1) &quot;b5ae0be4-5623-45a5-8faa-ab7eb167ce87:1&quot;</span><br><span class="line">2) &quot;1&quot;</span><br></pre></td></tr></table></figure><h2 id="4、解锁"><a href="#4、解锁" class="headerlink" title="4、解锁"></a>4、解锁</h2><p>我们通过调用 unlock 方法来解锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title">unlockAsync</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RPromise&lt;Void&gt; result = <span class="keyword">new</span> RedissonPromise&lt;Void&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁方法</span></span><br><span class="line">    RFuture&lt;Boolean&gt; future = unlockInnerAsync(threadId);</span><br><span class="line"></span><br><span class="line">    future.addListener(<span class="keyword">new</span> FutureListener&lt;Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Boolean&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                cancelExpirationRenewal(threadId);</span><br><span class="line">                result.tryFailure(future.cause());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取返回值</span></span><br><span class="line">            Boolean opStatus = future.getNow();</span><br><span class="line">            <span class="comment">//如果返回空，则证明解锁的线程和当前锁不是同一个线程，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (opStatus == <span class="keyword">null</span>) &#123;</span><br><span class="line">                IllegalMonitorStateException cause =</span><br><span class="line">                    <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"</span></span><br><span class="line"><span class="string">                        attempt to unlock lock, not locked by current thread by node id: "</span></span><br><span class="line">                        + id + <span class="string">" thread-id: "</span> + threadId);</span><br><span class="line">                result.tryFailure(cause);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//解锁成功，取消刷新过期时间的那个定时任务</span></span><br><span class="line">            <span class="keyword">if</span> (opStatus) &#123;</span><br><span class="line">                cancelExpirationRenewal(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            result.trySuccess(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再看 unlockInnerAsync 方法。这里也是一段 LUA 脚本代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, EVAL,</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果锁已经不存在， 发布锁释放的消息</span></span><br><span class="line">            <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><br><span class="line">                <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">                <span class="string">"return 1; "</span> +</span><br><span class="line">            <span class="string">"end;"</span> +</span><br><span class="line">            <span class="comment">//如果释放锁的线程和已存在锁的线程不是同一个线程，返回null</span></span><br><span class="line">            <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> +</span><br><span class="line">                <span class="string">"return nil;"</span> +</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">            <span class="comment">//通过hincrby递减1的方式，释放一次锁</span></span><br><span class="line">            <span class="comment">//若剩余次数大于0 ，则刷新过期时间</span></span><br><span class="line">            <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span><br><span class="line">            <span class="string">"if (counter &gt; 0) then "</span> +</span><br><span class="line">                <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span><br><span class="line">                <span class="string">"return 0; "</span> +</span><br><span class="line">            <span class="comment">//否则证明锁已经释放，删除key并发布锁释放的消息</span></span><br><span class="line">            <span class="string">"else "</span> +</span><br><span class="line">                <span class="string">"redis.call('del', KEYS[1]); "</span> +</span><br><span class="line">                <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">                <span class="string">"return 1; "</span>+</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">            <span class="string">"return nil;"</span>,</span><br><span class="line">    Arrays.&lt;Object&gt;asList(getName(), getChannelName()),</span><br><span class="line">        LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，就是释放锁的逻辑。同样的，它也是有三个判断：</p><ul><li>如果锁已经不存在，通过 publish 发布锁释放的消息，解锁成功</li><li>如果解锁的线程和当前锁的线程不是同一个，解锁失败，抛出异常</li><li>通过 hincrby 递减 1，先释放一次锁。若剩余次数还大于 0，则证明当前锁是重入锁，刷新过期时间；若剩余次数小于 0，删除 key 并发布锁释放的消息，解锁成功</li></ul><p><img src="/blog/assets/database/redis/redis_unlock.webp" alt="redis_unlock"></p><p>至此，Redisson 中的可重入锁的逻辑，就分析完了。但值得注意的是，上面的两种实现方式都是针对单机 Redis 实例而进行的。如果我们有多个 Redis 实例，请参阅 Redlock 算法。该算法的具体内容，请参考<a href="http://redis.cn/topics/distlock.html" target="_blank" rel="noopener">http://redis.cn/topics/distlock.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Java 中，关于锁我想大家都很熟悉。在并发编程中，我们通过锁，来避免由于竞争而造成的数据不一致问题。通常，我们以 synchronized 、Lock 来使用它。&lt;/p&gt;
&lt;p&gt;但是 Java 中的锁，只能保证在同一个 JVM 进程内中执行。如果在分布式集群环境下呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="redis" scheme="http://linthan.github.io/blog/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>几率大的Redis面试题（</title>
    <link href="http://linthan.github.io/blog/2020/07/17/tech/redis/daiery-2020-0717-1000/"/>
    <id>http://linthan.github.io/blog/2020/07/17/tech/redis/daiery-2020-0717-1000/</id>
    <published>2020-07-17T02:00:00.000Z</published>
    <updated>2020-07-17T02:45:22.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文的面试题如下："><a href="#本文的面试题如下：" class="headerlink" title="本文的面试题如下："></a>本文的面试题如下：</h2><p>Redis 持久化机制<br>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题<br>热点数据和冷数据是什么<br>Memcache 与 Redis 的区别都有哪些？<br>单线程的 redis 为什么这么快<br>redis 的数据类型，以及每种数据类型的使用场景，Redis 内部结构<br>redis 的过期策略以及内存淘汰机制【～】<br>Redis 为什么是单线程的，优点<br>如何解决 redis 的并发竞争 key 问题<br>Redis 集群方案应该怎么做？都有哪些方案？<br>有没有尝试进行多机 redis 的部署？如何保证数据一致的？<br>对于大量的请求怎么样处理<br>Redis 常见性能问题和解决方案？<br>讲解下 Redis 线程模型<br>为什么 Redis 的操作是原子性的，怎么保证原子性的？<br>Redis 事务<br>Redis 实现分布式锁</p><a id="more"></a><h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><p>Redis 是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当 Redis 重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。<br>实现：单独创建 fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。</p><p>RDB 是 Redis 默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即 Snapshot 快照存储，对应产生的数据文件为 dump.rdb，通过配置文件中的 save 参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。）<br>AOF：Redis 会将每一个收到的写命令都通过 Write 函数追加到文件最后，类似于 MySQL 的 binlog。当 Redis 重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。<br>当两种方式同时开启时，数据恢复 Redis 会优先选择 AOF 恢复。</p><h2 id="缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题"><a href="#缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题" class="headerlink" title="缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题"></a>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</h2><p><strong>缓存雪崩</strong>我们可以简单的理解为：由于原有缓存失效，新缓存未到期间<br>(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。<br><strong>解决办法：</strong><br>大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时将缓存失效时间分散开。</p><h3 id="二、缓存穿透"><a href="#二、缓存穿透" class="headerlink" title="二、缓存穿透"></a>二、缓存穿透</h3><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。<br><strong>解决办法</strong><br>最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。<br>另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。<br>5TB 的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些 32bit 大小的数据该如何解决？如果是 64bit 的呢？</p><p>对于空间的利用到达了一种极致，那就是 Bitmap 和布隆过滤器(Bloom Filter)。<br>Bitmap： 典型的就是哈希表<br>缺点是，Bitmap 对于每个元素只能记录 1bit 信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p><p><strong>布隆过滤器（推荐）</strong><br>就是引入了 k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。<br>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。<br>Bloom-Filter 算法的核心思想就是利用多个不同的 Hash 函数来解决“冲突”。<br>Hash 存在一个冲突（碰撞）的问题，用同一个 Hash 得到的两个 URL 的值有可能相同。为了减少冲突，我们可以多引入几个 Hash，如果通过其中的一个 Hash 值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的 Hash 函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是 Bloom-Filter 的基本思想。<br>Bloom-Filter 一般用于在大数据量的集合中判定某元素是否存在。</p><p><strong>受提醒补充：缓存穿透与缓存击穿的区别</strong><br><strong>缓存击穿：</strong> 指一个 key 非常热点，大并发集中对这个 key 进行访问，当这个 key 在失效的瞬间，仍然持续的大并发访问就穿破缓存，转而直接请求数据库。<br>解决方案;在访问 key 之前，采用 SETNX（set if not exists）来设置另一个短期 key 来锁住当前 key 的访问，访问结束再删除该短期 key。</p><h3 id="四、缓存更新"><a href="#四、缓存更新" class="headerlink" title="四、缓存更新"></a>四、缓存更新</h3><p>除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：<br>（1）定时去清理过期的缓存；<br>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。<br>两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p><h3 id="五、缓存降级"><a href="#五、缓存降级" class="headerlink" title="五、缓存降级"></a>五、缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。<br>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。<br>以参考日志级别设置预案：<br>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；<br>（2）警告：有些服务在一段时间内成功率有波动（如在 95~100%之间），可以自动降级或人工降级，并发送告警；<br>（3）错误：比如可用率低于 90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；<br>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p><p>服务降级的目的，是为了防止 Redis 服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis 出现问题，不去数据库查询，而是直接返回默认值给用户。</p><h2 id="热点数据和冷数据是什么"><a href="#热点数据和冷数据是什么" class="headerlink" title="热点数据和冷数据是什么"></a>热点数据和冷数据是什么</h2><p>热点数据，缓存才有价值<br>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存<br>对于上面两个例子，寿星列表、导航信息都存在一个特点，就是信息修改频率不高，读取通常非常高的场景。<br>对于热点数据，比如我们的某 IM 产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。<br><strong>数据更新前至少读取两次，</strong>缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。<br>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到 Redis 缓存，减少数据库压力。</p><h2 id="Memcache-与-Redis-的区别都有哪些？"><a href="#Memcache-与-Redis-的区别都有哪些？" class="headerlink" title="Memcache 与 Redis 的区别都有哪些？"></a>Memcache 与 Redis 的区别都有哪些？</h2><p>1)、存储方式 Memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis 有部份存在硬盘上，redis 可以持久化其数据 2)、数据支持类型 memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型 ，提供 list，set，zset，hash 等数据结构的存储 3)、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。<br>4). value 值大小不同：Redis 最大可以达到 512M；memcache 只有 1mb。<br>5）redis 的速度比 memcached 快很多<br>6）Redis 支持数据的备份，即 master-slave 模式的数据备份。</p><h2 id="单线程的-redis-为什么这么快"><a href="#单线程的-redis-为什么这么快" class="headerlink" title="单线程的 redis 为什么这么快"></a>单线程的 redis 为什么这么快</h2><p>(一)纯内存操作<br>(二)单线程操作，避免了频繁的上下文切换<br>(三)采用了非阻塞 I/O 多路复用机制</p><h2 id="redis-的数据类型，以及每种数据类型的使用场景"><a href="#redis-的数据类型，以及每种数据类型的使用场景" class="headerlink" title="redis 的数据类型，以及每种数据类型的使用场景"></a>redis 的数据类型，以及每种数据类型的使用场景</h2><p>回答：一共五种<br>(一)String<br>这个其实没啥好说的，最常规的 set/get 操作，value 可以是 String 也可以是数字。一般做一些复杂的计数功能的缓存。<br>(二)hash<br>这里 value 存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以 cookieId 作为 key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 session 的效果。<br>(三)list<br>使用 List 的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用 lrange 命令，做基于 redis 的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST 可以很好的完成排队，先进先出的原则。<br>(四)set<br>因为 set 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用 JVM 自带的 Set 进行去重？因为我们的系统一般都是集群部署，使用 JVM 自带的 Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。<br>另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。<br>(五)sorted set<br>sorted set 多了一个权重参数 score,集合中的元素能够按 score 进行排列。可以做排行榜应用，取 TOP N 操作。</p><h2 id="Redis-内部结构"><a href="#Redis-内部结构" class="headerlink" title="Redis 内部结构"></a>Redis 内部结构</h2><p>dict 本质上是为了解决算法中的查找问题（Searching）是一个用于维护 key 和 value 映射关系的数据结构，与很多语言中的 Map 或 dictionary 类似。 本质上是为了解决算法中的查找问题（Searching）<br>sds sds 就等同于 char * 它可以存储任意二进制数据，不能像 C 语言字符串那样以字符’\0’来标识字符串的结 束，因此它必然有个长度字段。<br>skiplist （跳跃表） 跳表是一种实现起来很简单，单层多指针的链表，它查找效率很高，堪比优化过的二叉平衡树，且比平衡树的实现，<br>quicklist<br>ziplist 压缩表 ziplist 是一个编码后的列表，是由一系列特殊编码的连续内存块组成的顺序型数据结构，</p><h2 id="redis-的过期策略以及内存淘汰机制"><a href="#redis-的过期策略以及内存淘汰机制" class="headerlink" title="redis 的过期策略以及内存淘汰机制"></a>redis 的过期策略以及内存淘汰机制</h2><p>redis 采用的是定期删除+惰性删除策略。<br>为什么不用定时删除策略?<br>定时删除,用一个定时器来负责监视 key,过期则自动删除。虽然内存及时释放，但是十分消耗 CPU 资源。在大并发请求下，CPU 要将时间应用在处理请求，而不是删除 key,因此没有采用这一策略.<br>定期删除+惰性删除是如何工作的呢?<br>定期删除，redis 默认每个 100ms 检查，是否有过期的 key,有过期 key 则删除。需要说明的是，redis 不是每个 100ms 将所有的 key 检查一次，而是随机抽取进行检查(如果每隔 100ms,全部 key 进行检查，redis 岂不是卡死)。因此，如果只采用定期删除策略，会导致很多 key 到时间没有删除。<br>于是，惰性删除派上用场。也就是说在你获取某个 key 的时候，redis 会检查一下，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除。<br>采用定期删除+惰性删除就没其他问题了么?<br>不是的，如果定期删除没删除 key。然后你也没即时去请求 key，也就是说惰性删除也没生效。这样，redis 的内存会越来越高。那么就应该采用内存淘汰机制。<br>在 redis.conf 中有一行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure><p>配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)<br>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰<br>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰<br>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰<br>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰<br>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰<br>no-enviction（驱逐）：禁止驱逐数据，新写入操作会报错<br>ps：如果没有设置 expire 的 key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p><h2 id="Redis-为什么是单线程的"><a href="#Redis-为什么是单线程的" class="headerlink" title="Redis 为什么是单线程的"></a>Redis 为什么是单线程的</h2><p>官方 FAQ 表示，因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）Redis 利用队列技术将并发访问变为串行访问<br>1）绝大部分请求是纯粹的内存操作（非常快速）2）采用单线程,避免了不必要的上下文切换和竞争条件<br>3）非阻塞 IO 优点： 1.速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)</p><ol start="2"><li>支持丰富数据类型，支持 string，list，set，sorted set，hash 3.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li><li>丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除如何解决 redis 的并发竞争 key 问题</li></ol><p>同时有多个子系统去 set 一个 key。这个时候要注意什么呢？ 不推荐使用 redis 的事务机制。因为我们的生产环境，基本都是 redis 集群环境，做了数据分片操作。你一个事务中有涉及到多个 key 操作的时候，这多个 key 不一定都存储在同一个 redis-server 上。因此，redis 的事务机制，十分鸡肋。<br>(1)如果对这个 key 操作，不要求顺序： 准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可<br>(2)如果对这个 key 操作，要求顺序： 分布式锁+时间戳。 假设这会系统 B 先抢到锁，将 key1 设置为{valueB 3:05}。接下来系统 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了。以此类推。<br>(3) 利用队列，将 set 方法变成串行访问也可以 redis 遇到高并发，如果保证读写 key 的一致性<br>对 redis 的操作都是具有原子性的,是线程安全的操作,你不用考虑并发问题,redis 内部已经帮你处理好并发的问题了。</p><h2 id="Redis-集群方案应该怎么做？都有哪些方案？"><a href="#Redis-集群方案应该怎么做？都有哪些方案？" class="headerlink" title="Redis 集群方案应该怎么做？都有哪些方案？"></a>Redis 集群方案应该怎么做？都有哪些方案？</h2><p>1.twemproxy，大概概念是，它类似于一个代理方式， 使用时在本需要连接 redis 的地方改为连接 twemproxy， 它会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 redis，将结果再返回 twemproxy。<br>缺点： twemproxy 自身单端口实例的压力，使用一致性 hash 后，对 redis 节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。</p><p>2.codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新 hash 节点</p><p>3.redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</p><h2 id="有没有尝试进行多机-redis-的部署？如何保证数据一致的？"><a href="#有没有尝试进行多机-redis-的部署？如何保证数据一致的？" class="headerlink" title="有没有尝试进行多机 redis 的部署？如何保证数据一致的？"></a>有没有尝试进行多机 redis 的部署？如何保证数据一致的？</h2><p>主从复制，读写分离<br>一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</p><h2 id="对于大量的请求怎么样处理"><a href="#对于大量的请求怎么样处理" class="headerlink" title="对于大量的请求怎么样处理"></a>对于大量的请求怎么样处理</h2><p>redis 是一个单线程程序，也就说同一时刻它只能处理一个客户端请求；<br>redis 是通过 IO 多路复用（select，epoll, kqueue，依据不同的平台，采取不同的实现）来处理多个客户端请求的</p><h2 id="Redis-常见性能问题和解决方案？"><a href="#Redis-常见性能问题和解决方案？" class="headerlink" title="Redis 常见性能问题和解决方案？"></a>Redis 常见性能问题和解决方案？</h2><p>(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件<br>(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次<br>(3) 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内<br>(4) 尽量避免在压力很大的主库上增加从库<br>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即： Master &lt;- Slave1 &lt;- Slave2 &lt;-<br>Slave3…</p><h2 id="讲解下-Redis-线程模型"><a href="#讲解下-Redis-线程模型" class="headerlink" title="讲解下 Redis 线程模型"></a>讲解下 Redis 线程模型</h2><p>文件事件处理器包括分别是套接字、 I/O 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器。使用 I/O 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。<br>I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。</p><h2 id="讲解下-Redis-线程模型-1"><a href="#讲解下-Redis-线程模型-1" class="headerlink" title="讲解下 Redis 线程模型"></a>讲解下 Redis 线程模型</h2><p>文件事件处理器包括分别是套接字、 I/O 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器。使用 I/O 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。<br>I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。</p><p><strong>工作原理：</strong><br>1)I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。<br>尽管多个文件事件可能会并发地出现， 但 I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列， 以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字.<br><img src="/blog/assets/database/flow.png" alt="flow"></p><h2 id="为什么-Redis-的操作是原子性的，怎么保证原子性的？"><a href="#为什么-Redis-的操作是原子性的，怎么保证原子性的？" class="headerlink" title="为什么 Redis 的操作是原子性的，怎么保证原子性的？"></a>为什么 Redis 的操作是原子性的，怎么保证原子性的？</h2><p>对于 Redis 而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。<br>Redis 的操作之所以是原子性的，是因为 Redis 是单线程的。<br>Redis 本身提供的所有 API 都是原子操作，Redis 中的事务其实是要保证批量操作的原子性。<br>多个命令在并发中也是原子性的吗？<br>不一定， 将 get 和 set 改成单命令操作，incr 。使用 Redis 的事务，或者使用 Redis+Lua==的方式实现.</p><h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p>Redis 事务功能是通过 MULTI、EXEC、DISCARD 和 WATCH 四个原语实现的<br>Redis 会将一个事务中的所有命令序列化，然后按顺序执行。<br>1.redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。 2.如果在一个事务中的命令出现错误，那么所有的命令都不会执行； 3.如果在一个事务中出现运行错误，那么正确的命令会被执行。<br>注：redis 的 discard 只是结束本次事务,正确命令造成的影响仍然存在.</p><p>1）MULTI 命令用于开启一个事务，它总是返回 OK。 MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当 EXEC 命令被调用时，所有队列中的命令才会被执行。<br>2）EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。<br>3）通过调用 DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。<br>4）WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到 EXEC 命令。</p><h2 id="Redis-实现分布式锁"><a href="#Redis-实现分布式锁" class="headerlink" title="Redis 实现分布式锁"></a>Redis 实现分布式锁</h2><p>Redis 为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对 Redis 的连接并不存在竞争关系 Redis 中可以使用 SETNX 命令实现分布式锁。<br>将 key 的值设为 value ，当且仅当 key 不存在。 若给定的 key 已经存在，则 SETNX 不做任何动作</p><p>解锁：使用 del key 命令就能释放锁<br>解决死锁：<br>1）通过 Redis 中 expire()给锁设定最大持有时间，如果超过，则 Redis 来帮我们释放锁。<br>2） 使用 setnx key “当前系统时间+锁持有的时间”和 getset key “当前系统时间+锁持有的时间”组合的命令就可以实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;本文的面试题如下：&quot;&gt;&lt;a href=&quot;#本文的面试题如下：&quot; class=&quot;headerlink&quot; title=&quot;本文的面试题如下：&quot;&gt;&lt;/a&gt;本文的面试题如下：&lt;/h2&gt;&lt;p&gt;Redis 持久化机制&lt;br&gt;缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题&lt;br&gt;热点数据和冷数据是什么&lt;br&gt;Memcache 与 Redis 的区别都有哪些？&lt;br&gt;单线程的 redis 为什么这么快&lt;br&gt;redis 的数据类型，以及每种数据类型的使用场景，Redis 内部结构&lt;br&gt;redis 的过期策略以及内存淘汰机制【～】&lt;br&gt;Redis 为什么是单线程的，优点&lt;br&gt;如何解决 redis 的并发竞争 key 问题&lt;br&gt;Redis 集群方案应该怎么做？都有哪些方案？&lt;br&gt;有没有尝试进行多机 redis 的部署？如何保证数据一致的？&lt;br&gt;对于大量的请求怎么样处理&lt;br&gt;Redis 常见性能问题和解决方案？&lt;br&gt;讲解下 Redis 线程模型&lt;br&gt;为什么 Redis 的操作是原子性的，怎么保证原子性的？&lt;br&gt;Redis 事务&lt;br&gt;Redis 实现分布式锁&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="redis" scheme="http://linthan.github.io/blog/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>用Go撸一个二叉搜索树</title>
    <link href="http://linthan.github.io/blog/2020/07/17/tech/algorithm/daiery-2020-07-17-900/"/>
    <id>http://linthan.github.io/blog/2020/07/17/tech/algorithm/daiery-2020-07-17-900/</id>
    <published>2020-07-17T02:00:00.000Z</published>
    <updated>2020-07-20T13:19:24.914Z</updated>
    
    <content type="html"><![CDATA[<p>前几天 Redis 的作者 antirez 说他朋友面试的时候考到排序问题，然后他说要是他也会考实现一个二叉搜索树，我说在中国某公司，据说面试直接就撸一个红黑树。不是说你技术渣，试问在座的各位有几个现在直接裸写出红黑树？</p><p>红黑树太过偏门，但是常用的二叉搜索树你能写出来吗？快排呢？堆排序呢？</p><h2 id="什么是二叉搜索树"><a href="#什么是二叉搜索树" class="headerlink" title="什么是二叉搜索树"></a>什么是二叉搜索树</h2><p>二叉搜索树(binary search tree,BST)也叫排序的二叉树，根节点比左边子树的所有节点都大，比右边子树上的所有节点都小，如下图就是一个二叉搜索树:<br><img src="/blog/assets/algorithm/bst.png" alt="bst"></p><p>要实现一个二叉搜索树， 我们需要实现节点的插入和删除，要实现节点的查找(搜索)，要实现前序遍历、中序遍历和后序遍历，要实现最大节点和最小节点的查找。</p><p>下面就让我们实现这个二叉搜索树。</p><a id="more"></a><h2 id="定义基本数据结构"><a href="#定义基本数据结构" class="headerlink" title="定义基本数据结构"></a>定义基本数据结构</h2><p>常规地，我们定义节点的类型，每个节点包含它的值以及左右节点。因为目前 Go 泛型还没有发布，所以这里我们实现一个元素为 int 类型的具体的二叉搜索树，等泛型实现后可以改成抽象的二叉搜索树。</p><p>树只要包含根节点可以了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node 定义节点.</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">value <span class="keyword">int</span>   <span class="comment">// 因为目前Go的泛型还没有发布，所以我们这里以一个int具体类型为例</span></span><br><span class="line">left  *Node <span class="comment">// 左子节点</span></span><br><span class="line">right *Node <span class="comment">// 右子节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BST 是一个节点的值为int类型的二叉搜索树.</span></span><br><span class="line"><span class="keyword">type</span> BST <span class="keyword">struct</span> &#123;</span><br><span class="line">root *Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据结构有了，接下来就是实现各个方法。</p><h2 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h2><p>既然是一棵树，就需要增加节点用来构造树，大部分情况下也需要删除节点。</p><p>增加节点的时候，需要判断应该往左边子树上添加，还是往右边子树上添加。天然地，既然二叉搜索树是一个有序的，那么我们就可以进行比较，然后递归的实现。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Insert 插入一个元素.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bst *BST)</span> <span class="title">Insert</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">newNode := &amp;Node&#123;value, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="comment">// 如果二叉树为空，那么这个节点就当作跟节点</span></span><br><span class="line"><span class="keyword">if</span> bst.root == <span class="literal">nil</span> &#123;</span><br><span class="line">bst.root = newNode</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">insertNode(bst.root, newNode)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从根节点依次比较</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertNode</span><span class="params">(root, newNode *Node)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> newNode.value &lt; root.value &#123; <span class="comment">// 应该放到根节点的左边</span></span><br><span class="line"><span class="keyword">if</span> root.left == <span class="literal">nil</span> &#123;</span><br><span class="line">root.left = newNode</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">insertNode(root.left, newNode)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> newNode.value &gt; root.value &#123; <span class="comment">// 应该放到根节点的右边</span></span><br><span class="line"><span class="keyword">if</span> root.right == <span class="literal">nil</span> &#123;</span><br><span class="line">root.right = newNode</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">insertNode(root.right, newNode)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则等于根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除有些麻烦，如果是删除叶节点就比较容易，删除即可。但是如果不是删除叶节点，那么就需要将子节点提升。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove 删除一个元素.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bst *BST)</span> <span class="title">Remove</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">_, existed := remove(bst.root, value)</span><br><span class="line"><span class="keyword">return</span> existed</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用来递归移除节点的辅助方法.</span></span><br><span class="line"><span class="comment">// 返回替换root的新节点，以及元素是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(root *Node, value <span class="keyword">int</span>)</span> <span class="params">(*Node, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> existed <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// 从左边找</span></span><br><span class="line"><span class="keyword">if</span> value &lt; root.value &#123;</span><br><span class="line">root.left, existed = remove(root.left, value)</span><br><span class="line"><span class="keyword">return</span> root, existed</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从右边找</span></span><br><span class="line"><span class="keyword">if</span> value &gt; root.value &#123;</span><br><span class="line">root.right, existed = remove(root.right, value)</span><br><span class="line"><span class="keyword">return</span> root, existed</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果此节点正是要移除的节点,那么返回此节点，同时返回之前可能需要调整.</span></span><br><span class="line">existed = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 如果此节点没有孩子，直接返回即可</span></span><br><span class="line"><span class="keyword">if</span> root.left == <span class="literal">nil</span> &amp;&amp; root.right == <span class="literal">nil</span> &#123;</span><br><span class="line">root = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> root, existed</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果左子节点为空, 提升右子节点</span></span><br><span class="line"><span class="keyword">if</span> root.left == <span class="literal">nil</span> &#123;</span><br><span class="line">root = root.right</span><br><span class="line"><span class="keyword">return</span> root, existed</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果右子节点为空, 提升左子节点</span></span><br><span class="line"><span class="keyword">if</span> root.right == <span class="literal">nil</span> &#123;</span><br><span class="line">root = root.left</span><br><span class="line"><span class="keyword">return</span> root, existed</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果左右节点都存在,那么从右边节点找到一个最小的节点提升，这个节点肯定比左子树所有节点都大.</span></span><br><span class="line"><span class="comment">// 也可以从左子树节点中找一个最大的提升，道理一样.</span></span><br><span class="line">smallestInRight, _ := min(root.right)</span><br><span class="line"><span class="comment">// 提升</span></span><br><span class="line">root.value = smallestInRight</span><br><span class="line"><span class="comment">// 从右边子树中移除此节点</span></span><br><span class="line">root.right, _ = remove(root.right, smallestInRight)</span><br><span class="line"><span class="keyword">return</span> root, existed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>检查一个节点是否存在比较简单，因为二叉搜索树是有序的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Search 搜索元素(检查元素是否存在)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bst *BST)</span> <span class="title">Search</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> search(bst.root, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(n *Node, value <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> value &lt; n.value &#123;</span><br><span class="line"><span class="keyword">return</span> search(n.left, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> value &gt; n.value &#123;</span><br><span class="line"><span class="keyword">return</span> search(n.right, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，我们还可以实现查找一个二叉搜索树的最大最小值。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Min 二叉搜索树中的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bst *BST)</span> <span class="title">Min</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> min(bst.root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(node *Node)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">n := node</span><br><span class="line"><span class="comment">// 从左边找</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> n.left == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n.value, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">n = n.left</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Max 二叉搜索树中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bst *BST)</span> <span class="title">Max</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> max(bst.root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(node *Node)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">n := node</span><br><span class="line"><span class="comment">// 从右边找</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> n.right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n.value, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">n = n.right</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>可以实现先序遍历、中序遍历和后序遍历，先中后指的是根节点相对子节点的处理顺序。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PreOrderTraverse 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bst *BST)</span> <span class="title">PreOrderTraverse</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">preOrderTraverse(bst.root, f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preOrderTraverse</span><span class="params">(n *Node, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">f(n.value) <span class="comment">// 前</span></span><br><span class="line">preOrderTraverse(n.left, f)</span><br><span class="line">preOrderTraverse(n.right, f)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PostOrderTraverse 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bst *BST)</span> <span class="title">PostOrderTraverse</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">postOrderTraverse(bst.root, f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postOrderTraverse</span><span class="params">(n *Node, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">postOrderTraverse(n.left, f)</span><br><span class="line">postOrderTraverse(n.right, f)</span><br><span class="line">f(n.value) <span class="comment">// 后</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是你还可以通过广度搜索按照层级进行遍历？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天 Redis 的作者 antirez 说他朋友面试的时候考到排序问题，然后他说要是他也会考实现一个二叉搜索树，我说在中国某公司，据说面试直接就撸一个红黑树。不是说你技术渣，试问在座的各位有几个现在直接裸写出红黑树？&lt;/p&gt;
&lt;p&gt;红黑树太过偏门，但是常用的二叉搜索树你能写出来吗？快排呢？堆排序呢？&lt;/p&gt;
&lt;h2 id=&quot;什么是二叉搜索树&quot;&gt;&lt;a href=&quot;#什么是二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;什么是二叉搜索树&quot;&gt;&lt;/a&gt;什么是二叉搜索树&lt;/h2&gt;&lt;p&gt;二叉搜索树(binary search tree,BST)也叫排序的二叉树，根节点比左边子树的所有节点都大，比右边子树上的所有节点都小，如下图就是一个二叉搜索树:&lt;br&gt;&lt;img src=&quot;/blog/assets/algorithm/bst.png&quot; alt=&quot;bst&quot;&gt;&lt;/p&gt;
&lt;p&gt;要实现一个二叉搜索树， 我们需要实现节点的插入和删除，要实现节点的查找(搜索)，要实现前序遍历、中序遍历和后序遍历，要实现最大节点和最小节点的查找。&lt;/p&gt;
&lt;p&gt;下面就让我们实现这个二叉搜索树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="算法" scheme="http://linthan.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="面试" scheme="http://linthan.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>http协议里的keep-alive</title>
    <link href="http://linthan.github.io/blog/2020/07/16/tech/http/daiery-2020-0717-2000/"/>
    <id>http://linthan.github.io/blog/2020/07/16/tech/http/daiery-2020-0717-2000/</id>
    <published>2020-07-16T14:00:00.000Z</published>
    <updated>2020-07-16T15:01:54.999Z</updated>
    
    <content type="html"><![CDATA[<p>http 是现在 web 领域极其普遍的应用层传输协议， 目前常见的使用版本则是 http1.1， 当然最先版本是 http2.0。</p><p>传统的 Http 应用里都是一次 TCP 连接一次 request。<br><img src="/blog/assets/http/http_simple.webp" alt="http_simple"></p><a id="more"></a><p>这种情况下效率有点低：</p><ul><li>服务端负载增加，每个请求过来都得占用端口</li><li>客户端或服务端对客户端连接数的限制（chrome 限制是 6 个）<br>这种情况很多，比如网页加载对于这个 case 的处理就是使用将静态资源放置到不同 Domain 或者压缩打包减少数量来提高效率</li></ul><p>http1.1 协议里增加了 keepalive 的支持， 并且默认开启。<br><img src="/blog/assets/http/http_1.1.webp" alt="http_1.1"></p><p>客户端和服务端在建立连接并完成 request 后并不会立即断开 TCP 连接，而是在下次 request 来临时复用这次 TCP 连接。但是这里也必须要有 TCP 连接的 timeout 时间限制。不然会造成服务端端口被长期占用释放不了。</p><p>对于不适用 keepalive 的 request 来说，不管是客户端还是服务端都是通过 TCP 的链接的断开知道 request 的结束（TCP 挥手时会 check 数据包的 seq， 保证数据完整性）。<br>支持 keepalive 后，如何知道 request 结束了呢？<br>在 Http1.1 的版本里， 解决方案是 request 和 reponse 里使用 contentLength 来帮助确认是否收到全部数据。</p><p>另一个问题就是在使用 keepalive 的情况，客户端依然有同时发送多个请求的情况，比如网页加载是需要同时 load 多个静态资源。比如 浏览器默认最大连接数是 6，现在有十个资源同时加载，那么这十个里会有 6 个并行，4 个与前 6 个串行。</p><p>在 keepalive 里有个问题就是如果能知道每个 repose 与其对应的 request 的话，并发的请求可以只需要一次 TCP 连接，这也就是 http2.0 实现的多路复用。</p><p><img src="/blog/assets/http/http_2.0.webp" alt="http_2.0"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;http 是现在 web 领域极其普遍的应用层传输协议， 目前常见的使用版本则是 http1.1， 当然最先版本是 http2.0。&lt;/p&gt;
&lt;p&gt;传统的 Http 应用里都是一次 TCP 连接一次 request。&lt;br&gt;&lt;img src=&quot;/blog/assets/http/http_simple.webp&quot; alt=&quot;http_simple&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="面试" scheme="http://linthan.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>http常见的状态码，400,401,403状态码分别代表什么？</title>
    <link href="http://linthan.github.io/blog/2020/07/16/tech/interview/daiery-2020-0716-2000/"/>
    <id>http://linthan.github.io/blog/2020/07/16/tech/interview/daiery-2020-0716-2000/</id>
    <published>2020-07-16T14:00:00.000Z</published>
    <updated>2020-07-16T14:11:12.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><p>200 OK，表示从客户端发来的请求在服务器端被正确处理<br>204 No content，表示请求成功，但响应报文不含实体的主体部分<br>206 Partial Content，进行范围请求</p><a id="more"></a><h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><p>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL<br>302 found，临时性重定向，表示资源临时被分配了新的 URL<br>303 see other，表示资源存在着另一个 URL，应使用 GET 方法定向获取资源<br>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况<br>307 temporary redirect，临时重定向，和 302 含义相同</p><h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><p>400 bad request，请求报文存在语法错误<br>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息<br>403 forbidden，表示对请求资源的访问被服务器拒绝<br>404 not found，表示在服务器上没有找到请求的资源</p><h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><p>500 internal sever error，表示服务器端在执行请求时发生了错误<br>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2XX-成功&quot;&gt;&lt;a href=&quot;#2XX-成功&quot; class=&quot;headerlink&quot; title=&quot;2XX 成功&quot;&gt;&lt;/a&gt;2XX 成功&lt;/h2&gt;&lt;p&gt;200 OK，表示从客户端发来的请求在服务器端被正确处理&lt;br&gt;204 No content，表示请求成功，但响应报文不含实体的主体部分&lt;br&gt;206 Partial Content，进行范围请求&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="面试" scheme="http://linthan.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>图解Golang的内存分配</title>
    <link href="http://linthan.github.io/blog/2020/07/16/tech/golang/daiery-2020-07-16-2030/"/>
    <id>http://linthan.github.io/blog/2020/07/16/tech/golang/daiery-2020-07-16-2030/</id>
    <published>2020-07-16T11:30:00.000Z</published>
    <updated>2020-07-16T13:30:06.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一般程序的内存分配"><a href="#一般程序的内存分配" class="headerlink" title="一般程序的内存分配"></a>一般程序的内存分配</h2><p>在讲 Golang 的内存分配之前，让我们先来看看一般程序的内存分布情况：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一般程序的内存分配&quot;&gt;&lt;a href=&quot;#一般程序的内存分配&quot; class=&quot;headerlink&quot; title=&quot;一般程序的内存分配&quot;&gt;&lt;/a&gt;一般程序的内存分配&lt;/h2&gt;&lt;p&gt;在讲 Golang 的内存分配之前，让我们先来看看一般程序的内存分布情况：&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="golang" scheme="http://linthan.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>mysql 四种隔离级别</title>
    <link href="http://linthan.github.io/blog/2020/07/16/tech/database/daiery-2020-0716-1009/"/>
    <id>http://linthan.github.io/blog/2020/07/16/tech/database/daiery-2020-0716-1009/</id>
    <published>2020-07-16T02:30:00.000Z</published>
    <updated>2020-07-16T02:49:43.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务的-四个特征（ACID）"><a href="#事务的-四个特征（ACID）" class="headerlink" title="事务的 四个特征（ACID）"></a>事务的 四个特征（ACID）</h2><p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。</p><p>1 、原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做</p><p>2 、一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。</p><p>3 、隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><p>4 、持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</p><h2 id="Mysql-的四种隔离级别"><a href="#Mysql-的四种隔离级别" class="headerlink" title="Mysql 的四种隔离级别"></a>Mysql 的四种隔离级别</h2><p>SQL 标准定义了 4 类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。</p><p>Read Uncommitted（读取未提交内容）</p><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p><p>Read Committed（读取提交内容）</p><p>这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的 commit，所以同一 select 可能返回不同结果。</p><p>Repeatable Read（可重读）</p><p>这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB 和 Falcon 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p><p>Serializable（可串行化）</p><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p><p>出现问题</p><p>这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：</p><p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个 RollBack 了操作，则后一个事务所读取的数据就会是不正确的。</p><p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p><p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p><p>在 MySQL 中，实现了这四种隔离级别，分别有可能产生问题如下所示：<br><img src="/blog/assets/database/isolation_problem.png" alt="isolation_problem"></p><hr><p><a href="https://www.cnblogs.com/jian-gao/p/10795407.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事务的-四个特征（ACID）&quot;&gt;&lt;a href=&quot;#事务的-四个特征（ACID）&quot; class=&quot;headerlink&quot; title=&quot;事务的 四个特征（ACID）&quot;&gt;&lt;/a&gt;事务的 四个特征（ACID）&lt;/h2&gt;&lt;p&gt;事务具有四个特征：原子性（ Atomicit
      
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="http://linthan.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>死锁产生的原因和解锁的方法</title>
    <link href="http://linthan.github.io/blog/2020/07/16/tech/os/daiery-2020-0716-1000/"/>
    <id>http://linthan.github.io/blog/2020/07/16/tech/os/daiery-2020-0716-1000/</id>
    <published>2020-07-16T02:00:00.000Z</published>
    <updated>2020-07-16T02:13:42.763Z</updated>
    
    <content type="html"><![CDATA[<p>产生死锁的四个必要条件：</p><ul><li>（1） 互斥条件：一个资源每次只能被一个进程使用。</li><li>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul><a id="more"></a><h2 id="二-锁的分类"><a href="#二-锁的分类" class="headerlink" title="二 锁的分类"></a>二 锁的分类</h2><ol><li>从数据库系统的角度来看：分为独占锁（即排它锁），共享锁和更新锁<br>MS-SQL Server 使用以下资源锁模式。</li></ol><p>锁模式 描述<br>共享 (S) ：读锁，用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。<br>更新 (U) ：(介于共享和排它锁之间），可以让其他程序在不加锁的条件下读，但本程序可以随时更改。</p><p>读取表时使用更新锁，而不使用共享锁，并将锁一直保留到语句或事务的结束。UPDLOCK 的优点是允许您读取数据（不阻塞其它事务）并在以后更新数据，同时确保自从上次读取数据后数据没有被更改。当我们用 UPDLOCK 来读取记录时可以对取到的记录加上更新锁，从而加上锁的记录在其它的线程中是不能更改的只能等本线程的事务结束后才能更改，我如下示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">TRANSACTION</span> <span class="comment">--开始一个事务</span></span><br><span class="line"><span class="keyword">SELECT</span> Qty</span><br><span class="line"> <span class="keyword">FROM</span> myTable <span class="keyword">WITH</span> (UPDLOCK)</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">Id</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">UPDATE</span> myTable <span class="keyword">SET</span> Qty = Qty - A.Qty</span><br><span class="line"> <span class="keyword">FROM</span> myTable  <span class="keyword">AS</span> A</span><br><span class="line"> <span class="keyword">INNER</span> <span class="keyword">JOIN</span>  @_Table <span class="keyword">AS</span> B <span class="keyword">ON</span> A.ID = B.ID</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> <span class="keyword">TRANSACTION</span> <span class="comment">--提交事务</span></span><br></pre></td></tr></table></figure><p>这样在更新时其它的线程或事务在这些语句执行完成前是不能更改 ID 是１，２，３的记录的．其它的都可以修改和读，１，２，３的只能读，要是修改的话只能等这些语句完成后才能操作.从而保证的数据的修改正确.</p><p>排它 (X)：写锁。 用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。<br>意向锁 用于建立锁的层次结构。意向锁的类型为：意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。<br>架构锁 在执行依赖于表架构的操作时使用。架构锁的类型为：架构修改 (Sch-M) 和架构稳定性 (Sch-S)。<br>大容量更新 (BU) 向表中大容量复制数据并指定了 TABLOCK 提示时使用。</p><p>共享锁<br>共享 (S) 锁允许并发事务读取 (SELECT) 一个资源。资源上存在共享 (S) 锁时，任何其它事务都不能修改数据。一旦已经读取数据，便立即释放资源上的共享 (S) 锁，除非将事务隔离级别设置为可重复读或更高级别，或者在事务生存周期内用锁定提示保留共享 (S) 锁。</p><p>更新锁<br>更新 (U) 锁可以防止通常形式的死锁。一般更新模式由一个事务组成，此事务读取记录，获取资源（页或行）的共享 (S) 锁，然后修改行，此操作要求锁转换为排它 (X) 锁。如果两个事务获得了资源上的共享模式锁，然后试图同时更新数据，则一个事务尝试将锁转换为排它 (X) 锁。共享模式到排它锁的转换必须等待一段时间，因为一个事务的排它锁与其它事务的共享模式锁不兼容；发生锁等待。第二个事务试图获取排它 (X) 锁以进行更新。由于两个事务都要转换为排它 (X) 锁，并且每个事务都等待另一个事务释放共享模式锁，因此发生死锁。</p><p>若要避免这种潜在的死锁问题，请使用更新 (U) 锁。一次只有一个事务可以获得资源的更新 (U) 锁。如果事务修改资源，则更新 (U) 锁转换为排它 (X) 锁。否则，锁转换为共享锁。</p><p>排它锁<br>排它 (X) 锁可以防止并发事务对资源进行访问。其它事务不能读取或修改排它 (X) 锁锁定的数据。</p><p>意向锁<br>意向锁表示 SQL Server 需要在层次结构中的某些底层资源上获取共享 (S) 锁或排它 (X) 锁。例如，放置在表级的共享意向锁表示事务打算在表中的页或行上放置共享 (S) 锁。在表级设置意向锁可防止另一个事务随后在包含那一页的表上获取排它 (X) 锁。意向锁可以提高性能，因为 SQL Server 仅在表级检查意向锁来确定事务是否可以安全地获取该表上的锁。而无须检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。</p><p>意向锁包括意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。</p><h2 id="死锁原理"><a href="#死锁原理" class="headerlink" title="死锁原理"></a>死锁原理</h2><p>根据操作系统中的定义：死锁是指在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所站用不会释放的资源而处于的一种永久等待状态。</p><p>死锁的四个必要条件：<br>互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用。<br>请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源。<br>非剥夺条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。<br>循环等待条件(Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。</p><p>对应到 SQL Server 中，当在两个或多个任务中，如果每个任务锁定了其他任务试图锁定的资源，此时会造成这些任务永久阻塞，从而出现死锁；这些资源可能是：单行(RID，堆中的单行)、索引中的键(KEY，行锁)、页(PAG，8KB)、区结构(EXT，连续的 8 页)、堆或 B 树(HOBT) 、表(TAB，包括数据和索引)、文件(File，数据库文件)、应用程序专用资源(APP)、元数据(METADATA)、分配单元(Allocation_Unit)、整个数据库(DB)。一个死锁示例如下图所示：</p><pre><code>说明：T1、T2表示两个任务；R1和R2表示两个资源；由资源指向任务的箭头(如R1-&gt;T1，R2-&gt;T2)表示该资源被改任务所持有；由任务指向资源的箭头(如T1-&gt;S2，T2-&gt;S1)表示该任务正在请求对应目标资源；其满足上面死锁的四个必要条件：</code></pre><p>(1).互斥：资源 S1 和 S2 不能被共享，同一时间只能由一个任务使用；<br>(2).请求与保持条件：T1 持有 S1 的同时，请求 S2；T2 持有 S2 的同时请求 S1；<br>(3).非剥夺条件：T1 无法从 T2 上剥夺 S2，T2 也无法从 T1 上剥夺 S1；<br>(4).循环等待条件：上图中的箭头构成环路，存在循环等待。</p><h3 id="2-死锁排查"><a href="#2-死锁排查" class="headerlink" title="2. 死锁排查"></a>2. 死锁排查</h3><p>1). 使用 SQL Server 的系统存储过程 sp_who 和 sp_lock，可以查看当前数据库中的锁情况；进而根据 objectID(@objID)(SQL Server 2005)/ object_name(@objID)(Sql Server 2000)可以查看哪个资源被锁，用 dbcc ld(@blk)，可以查看最后一条发生给 SQL Server 的 Sql 语句；</p><p>CREATE Table #Who(spid int,<br>ecid int,<br>status nvarchar(50),<br>loginname nvarchar(50),<br>hostname nvarchar(50),<br>blk int,<br>dbname nvarchar(50),<br>cmd nvarchar(50),<br>request_ID int);</p><p>CREATE Table #Lock(spid int,<br>dpid int,<br>objid int,<br>indld int,<br>[Type] nvarchar(20),<br>Resource nvarchar(50),<br>Mode nvarchar(10),<br>Status nvarchar(10)<br>);</p><p>INSERT INTO #Who<br>EXEC sp_who active –看哪个引起的阻塞，blk<br>INSERT INTO #Lock<br>EXEC sp_lock –看锁住了那个资源 id，objid</p><p>DECLARE @DBName nvarchar(20);<br>SET @DBName=’NameOfDataBase’</p><p>SELECT #Who._ FROM #Who WHERE dbname=@DBName<br>SELECT #Lock._ FROM #Lock<br>JOIN #Who<br>ON #Who.spid=#Lock.spid<br>AND dbname=@DBName;</p><p>–最后发送到 SQL Server 的语句<br>DECLARE crsr Cursor FOR<br>SELECT blk FROM #Who WHERE dbname=@DBName AND blk&lt;&gt;0;<br>DECLARE @blk int;<br>open crsr;<br>FETCH NEXT FROM crsr INTO @blk;<br>WHILE (@@FETCH_STATUS = 0)<br>BEGIN;<br>dbcc inputbuffer(@blk);<br>FETCH NEXT FROM crsr INTO @blk;<br>END;<br>close crsr;<br>DEALLOCATE crsr;</p><p>–锁定的资源<br>SELECT #Who.spid,hostname,objid,[type],mode,object_name(objid) as objName FROM #Lock<br>JOIN #Who<br>ON #Who.spid=#Lock.spid<br>AND dbname=@DBName<br>WHERE objid&lt;&gt;0;</p><p>DROP Table #Who;<br>DROP Table #Lock;</p><p>(2). 使用 SQL Server Profiler 分析死锁: 将 Deadlock graph 事件类添加到跟踪。此事件类使用死锁涉及到的进程和对象的 XML 数据填充跟踪中的 TextData 数据列。SQL Server 事件探查器 可以将 XML 文档提取到死锁 XML (.xdl) 文件中，以后可在 SQL Server Management Studio 中查看该文件。</p><h3 id="3-避免死锁"><a href="#3-避免死锁" class="headerlink" title="3. 避免死锁"></a>3. 避免死锁</h3><p>上面 1 中列出了死锁的四个必要条件，我们只要想办法破其中的任意一个或多个条件，就可以避免死锁发生，一般有以下几种方法(FROM Sql Server 2005 联机丛书)：<br>(1).按同一顺序访问对象。(注：避免出现循环)<br>(2).避免事务中的用户交互。(注：减少持有资源的时间，较少锁竞争)<br>(3).保持事务简短并处于一个批处理中。(注：同(2)，减少持有资源的时间)<br>(4).使用较低的隔离级别。(注：使用较低的隔离级别（例如已提交读）比使用较高的隔离级别（例如可序列化）持有共享锁的时间更短，减少锁竞争)<br>(5).使用基于行版本控制的隔离级别：2005 中支持快照事务隔离和指定 READ_COMMITTED 隔离级别的事务使用行版本控制，可以将读与写操作之间发生的死锁几率降至最低：<br>SET ALLOW_SNAPSHOT_ISOLATION ON –事务可以指定 SNAPSHOT 事务隔离级别;<br>SET READ_COMMITTED_SNAPSHOT ON –指定 READ_COMMITTED 隔离级别的事务将使用行版本控制而不是锁定。默认情况下(没有开启此选项，没有加 with nolock 提示)，SELECT 语句会对请求的资源加 S 锁(共享锁)；而开启了此选项后，SELECT 不会对请求的资源加 S 锁。<br>注意：设置 READ_COMMITTED_SNAPSHOT 选项时，数据库中只允许存在执行 ALTER DATABASE 命令的连接。在 ALTER DATABASE 完成之前，数据库中决不能有其他打开的连接。数据库不必一定要处于单用户模式中。<br>(6).使用绑定连接。(注：绑定会话有利于在同一台服务器上的多个会话之间协调操作。绑定会话允许一个或多个会话共享相同的事务和锁(但每个回话保留其自己的事务隔离级别)，并可以使用同一数据，而不会有锁冲突。可以从同一个应用程序内的多个会话中创建绑定会话，也可以从包含不同会话的多个应用程序中创建绑定会话。在一个会话中开启事务(begin tran)后，调用 exec sp_getbindtoken @Token out;来取得 Token，然后传入另一个会话并执行 EXEC sp_bindsession @Token 来进行绑定(最后的示例中演示了绑定连接)。</p><h3 id="4-死锁处理方法："><a href="#4-死锁处理方法：" class="headerlink" title="4. 死锁处理方法："></a>4. 死锁处理方法：</h3><p>(1). 根据 2 中提供的 sql，查看那个 spid 处于 wait 状态，然后用 kill spid 来干掉(即破坏死锁的第四个必要条件:循环等待)；当然这只是一种临时解决方案，我们总不能在遇到死锁就在用户的生产环境上排查死锁、Kill sp，我们应该考虑如何去避免死锁。</p><p>(2). 使用 SET LOCK_TIMEOUT timeout_period(单位为毫秒)来设定锁请求超时。默认情况下，数据库没有超时期限(timeout_period 值为-1，可以用 SELECT @@LOCK_TIMEOUT 来查看该值，即无限期等待)。当请求锁超过 timeout_period 时，将返回错误。timeout_period 值为 0 时表示根本不等待，一遇到锁就返回消息。设置锁请求超时，破环了死锁的第二个必要条件(请求与保持条件)。</p><p>服务器: 消息 1222，级别 16，状态 50，行 1<br>已超过了锁请求超时时段。</p><p>(3). SQL Server 内部有一个锁监视器线程执行死锁检查，锁监视器对特定线程启动死锁搜索时，会标识线程正在等待的资源；然后查找特定资源的所有者，并递归地继续执行对那些线程的死锁搜索，直到找到一个构成死锁条件的循环。检测到死锁后，数据库引擎 选择运行回滚开销最小的事务的会话作为死锁牺牲品，返回 1205 错误，回滚死锁牺牲品的事务并释放该事务持有的所有锁，使其他线程的事务可以请求资源并继续运行。</p><h3 id="5-两个死锁示例及解决方法"><a href="#5-两个死锁示例及解决方法" class="headerlink" title="5. 两个死锁示例及解决方法"></a>5. 两个死锁示例及解决方法</h3><p>5.1 SQL 死锁</p><p>(1). 测试用的基础数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Lock1(C1 <span class="built_in">int</span> <span class="keyword">default</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Lock2(C1 <span class="built_in">int</span> <span class="keyword">default</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Lock1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Lock2 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>(2). 开两个查询窗口，分别执行下面两段 sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--Query 1</span></span><br><span class="line"><span class="keyword">Begin</span> Tran</span><br><span class="line"><span class="keyword">Update</span> Lock1 <span class="keyword">Set</span> C1=C1+<span class="number">1</span>;</span><br><span class="line">WaitFor Delay '00:01:00';</span><br><span class="line"><span class="keyword">SELECT</span> \* <span class="keyword">FROM</span> Lock2</span><br><span class="line"><span class="keyword">Rollback</span> Tran;</span><br><span class="line"></span><br><span class="line"><span class="comment">--Query 2</span></span><br><span class="line"><span class="keyword">Begin</span> Tran</span><br><span class="line"><span class="keyword">Update</span> Lock2 <span class="keyword">Set</span> C1=C1+<span class="number">1</span>;</span><br><span class="line">WaitFor Delay '00:01:00';</span><br><span class="line"><span class="keyword">SELECT</span> \* <span class="keyword">FROM</span> Lock1</span><br><span class="line"><span class="keyword">Rollback</span> Tran;</span><br></pre></td></tr></table></figure><p>上面的 SQL 中有一句 WaitFor Delay ‘00:01:00’，用于等待 1 分钟，以方便查看锁的情况。</p><p>(3). 查看锁情况</p><p>在执行上面的 WaitFor 语句期间，执行第二节中提供的语句来查看锁信息：</p><p>Query1 中，持有 Lock1 中第一行(表中只有一行数据)的行排他锁(RID:X)，并持有该行所在页的意向更新锁(PAG:IX)、该表的意向更新锁(TAB:IX)；Query2 中，持有 Lock2 中第一行(表中只有一行数据)的行排他锁(RID:X)，并持有该行所在页的意向更新锁(PAG:IX)、该表的意向更新锁(TAB:IX)；</p><p>执行完 Waitfor，Query1 查询 Lock2，请求在资源上加 S 锁，但该行已经被 Query2 加上了 X 锁；Query2 查询 Lock1，请求在资源上加 S 锁，但该行已经被 Query1 加上了 X 锁；于是两个查询持有资源并互不相让，构成死锁。</p><p>(4). 解决办法</p><p>a). SQL Server 自动选择一条 SQL 作死锁牺牲品：运行完上面的两个查询后，我们会发现有一条 SQL 能正常执行完毕，而另一个 SQL 则报如下错误：</p><p>服务器: 消息 1205，级别 13，状态 50，行 1<br>事务（进程 ID xx）与另一个进程已被死锁在 lock 资源上，且该事务已被选作死锁牺牲品。请重新运行该事务。</p><p>这就是上面第四节中介绍的锁监视器干活了。</p><p>b). 按同一顺序访问对象：颠倒任意一条 SQL 中的 Update 与 SELECT 语句的顺序。例如修改第二条 SQL 成如下：</p><p>–Query2</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Begin</span> Tran</span><br><span class="line"><span class="keyword">SELECT</span> \* <span class="keyword">FROM</span> Lock1<span class="comment">--在 Lock1 上申请 S 锁</span></span><br><span class="line">WaitFor Delay <span class="string">'00:01:00'</span>;</span><br><span class="line"><span class="keyword">Update</span> Lock2 <span class="keyword">Set</span> C1=C1+<span class="number">1</span>;<span class="comment">--Lock2:RID:X</span></span><br><span class="line"><span class="keyword">Rollback</span> Tran;</span><br></pre></td></tr></table></figure><p>当然这样修改也是有代价的，这会导致第一条 SQL 执行完毕之前，第二条 SQL 一直处于阻塞状态。单独执行 Query1 或 Query2 需要约 1 分钟，但如果开始执行 Query1 时，马上同时执行 Query2，则 Query2 需要 2 分钟才能执行完；这种按顺序请求资源从一定程度上降低了并发性。</p><p>c). SELECT 语句加 With(NoLock)提示：默认情况下 SELECT 语句会对查询到的资源加 S 锁(共享锁)，S 锁与 X 锁(排他锁)不兼容；但加上 With(NoLock)后，SELECT 不对查询到的资源加锁(或者加 Sch-S 锁，Sch-S 锁可以与任何锁兼容)；从而可以是这两条 SQL 可以并发地访问同一资源。当然，此方法适合解决读与写并发死锁的情况，但加 With(NoLock)可能会导致脏读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> _ <span class="keyword">FROM</span> Lock2 <span class="keyword">WITH</span>(NOLock)</span><br><span class="line"><span class="keyword">SELECT</span> _ <span class="keyword">FROM</span> Lock1 <span class="keyword">WITH</span>(NOLock)</span><br></pre></td></tr></table></figure><p>d). 使用较低的隔离级别。SQL Server 2000 支持四种事务处理隔离级别(TIL)，分别为：READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ、SERIALIZABLE；SQL Server 2005 中增加了 SNAPSHOT TIL。默认情况下，SQL Server 使用 READ COMMITTED TIL，我们可以在上面的两条 SQL 前都加上一句 SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED，来降低 TIL 以避免死锁；事实上，运行在 READ UNCOMMITTED TIL 的事务，其中的 SELECT 语句不对结果资源加锁或加 Sch-S 锁，而不会加 S 锁；但还有一点需要注意的是：READ UNCOMMITTED TIL 允许脏读，虽然加上了降低 TIL 的语句后，上面两条 SQL 在执行过程中不会报错，但执行结果是一个返回 1，一个返回 2，即读到了脏数据，也许这并不是我们所期望的。</p><p>e). 在 SQL 前加 SET LOCK_TIMEOUT timeout_period，当请求锁超过设定的 timeout_period 时间后，就会终止当前 SQL 的执行，牺牲自己，成全别人。</p><p>f). 使用基于行版本控制的隔离级别(SQL Server 2005 支持)：开启下面的选项后，SELECT 不会对请求的资源加 S 锁，不加锁或者加 Sch-S 锁，从而将读与写操作之间发生的死锁几率降至最低；而且不会发生脏读。啊</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> ALLOW_SNAPSHOT_ISOLATION <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">SET</span> READ_COMMITTED_SNAPSHOT <span class="keyword">ON</span></span><br></pre></td></tr></table></figure><pre><code>g). 使用绑定连接(使用方法见下一个示例。)</code></pre><p>5.2 程序死锁(SQL 阻塞)</p><p>看一个例子：一个典型的数据库操作事务死锁分析，按照我自己的理解，我觉得这应该算是 C#程序中出现死锁，而不是数据库中的死锁；下面的代码模拟了该文中对数据库的操作过程：</p><p>//略去的无关的 code</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">SqlConnection conn = new SqlConnection(connectionString);</span><br><span class="line">conn.Open();</span><br><span class="line">SqlTransaction tran = conn.BeginTransaction();</span><br><span class="line">string sql1 = "<span class="keyword">Update</span> Lock1 <span class="keyword">SET</span> C1=C1+<span class="number">1</span><span class="string">";</span></span><br><span class="line"><span class="string">string sql2 = "</span><span class="keyword">SELECT</span> \* <span class="keyword">FROM</span> Lock1<span class="string">";</span></span><br><span class="line"><span class="string">ExecuteNonQuery(tran, sql1); //使用事务:事务中 Lock 了 Table</span></span><br><span class="line"><span class="string">ExecuteNonQuery(null, sql2); //新开一个 connection 来读取 Table</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">public static void ExecuteNonQuery(SqlTransaction tran, string sql)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">SqlCommand cmd = new SqlCommand(sql);</span></span><br><span class="line"><span class="string">if (tran != null)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cmd.Connection = tran.Connection;</span></span><br><span class="line"><span class="string">cmd.Transaction = tran;</span></span><br><span class="line"><span class="string">cmd.ExecuteNonQuery();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">using (SqlConnection conn = new SqlConnection(connectionString))</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">conn.Open();</span></span><br><span class="line"><span class="string">cmd.Connection = conn;</span></span><br><span class="line"><span class="string">cmd.ExecuteNonQuery();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>执行到 ExecuteNonQuery(null, sql2)时抛出 SQL 执行超时的异常，下图从数据库的角度来看该问题：</p><pre><code> 代码从上往下执行，会话1持有了表Lock1的X锁，且事务没有结束，回话1就一直持有X锁不释放；而会话2执行select操作，请求在表Lock1上加S锁，但S锁与X锁是不兼容的，所以回话2的被阻塞等待，不在等待中，就在等待中获得资源，就在等待中超时。。。从中我们可以看到，里面并没有出现死锁，而只是SELECT操作被阻塞了。也正因为不是数据库死锁，所以SQL Server的锁监视器无法检测到死锁。   我们再从C#程序的角度来看该问题：   C#程序持有了表Lock1上的X锁，同时开了另一个SqlConnection还想在该表上请求一把S锁，图中已经构成了环路；太贪心了，结果自己把自己给锁死了。。。   虽然这不是一个数据库死锁，但却是因为数据库资源而导致的死锁，上例中提到的解决死锁的方法在这里也基本适用，主要是避免读操作被阻塞，解决方法如下：   a). 把SELECT放在Update语句前：SELECT不在事务中，且执行完毕会释放S锁；   b). 把SELECT也放加入到事务中：ExecuteNonQuery(tran, sql2);   c). SELECT加With(NOLock)提示：可能产生脏读；   d). 降低事务隔离级别：SELECT语句前加SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED；同上，可能产生脏读；   e). 使用基于行版本控制的隔离级别（同上例）。   g). 使用绑定连接：取得事务所在会话的token，然后传入新开的connection中；执行EXEC sp_bindsession @Token后绑定了连接，最后执行exec sp_bindsession null;来取消绑定；最后需要注意的四点是：(1). 使用了绑定连接的多个connection共享同一个事务和相同的锁，但各自保留自己的事务隔离级别；(2). 如果在sql3字符串的“exec sp_bindsession null”换成“commit tran”或者“rollback tran”，则会提交整个事务，最后一行C#代码tran.Commit()就可以不用执行了(执行会报错，因为事务已经结束了-,-)。(3). 开启事务(begin tran)后，才可以调用exec sp_getbindtoken @Token out来取得Token；如果不想再新开的connection中结束掉原有的事务，则在这个connection close之前，必须执行“exec sp_bindsession null”来取消绑定连接，或者在新开的connectoin close之前先结束掉事务(commit/tran)。(4). (Sql server 2005 联机丛书)后续版本的 Microsoft SQL Server 将删除该功能。请避免在新的开发工作中使用该功能，并着手修改当前还在使用该功能的应用程序。 请改用多个活动结果集 (MARS) 或分布式事务。</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tran = connection.BeginTransaction();</span><br><span class="line">string sql1 = "<span class="keyword">Update</span> Lock1 <span class="keyword">SET</span> C1=C1+<span class="number">1</span><span class="string">";</span></span><br><span class="line"><span class="string">ExecuteNonQuery(tran, sql1); //使用事务:事务中 Lock 了测试表 Lock1</span></span><br><span class="line"><span class="string">string sql2 = @"</span><span class="keyword">DECLARE</span> @Token <span class="built_in">varchar</span>(<span class="number">255</span>);</span><br><span class="line">exec sp_getbindtoken @Token out;</span><br><span class="line"><span class="keyword">SELECT</span> @Token;";</span><br><span class="line">string token = ExecuteScalar(tran, sql2).ToString();</span><br><span class="line">string sql3 = "EXEC sp_bindsession @Token;<span class="keyword">Update</span> Lock1 <span class="keyword">SET</span> C1=C1+<span class="number">1</span>;exec sp_bindsession null;";</span><br><span class="line">SqlParameter parameter = new SqlParameter("@Token", SqlDbType.VarChar);</span><br><span class="line">parameter.Value = token;</span><br><span class="line">ExecuteNonQuery(null, sql3, parameter); //新开一个 connection 来操作测试表 Lock1</span><br><span class="line">tran.Commit();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;产生死锁的四个必要条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;（1） 互斥条件：一个资源每次只能被一个进程使用。&lt;/li&gt;
&lt;li&gt;（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。&lt;/li&gt;
&lt;li&gt;（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。&lt;/li&gt;
&lt;li&gt;（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="面试" scheme="http://linthan.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="操作系统" scheme="http://linthan.github.io/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>线程共享内容和独享内容</title>
    <link href="http://linthan.github.io/blog/2020/07/16/tech/os/daiery-2020-0716-2030/"/>
    <id>http://linthan.github.io/blog/2020/07/16/tech/os/daiery-2020-0716-2030/</id>
    <published>2020-07-16T02:00:00.000Z</published>
    <updated>2020-07-16T15:09:45.381Z</updated>
    
    <content type="html"><![CDATA[<p>线程共享的内容包括：</p><ul><li>1.进程代码段</li><li>2.进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)</li><li>3.进程打开的文件描述符、</li><li>4.信号的处理器、</li><li>5.进程的当前目录和</li><li>6.进程用户 ID 与进程组 ID<br>线程独有的内容包括：</li><li>1.线程 ID</li><li>2.寄存器组的值</li><li>3.线程的堆栈</li><li>4.错误返回码</li><li>5.线程的信号屏蔽码</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线程共享的内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.进程代码段&lt;/li&gt;
&lt;li&gt;2.进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)&lt;/li&gt;
&lt;li&gt;3.进程打开的文件描述符、&lt;/li&gt;
&lt;li&gt;4.信号的处理器、&lt;/li&gt;
&lt;li&gt;5.进程的当前目
      
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="面试" scheme="http://linthan.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="操作系统" scheme="http://linthan.github.io/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>数据库索引原理，及MySQL索引类型</title>
    <link href="http://linthan.github.io/blog/2020/07/16/tech/database/daiery-2020-0716-0830/"/>
    <id>http://linthan.github.io/blog/2020/07/16/tech/database/daiery-2020-0716-0830/</id>
    <published>2020-07-16T00:30:00.000Z</published>
    <updated>2020-07-16T01:53:51.911Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 索引类型一览 让 MySQL 高效运行起来<br>本文介绍了七种 MySQL 索引类型。在数据库表中，对字段建立索引可以大大提高查询速度。通过善用这些索引，可以令 MySQL 的查询和运行更加高效。</p><a id="more"></a><p>索引是快速搜索的关键。MySQL 索引的建立对于 MySQL 的高效运行是很重要的。下面介绍几种常见的 MySQL 索引类型。</p><p>在数据库表中，对字段建立索引可以大大提高查询速度。假如我们创建了一个 mytable 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(</span><br><span class="line"></span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"></span><br><span class="line">username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们随机向里面插入了 10000 条记录，其中有一条：5555, admin。</p><p>在查找 username=”admin”的记录 SELECT * FROM mytable WHERE username=’admin’;时，如果在 username 上已经建立了索引，MySQL 无须任何扫描，即准确可找到该记录。相反，MySQL 会扫描所有记录，即要查询 10000 条记录。</p><p>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索包含多个列。</p><h1 id="MySQL-索引类型包括："><a href="#MySQL-索引类型包括：" class="headerlink" title="MySQL 索引类型包括："></a>MySQL 索引类型包括：</h1><h2 id="（1）普通索引"><a href="#（1）普通索引" class="headerlink" title="（1）普通索引"></a>（1）普通索引</h2><p>这是最基本的索引，它没有任何限制。它有以下几种创建方式：</p><ul><li>创建索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> indexName <span class="keyword">ON</span> mytable(username(<span class="keyword">length</span>));</span><br></pre></td></tr></table></figure><p>如果是 CHAR，VARCHAR 类型，length 可以小于字段实际长度；如果是 BLOB 和 TEXT 类型，必须指定 length，下同。</p><ul><li>修改表结构</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> mytable <span class="keyword">ADD</span> <span class="keyword">INDEX</span> [indexName] <span class="keyword">ON</span> (username(<span class="keyword">length</span>))</span><br></pre></td></tr></table></figure><ul><li>创建表的时候直接指定</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE mytable(</span><br><span class="line"></span><br><span class="line">ID INT NOT NULL,</span><br><span class="line"></span><br><span class="line">username VARCHAR(16) NOT NULL,</span><br><span class="line"></span><br><span class="line">INDEX [indexName] (username(length))</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>删除索引的语法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> [indexName] <span class="keyword">ON</span> mytable;</span><br></pre></td></tr></table></figure><h2 id="（2）唯一索引"><a href="#（2）唯一索引" class="headerlink" title="（2）唯一索引"></a>（2）唯一索引</h2><p>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p><ul><li>创建索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> indexName <span class="keyword">ON</span> mytable(username(<span class="keyword">length</span>))</span><br></pre></td></tr></table></figure><ul><li>修改表结构</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> mytable <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> [indexName] <span class="keyword">ON</span> (username(<span class="keyword">length</span>))</span><br></pre></td></tr></table></figure><ul><li>创建表的时候直接指定</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(</span><br><span class="line"></span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"></span><br><span class="line">username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"></span><br><span class="line"><span class="keyword">UNIQUE</span> [indexName] (username(<span class="keyword">length</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="（3）主键索引"><a href="#（3）主键索引" class="headerlink" title="（3）主键索引"></a>（3）主键索引</h2><p>它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(</span><br><span class="line"></span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"></span><br><span class="line">username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"></span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">ID</span>)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当然也可以用 ALTER 命令。记住：一个表只能有一个主键。</p><h2 id="（4）组合索引"><a href="#（4）组合索引" class="headerlink" title="（4）组合索引"></a>（4）组合索引</h2><p>为了形象地对比单列索引和组合索引，为表添加多个字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(  </span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,   </span><br><span class="line">username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">city <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">age <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。就是将 name, city, age 建到一个索引里：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="keyword">ADD</span> <span class="keyword">INDEX</span> name_city_age (<span class="keyword">name</span>(<span class="number">10</span>),city,age);</span><br></pre></td></tr></table></figure><p>建表时，usernname 长度为 16，这里用 10。这是因为一般情况下名字的长度不会超过 10，这样会加速索引查询速度，还会减少索引文件的大小，提高 INSERT 的更新速度。</p><p>如果分别在 usernname，city，age 上建立单列索引，让该表有 3 个单列索引，查询时和上述的组合索引效率也会大不一样，远远低于我们的组合索引。虽然此时有了三个索引，但 MySQL 只能用到其中的那个它认为似乎是最有效率的单列索引。</p><p>建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usernname,city,age</span><br><span class="line">usernname,city</span><br><span class="line">usernname</span><br></pre></td></tr></table></figure><p>为什么没有 city，age 这样的组合索引呢？这是因为 MySQL 组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引，下面的几个 SQL 就会用到这个组合索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable WHREE username=<span class="string">"admin"</span> <span class="keyword">AND</span> city=<span class="string">"郑州"</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable WHREE username=<span class="string">"admin"</span></span><br></pre></td></tr></table></figure><p>而下面几个则不会用到：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable WHREE age=<span class="number">20</span> <span class="keyword">AND</span> city=<span class="string">"郑州"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable WHREE city=<span class="string">"郑州"</span></span><br></pre></td></tr></table></figure><h2 id="（5）建立索引的时机"><a href="#（5）建立索引的时机" class="headerlink" title="（5）建立索引的时机"></a>（5）建立索引的时机</h2><p>到这里我们已经学会了建立索引，那么我们需要在什么情况下建立索引呢？一般来说，在 WHERE 和 JOIN 中出现的列需要建立索引，但也不完全如此，因为 MySQL 只对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的 LIKE 才会使用索引。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.Name</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> mytable t <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> mytable m</span><br><span class="line"></span><br><span class="line"><span class="keyword">ON</span> t.Name=m.username <span class="keyword">WHERE</span> m.age=<span class="number">20</span> <span class="keyword">AND</span> m.city=<span class="string">'郑州'</span></span><br></pre></td></tr></table></figure><p>此时就需要对 city 和 age 建立索引，由于 mytable 表的 userame 也出现在了 JOIN 子句中，也有对它建立索引的必要。</p><p>刚才提到只有某些时候的 LIKE 才需建立索引。因为在以通配符%和_开头作查询时，MySQL 不会使用索引。例如下句会使用索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable <span class="keyword">WHERE</span> username <span class="keyword">like</span><span class="string">'admin%'</span></span><br></pre></td></tr></table></figure><p>而下句就不会使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable WHEREt <span class="keyword">Name</span> <span class="keyword">like</span><span class="string">'%admin'</span></span><br></pre></td></tr></table></figure><p>因此，在使用 LIKE 时应注意以上的区别。</p><h2 id="（6）索引的不足之处"><a href="#（6）索引的不足之处" class="headerlink" title="（6）索引的不足之处"></a>（6）索引的不足之处</h2><p>上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：</p><ul><li><p>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT、UPDATE 和 DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件。</p></li><li><p>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。</p></li></ul><p>索引只是提高效率的一个因素，如果你的 MySQL 有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。</p><h2 id="（7）使用索引的注意事项"><a href="#（7）使用索引的注意事项" class="headerlink" title="（7）使用索引的注意事项"></a>（7）使用索引的注意事项</h2><p>使用索引时，有以下一些技巧和注意事项：</p><ul><li>索引不会包含有 NULL 值的列<br>只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL 值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为 NULL。</li><li>使用短索引<br>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个 CHAR(255)的列，如果在前 10 个或 20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和 I/O 操作。</li><li>索引列排序<br>MySQL 查询只使用一个索引，因此如果 where 子句中已经使用了索引的话，那么 order by 中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</li><li>like 语句操作<br>一般情况下不鼓励使用 like 操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而 like “aaa%”可以使用索引。</li><li>不要在列上进行运算</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">YEAR</span>(adddate)&lt;<span class="number">2007</span>;</span><br></pre></td></tr></table></figure><p>将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where adddate&lt;‘2007-01-01’;</span><br></pre></td></tr></table></figure><ul><li>不使用 NOT IN 和&lt;&gt;操作</li></ul><h2 id="索引原理："><a href="#索引原理：" class="headerlink" title="索引原理："></a>索引原理：</h2><p>想要理解索引原理必须清楚一种数据结构「平衡树」(非二叉)，也就是 b tree 或者 b+ tree，重要的事情说三遍：“平衡树，平衡树，平衡树”。当然， 有的数据库也使用哈希桶作用索引的数据结构 ， 然而， 主流的 RDBMS 都是把平衡树当做数据表默认的索引数据结构的。</p><p>我们平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，数据库会拒绝建表的语句执行。 事实上， 一个加了主键的表，并不能被称之为「表」。一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟我认知中的「表」很接近。如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引。没错， 再说一遍， 整个表变成了一个索引，也就是所谓的「聚集索引」。 这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。</p><p>上图就是带有主键的表（聚集索引）的结构图。图画的不是很好， 将就着看。其中树的所有结点（底部除外）的数据都是由主键字段中的数据构成，也就是通常我们指定主键的 id 字段。最下面部分是真正表中的数据。 假如我们执行一个 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1256</span>;</span><br></pre></td></tr></table></figure><p>首先根据索引定位到 1256 这个值所在的叶结点，然后再通过叶结点取到 id 等于 1256 的数据行。 这里不讲解平衡树的运行细节， 但是从上图能看出，树一共有三层， 从根节点至叶节点只需要经过三次查找就能得到结果。如下图</p><p>假如一张表有一亿条数据 ，需要查找其中某一条数据，按照常规逻辑， 一条一条的去匹配的话， 最坏的情况下需要匹配一亿次才能得到结果，用大 O 标记法就是 O(n)最坏时间复杂度，这是无法接受的，而且这一亿条数据显然不能一次性读入内存供程序使用， 因此， 这一亿次匹配在不经缓存优化的情况下就是一亿次 IO 开销，以现在磁盘的 IO 能力和 CPU 的运算能力， 有可能需要几个月才能得出结果 。如果把这张表转换成平衡树结构（一棵非常茂盛和节点非常多的树），假设这棵树有 10 层，那么只需要 10 次 IO 开销就能查找到所需要的数据， 速度以指数级别提升，用大 O 标记法就是 O(log n)，n 是记录总树，底数是树的分叉数，结果就是树的层次数。换言之，查找次数是以树的分叉数为底，记录总数的对数，用公式来表示就是</p><p>用程序来表示就是 Math.Log(100000000,10)，100000000 是记录数，10 是树的分叉数（真实环境下分叉数远不止 10）， 结果就是查找次数，这里的结果从亿降到了个位数。因此，利用索引会使数据库查询有惊人的性能提升。</p><p>然而， 事物都是有两面的， 索引能让数据库查询数据的速度上升， 而使写入数据的速度下降，原因很简单的， 因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构， 因此，在每次数据改变时， DBMS 必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因。</p><p>讲完聚集索引 ， 接下来聊一下非聚集索引， 也就是我们平时经常提起和使用的常规索引。</p><p>非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。索引树结构中各节点的值来自于表中的索引字段， 假如给 user 表的 name 字段加上索引 ， 那么索引就是由 name 字段中的值构成，在数据改变时， DBMS 需要一直维护索引结构的正确性。如果给表中多个字段加上索引 ， 那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。 如下图</p><p>每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。</p><p>非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据，如下图</p><p>不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。</p><p>然而， 有一种例外可以不使用聚集索引就能查询出所需要的数据， 这种非主流的方法 称之为「覆盖索引」查询， 也就是平时所说的复合索引或者多字段索引查询。 文章上面的内容已经指出， 当为字段建立索引以后， 字段中的内容会被同步到索引之中， 如果为一个索引指定两个字段， 那么这个两个字段的内容都会被同步至索引之中。</p><p>先看下面这个 SQL 语句</p><p>//建立索引</p><p>create index index_birthday on user_info(birthday);</p><p>//查询生日在 1991 年 11 月 1 日出生用户的用户名</p><p>select user_name from user_info where birthday = ‘1991-11-1’</p><p>这句 SQL 语句的执行过程如下</p><p>首先，通过非聚集索引 index_birthday 查找 birthday 等于 1991-11-1 的所有记录的主键 ID 值</p><p>然后，通过得到的主键 ID 值执行聚集索引查找，找到主键 ID 值对就的真实数据（数据行）存储的位置</p><p>最后， 从得到的真实数据中取得 user_name 字段的值返回， 也就是取得最终的结果</p><p>我们把 birthday 字段上的索引改成双字段的覆盖索引</p><p>create index index_birthday_and_user_name on user_info(birthday, user_name);</p><p>这句 SQL 语句的执行过程就会变为</p><p>通过非聚集索引 index_birthday_and_user_name 查找 birthday 等于 1991-11-1 的叶节点的内容，然而， 叶节点中除了有 user_name 表主键 ID 的值以外， user_name 字段的值也在里面， 因此不需要通过主键 ID 值的查找数据行的真实所在， 直接取得叶节点中 user_name 的值返回即可。 通过这种覆盖索引直接查找的方式， 可以省略不使用覆盖索引查找的后面两个步骤， 大大的提高了查询性能，如下图</p><p>数据库索引的大致工作原理就是像文中所述， 然而细节方面可能会略有偏差，这但并不会对概念阐述的结果产生影响 。</p><p>最后， 推荐三本关系数据库方面的书籍， 文中所讲解的概念内容都是来自于此。</p><p>《SQL Server2005 技术内幕之 T-SQL 查询》</p><p>这本书虽然是针对 SQL Server 写的， 但是里面的大部份内容同样适用于其它关系数据库，此书对查询编写的技巧和优化讲解的非常透彻。</p><p>《关系数据库系统概论》第四版</p><p>王珊和萨师煊写的那本， 是大学计算机教材， 讲的通俗易懂， 在国内计算机书图书出版领域质量是排的上号的。</p><p>《数据库系统概念》</p><p>这本书在数据库领域非常出名， 被称之为帆船书， 书中内容博大精深，非一朝一夕可参透的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL 索引类型一览 让 MySQL 高效运行起来&lt;br&gt;本文介绍了七种 MySQL 索引类型。在数据库表中，对字段建立索引可以大大提高查询速度。通过善用这些索引，可以令 MySQL 的查询和运行更加高效。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="http://linthan.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>图解Go的channel底层实现</title>
    <link href="http://linthan.github.io/blog/2020/07/16/tech/golang/daiery-2020-07-16-0700/"/>
    <id>http://linthan.github.io/blog/2020/07/16/tech/golang/daiery-2020-07-16-0700/</id>
    <published>2020-07-15T23:30:00.000Z</published>
    <updated>2020-07-16T00:06:45.213Z</updated>
    
    <content type="html"><![CDATA[<p>废话不多说，直奔主题。</p><h2 id="channel-的整体结构图"><a href="#channel-的整体结构图" class="headerlink" title="channel 的整体结构图"></a>channel 的整体结构图</h2><p><img src="/blog/assets/golang/channel/hchan.png" alt="hchan"><br>简单说明：</p><ul><li>buf 是有缓冲的 channel 所特有的结构，用来存储缓存数据。是个循环链表</li><li>sendx 和 recvx 用于记录 buf 这个循环链表中的发送或者接收的 index</li><li>lock 是个互斥锁。</li><li>recvq 和 sendq 分别是接收(&lt;-channel)或者发送(channel &lt;- xxx)的 goroutine 抽象出来的结构体(sudog)的队列。是个双向链表</li></ul><a id="more"></a><p>源码位于/runtime/chan.go 中(目前版本：1.11)。结构体为 hchan。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span></span><br><span class="line">    closed   <span class="keyword">uint32</span></span><br><span class="line">    elemtype *_type <span class="comment">// element type</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">    recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">    sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来详细介绍 hchan 中各部分是如何使用的。</p><h2 id="先从创建开始"><a href="#先从创建开始" class="headerlink" title="先从创建开始"></a>先从创建开始</h2><p>我们首先创建一个 channel。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="/blog/assets/golang/channel/hchan1.png" alt="hchan1"><br>创建 channel 实际上就是在内存中实例化了一个 hchan 的结构体，并返回一个 ch 指针，我们使用过程中 channel 在函数之间的传递都是用的这个指针，这就是为什么函数传递中无需使用 channel 的指针，而直接用 channel 就行了，因为 channel 本身就是一个指针。</p><h2 id="channel-中发送-send-ch-lt-xxx-和-recv-lt-ch-接收"><a href="#channel-中发送-send-ch-lt-xxx-和-recv-lt-ch-接收" class="headerlink" title="channel 中发送 send(ch &lt;- xxx)和 recv(&lt;- ch)接收"></a>channel 中发送 send(ch &lt;- xxx)和 recv(&lt;- ch)接收</h2><p>先考虑一个问题，如果你想让 goroutine 以先进先出(FIFO)的方式进入一个结构体中，你会怎么操作？<br>加锁！对的！channel 就是用了一个锁。hchan 本身包含一个互斥锁 mutex</p><h2 id="channel-中队列是如何实现的"><a href="#channel-中队列是如何实现的" class="headerlink" title="channel 中队列是如何实现的"></a>channel 中队列是如何实现的</h2><p>channel 中有个缓存 buf，是用来缓存数据的(假如实例化了带缓存的 channel 的话)队列。我们先来看看是如何实现“队列”的。<br>还是刚才创建的那个 channel</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="/blog/assets/golang/channel/hchan_gif1.png" alt="hchan_gif1"></p><p>当使用 send (ch &lt;- xx)或者 recv ( &lt;-ch)的时候，首先要锁住 hchan 这个结构体。</p><p><img src="/blog/assets/golang/channel/hchan_gif2.png" alt="hchan_gif2"></p><p>然后开始 send (ch &lt;- xx)数据。<br>一</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure><p>二</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure><p>三</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这时候满了，队列塞不进去了<br>动态图表示为：<br><img src="/blog/assets/golang/channel/send.gif" alt="send"></p><p>然后是取 recv ( &lt;-ch)的过程，是个逆向的操作，也是需要加锁。<br><img src="/blog/assets/golang/channel/hchan_gif6.png" alt="hchan_gif6"></p><p>然后开始 recv (&lt;-ch)数据。<br>一</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;-ch</span><br></pre></td></tr></table></figure><p>二</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;-ch</span><br></pre></td></tr></table></figure><p>三</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;-ch</span><br></pre></td></tr></table></figure><p>图为：<br><img src="/blog/assets/golang/channel/recv.gif" alt="recv"></p><p>注意以上两幅图中 buf 和 recvx 以及 sendx 的变化，recvx 和 sendx 是根据循环链表 buf 的变动而改变的。<br>至于为什么 channel 会使用循环链表作为缓存结构，我个人认为是在缓存列表在动态的 send 和 recv 过程中，定位当前 send 或者 recvx 的位置、选择 send 的和 recvx 的位置比较方便吧，只要顺着链表顺序一直旋转操作就好。</p><p>缓存中按链表顺序存放，取数据的时候按链表顺序读取，符合 FIFO 的原则。</p><h2 id="send-recv-的细化操作"><a href="#send-recv-的细化操作" class="headerlink" title="send/recv 的细化操作"></a>send/recv 的细化操作</h2><p>注意：缓存链表中以上每一步的操作，都是需要加锁操作的！</p><p>每一步的操作的细节可以细化为：</p><ul><li>第一，加锁</li><li>第二，把数据从 goroutine 中 copy 到“队列”中(或者从队列中 copy 到 goroutine 中）。</li><li>第三，释放锁</li></ul><p>每一步的操作总结为动态图为：(发送过程)<br><img src="/blog/assets/golang/channel/send_single.gif" alt="send_single"><br>或者为：(接收过程)<br><img src="/blog/assets/golang/channel/recv_single.gif" alt="recv_single"></p><p>所以不难看出，Go 中那句经典的话：Do not communicate by sharing memory; instead, share memory by communicating.的具体实现就是利用 channel 把数据从一端 copy 到了另一端！<br>还真是符合 channel 的英文含义：<br><img src="/blog/assets/golang/channel/hchan_channl.png" alt="hchan_channl"></p><h2 id="当-channel-缓存满了之后会发生什么？这其中的原理是怎样的？"><a href="#当-channel-缓存满了之后会发生什么？这其中的原理是怎样的？" class="headerlink" title="当 channel 缓存满了之后会发生什么？这其中的原理是怎样的？"></a>当 channel 缓存满了之后会发生什么？这其中的原理是怎样的？</h2><p>使用的时候，我们都知道，当 channel 缓存满了，或者没有缓存的时候，我们继续 send(ch &lt;- xxx)或者 recv(&lt;- ch)会阻塞当前 goroutine，但是，是如何实现的呢？</p><p>我们知道，Go 的 goroutine 是用户态的线程(user-space threads)，用户态的线程是需要自己去调度的，Go 有运行时的 scheduler 去帮我们完成调度这件事情。关于 Go 的调度模型 GMP 模型我在此不做赘述，如果不了解，可以看我另一篇文章(Go 调度原理)</p><p>goroutine 的阻塞操作，实际上是调用 send (ch &lt;- xx)或者 recv ( &lt;-ch)的时候主动触发的，具体请看以下内容：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//goroutine1 中，记做G1</span></span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/blog/assets/golang/channel/hchan_block.png" alt="hchan_block"><br><img src="/blog/assets/golang/channel/hchan_block1.png" alt="hchan_block1"></p><p>这个时候 G1 正在正常运行,当再次进行 send 操作(ch&lt;-1)的时候，会主动调用 Go 的调度器,让 G1 等待，并从让出 M，让其他 G 去使用<br><img src="/blog/assets/golang/channel/hchan_block2.png" alt="hchan_block2"><br>同时 G1 也会被抽象成含有 G1 指针和 send 元素的 sudog 结构体保存到 hchan 的 sendq 中等待被唤醒。<br><img src="/blog/assets/golang/channel/hchan_block3.png" alt="hchan_block3"><br>那么，G1 什么时候被唤醒呢？这个时候 G2 隆重登场。</p><p><img src="/blog/assets/golang/channel/hchan_block4.png" alt="hchan_block4"><br>G2 执行了 recv 操作 p := &lt;-ch，于是会发生以下的操作：</p><p>G2 从缓存队列中取出数据，channel 会将等待队列中的 G1 推出，将 G1 当时 send 的数据推到缓存中，然后调用 Go 的 scheduler，唤醒 G1，并把 G1 放到可运行的 Goroutine 队列中。</p><p>假如是先进行执行 recv 操作的 G2 会怎么样？<br>你可能会顺着以上的思路反推。首先：</p><p>这个时候 G2 会主动调用 Go 的调度器,让 G2 等待，并从让出 M，让其他 G 去使用。<br>G2 还会被抽象成含有 G2 指针和 recv 空元素的 sudog 结构体保存到 hchan 的 recvq 中等待被唤醒</p><p>此时恰好有个 goroutine G1 开始向 channel 中推送数据 ch &lt;- 1。<br>此时，非常有意思的事情发生了：</p><p>G1 并没有锁住 channel，然后将数据放到缓存中，而是直接把数据从 G1 直接 copy 到了 G2 的栈中。<br>这种方式非常的赞！在唤醒过程中，G2 无需再获得 channel 的锁，然后从缓存中取数据。减少了内存的 copy，提高了效率。</p><p>之后的事情显而易见：</p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ul><li><a href="https://www.youtube.com/watch?v=KBZlN0izeiY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=KBZlN0izeiY</a></li><li><a href="https://zhuanlan.zhihu.com/p/27917262" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27917262</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;废话不多说，直奔主题。&lt;/p&gt;
&lt;h2 id=&quot;channel-的整体结构图&quot;&gt;&lt;a href=&quot;#channel-的整体结构图&quot; class=&quot;headerlink&quot; title=&quot;channel 的整体结构图&quot;&gt;&lt;/a&gt;channel 的整体结构图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/blog/assets/golang/channel/hchan.png&quot; alt=&quot;hchan&quot;&gt;&lt;br&gt;简单说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;buf 是有缓冲的 channel 所特有的结构，用来存储缓存数据。是个循环链表&lt;/li&gt;
&lt;li&gt;sendx 和 recvx 用于记录 buf 这个循环链表中的发送或者接收的 index&lt;/li&gt;
&lt;li&gt;lock 是个互斥锁。&lt;/li&gt;
&lt;li&gt;recvq 和 sendq 分别是接收(&amp;lt;-channel)或者发送(channel &amp;lt;- xxx)的 goroutine 抽象出来的结构体(sudog)的队列。是个双向链表&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="golang" scheme="http://linthan.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Http get与pos、HEAD的区别</title>
    <link href="http://linthan.github.io/blog/2020/07/15/tech/interview/daiery-2020-0715-2300/"/>
    <id>http://linthan.github.io/blog/2020/07/15/tech/interview/daiery-2020-0715-2300/</id>
    <published>2020-07-15T15:00:00.000Z</published>
    <updated>2020-07-15T23:34:02.438Z</updated>
    
    <content type="html"><![CDATA[<p>Http get 与 pos 的区别</p><p>GET 和 POST 是 HTTP 请求的两种基本方法，要说它们的区别，接触过 WEB 开发的人都能说出一二。</p><p>最直观的区别就是 GET 把参数包含在 URL 中，POST 通过 request body 传递参数。</p><p>你可能自己写过无数个 GET 和 POST 请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。</p><a id="more"></a><p>当你在面试中被问到这个问题，你的内心充满了自信和喜悦。</p><p>你轻轻松松的给出了一个“标准答案”：</p><ul><li>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。</li><li>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。</li><li>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。</li><li>GET 请求只能进行 url 编码，而 POST 支持多种编码方式。</li><li>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。</li><li>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有。</li><li>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</li><li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</li><li>GET 参数通过 URL 传递，POST 放在 Request body 中。</li></ul><p>“很遗憾，这不是我们要的回答！”</p><p>如果我告诉你 GET 和 POST 本质上没有区别你信吗？<br>让我们扒下 GET 和 POST 的外衣，坦诚相见吧！</p><p>GET 和 POST 是什么？HTTP 协议中的两种发送请求的方法。</p><p>HTTP 是什么？HTTP 是基于 TCP/IP 的关于数据如何在万维网中如何通信的协议。</p><p>HTTP 的底层是 TCP/IP。所以 GET 和 POST 的底层也是 TCP/IP，也就是说，GET/POST 都是 TCP 链接。GET 和 POST 能做的事情是一样一样的。你要给 GET 加上 request body，给 POST 带上 url 参数，技术上是完全行的通的。</p><p>那么，“标准答案”里的那些区别是怎么回事？</p><p>在我大万维网世界中，TCP 就像汽车，我们用 TCP 来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则 HTTP 诞生了。HTTP 给汽车运输设定了好几个服务类别，有 GET, POST, PUT, DELETE 等等，HTTP 规定，当执行 GET 请求的时候，要给汽车贴上 GET 的标签（设置 method 为 GET），而且要求把传送的数据放在车顶上（url 中）以方便记录。如果是 POST 请求，就要在车上贴上 POST 的标签，并把货物放在车厢里。当然，你也可以在 GET 的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在 POST 的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP 只是个行为准则，而 TCP 才是 GET 和 POST 怎么实现的基本。</p><p>但是，我们只看到 HTTP 对 GET 和 POST 参数的传送渠道（url 还是 requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？</p><p>在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起 http 请求）和服务器（接受 http 请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url 中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制 url 长度在 2K 个字节，而（大多数）服务器最多处理 64K 大小的 url。超过的部分，恕不处理。如果你用 GET 服务，在 request body 偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然 GET 可以带 request body，也不能保证一定能被接收到哦。</p><p>好了，现在你知道，GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p><p>你以为本文就这么结束了？</p><p>我们的大 BOSS 还等着出场呢。。。</p><p>这位 BOSS 有多神秘？当你试图在网上找“GET 和 POST 的区别”的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢。。。</p><p>GET 和 POST 还有一个重大区别，简单的说：</p><p>GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。</p><p>长的说：</p><p>对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；</p><p>而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。</p><p>也就是说，GET 只需要汽车跑一趟就把货送到了，而 POST 得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p><p>因为 POST 需要两步，时间上消耗的要多一点，看起来 GET 比 POST 更有效。因此 Yahoo 团队有推荐用 GET 替换 POST 来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p><ol><li><p>GET 与 POST 都有自己的语义，不能随便混用。</p></li><li><p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点。</p></li><li><p>并不是所有浏览器都会在 POST 中发送两次包，Firefox 就只发送一次。</p></li></ol><p>现在，当面试官再问你“GET 与 POST 的区别”的时候，你的内心是不是这样的？</p><h2 id="HTTP-协议中-GET、POST-和-HEAD-的区别？"><a href="#HTTP-协议中-GET、POST-和-HEAD-的区别？" class="headerlink" title="HTTP 协议中 GET、POST 和 HEAD 的区别？"></a>HTTP 协议中 GET、POST 和 HEAD 的区别？</h2><p><a href="https://blog.csdn.net/qq_29920751/article/details/52245659" target="_blank" rel="noopener">https://blog.csdn.net/qq_29920751/article/details/52245659</a></p><p>HEAD： 只请求页面的首部。</p><p>GET： 请求指定的页面信息，并返回实体主体。</p><p>POST： 请求服务器接受所指定的文档作为对所标识的 URL 的新的从属实体。</p><p>（1）HTTP 定义了与服务器交互的不同方法，最基本的方法是 GET 和 POST。事实上 GET 适用于多数请求，而保留 POST 仅用于更新站点。</p><p>（2）在 FORM 提交的时候，如果不指定 Method，则默认为 GET 请 求，Form 中提交的数据将会附加在 url 之后，以?分开与 url 分开。字母数字字符原样发送，但空格转换为“+“号，其它符号转换为%XX,其中 XX 为该符号以 16 进制表示的 ASCII（或 ISO Latin-1）值。GET 请求请提交的数据放置在 HTTP 请求协议头中，而 POST 提交的数据则放在实体数据中；</p><p>GET 方式提交的数据最多只能有 1024 字节，而 POST 则没有此限制。</p><p>（3）GET  这个是浏览器用语向服务器请求最常用的方法。POST 这个方法也是用来传送数据的，但是与 GET 不同的是，使用 POST 的时候，数据不是附在 URI 后面传递的，而是要做为独立的行来传递，此时还必须要发送一个 Content_length 标题，以标明数据长度，随后一个空白行，然后就是实际传送的数据。网页的表单通常是用 POST 来传送的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Http get 与 pos 的区别&lt;/p&gt;
&lt;p&gt;GET 和 POST 是 HTTP 请求的两种基本方法，要说它们的区别，接触过 WEB 开发的人都能说出一二。&lt;/p&gt;
&lt;p&gt;最直观的区别就是 GET 把参数包含在 URL 中，POST 通过 request body 传递参数。&lt;/p&gt;
&lt;p&gt;你可能自己写过无数个 GET 和 POST 请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="面试" scheme="http://linthan.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="golang" scheme="http://linthan.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>几大排序的稳定性</title>
    <link href="http://linthan.github.io/blog/2020/07/15/tech/algorithm/daiery-2020-07-15-2200/"/>
    <id>http://linthan.github.io/blog/2020/07/15/tech/algorithm/daiery-2020-07-15-2200/</id>
    <published>2020-07-15T14:00:00.000Z</published>
    <updated>2020-07-15T14:43:52.746Z</updated>
    
    <content type="html"><![CDATA[<p>以前看人利用口诀记忆排序的稳定性：考研好痛苦，一堆（堆排序）专业课，情绪不稳定（不稳定排序），快（快速排序）来选（选择排序）一些（希尔排序）朋友聊聊天吧，剩下的都是稳定的。</p><p>感觉不错。。。。。。</p><p>接下来是八大排序总结</p><a id="more"></a><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="(1)冒泡排序"></a>(1)冒泡排序</h2><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;<span class="comment">//[low,high)</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; (high = bubble(a, low, high)));<span class="comment">//逐趟扫描，直至全部有序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = low;</span><br><span class="line">    <span class="keyword">while</span>(++low&lt;high)</span><br><span class="line">        <span class="keyword">if</span>(a[low<span class="number">-1</span>]&gt;a[low])&#123;</span><br><span class="line">            swap(a[low<span class="number">-1</span>],a[low]);</span><br><span class="line">            last = low;<span class="comment">//找到上次最后一次发生交换的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;<span class="comment">//平均复杂度太高了，不能用不能用。。。。。。</span></span><br></pre></td></tr></table></figure><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="(2)选择排序"></a>(2)选择排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> min_index = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; right; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt;= arr[min_index]) min_index = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::swap(arr[min_index], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// o(n^2) 复杂度较高不好用</span></span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。这个排序也可以利用 STL 的 sort 来模拟，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。这个排序在元素个数较少或者序列基本有序的情况下速度是非常可观的，对一组序列如果数据量很大的时候可以主要用快排，当快排将区间划分的较小的时候切换排序方式为插入排序（如果快速排序递归栈过深也可采用堆排序避免）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[i - <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;=<span class="number">0</span> &amp;&amp; temp &lt; arr[j]; --j)&#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//元素基本有序的情况下，这个排序的复杂度很低，挺实用的，附上代码一份</span></span><br></pre></td></tr></table></figure><h2 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="(4)快速排序"></a>(4)快速排序</h2><p>简单来说就是选取一个中枢元素，一轮下来比中枢元素的小的在一边，比中枢元素大的在另外一边，所以每一轮可以将这一轮的中枢元素移动到其最终位置上(用此方法可以快速找到数组中第 K 个大小的元素而无需使用堆这一数据结构)，这个<br>比如序列为 5 6 3 4 3，以 5 为中枢元素，一轮下来该序列变成 3 4 3 5 6,（5 已经在最终位置上，但是两个 3 的相对位置发生了改变）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void Qsort2(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high;</span><br><span class="line">    <span class="keyword">int</span> key = arr[low];</span><br><span class="line">    while(i &lt; j)&#123;</span><br><span class="line">        while(i &lt; j &amp;&amp; key &lt;= arr[j]) j--;</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        while(i &lt; j &amp;&amp; key &gt;= arr[i]) i++;</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = key;</span><br><span class="line">    Qsort2(arr, low, i - <span class="number">1</span>);</span><br><span class="line">    Qsort2(arr, i + <span class="number">1</span>, high);</span><br><span class="line">&#125;<span class="comment">//复杂度o(nlogn)，速度很快但是递归过程中可能爆栈，总的来说还是非常实用的</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Qsort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x = arr[i + j &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[++i] &lt; x);</span><br><span class="line">        <span class="keyword">while</span> (arr[--j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    Qsort(arr, l, j);</span><br><span class="line">    Qsort(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="(5)归并排序"></a>(5)归并排序</h2><p>归并排序是针对两个已经排好序的序列，将这；两个序列合并成一个有序序列的排序方法，对于一个长度为 n 未排序的序列，我们一开始可以假设它是 n 个长度为 1 的有序序列构成，然后进行一次合并变成 n / 2 个长度为 2 的有序序列，然后再一次合并成</p><p>n / 4 个长度为 4 的有序序列，以此类推。。。进行 log2 (n)次后整个未排序序列就会变成一个长度为 n 的有序序列，时间复杂度为 O(logn)</p><p>归并排序是稳定的排序算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) ++n;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="comment">// i是每轮区间的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">            <span class="comment">// j是每轮排序的两个区间的第一个节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt; n; j += i &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// left是左边起点， right是右边起点</span></span><br><span class="line">                <span class="keyword">auto</span> left = cur-&gt;next, right = cur-&gt;next;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k) right = right-&gt;next;</span><br><span class="line">                <span class="comment">// l是左边以及排好序的节点数，r是右边已经排好序的节点数</span></span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; i &amp;&amp; r &lt; i &amp;&amp; right) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (left-&gt;val &lt; right-&gt;val) &#123;</span><br><span class="line">                        cur-&gt;next = left;</span><br><span class="line">                        cur = left;</span><br><span class="line">                        left = left-&gt;next;</span><br><span class="line">                        l++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        cur-&gt;next = right;</span><br><span class="line">                        cur = right;</span><br><span class="line">                        right = right-&gt;next;</span><br><span class="line">                        r++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; i) &#123;</span><br><span class="line">                    cur-&gt;next = left;</span><br><span class="line">                    cur = left;</span><br><span class="line">                    left = left-&gt;next;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (r &lt; i &amp;&amp; right) &#123;</span><br><span class="line">                    cur-&gt;next = right;</span><br><span class="line">                    cur = right;</span><br><span class="line">                    right = right-&gt;next;</span><br><span class="line">                    r++;</span><br><span class="line">                &#125;</span><br><span class="line">                cur-&gt;next = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; <span class="comment">// leetcode 148 链表的归并排序， 时间复杂度O(n), 空间复杂度O(1)</span></span><br></pre></td></tr></table></figure><h2 id="6-基数排序-（桶排序）"><a href="#6-基数排序-（桶排序）" class="headerlink" title="(6)基数排序 （桶排序）"></a>(6)基数排序 （桶排序）</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。</p><h2 id="7-希尔排序-shell"><a href="#7-希尔排序-shell" class="headerlink" title="(7)希尔排序(shell)"></a>(7)希尔排序(shell)</h2><p>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比 O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以 shell 排序是不稳定的。<br>听说复杂度可以到 o(n^1.3)，没怎么见过人使用。</p><h2 id="8-堆排序"><a href="#8-堆排序" class="headerlink" title="(8)堆排序"></a>(8)堆排序</h2><p>我们知道堆的结构是节点 i 的孩子为 2 _ i 和 2 _ i + 1 节点，大顶堆要求父节点大于等于其 2 个子节点，小顶堆要求父节点小于等于其 2 个子节点。在一个长为 n 的序列，堆排序的过程是从第 n / 2 开始和其子节点共 3 个值选择最大（大顶堆）或者最小（小顶堆），这 3 个元素之间的选择当然不会破坏稳定性。但当为 n / 2 - 1， n / 2 - 2， … 1 这些个父节点选择元素时，就会破坏稳定性。有可能第 n / 2 个父节点交换把后面一个元素交换过去了，而第 n / 2 - 1 个父节点把后面一个相同的元素没 有交换，那么这 2 个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可以用STL中make_heap来建堆并进行模拟，在复杂度和快速排序一样是o(nlogn)但是听说在排序过程中有较多的  &lt;&lt; 1 和 &gt;&gt; 1操作，对CPU来说并不是非常友好，而快速排序都是++或者--操作，</span><br><span class="line">所以STL的sort只有在递归栈过深的情况下才会使用堆排序，代码参见数据结构——堆的代码即可。</span><br><span class="line">3 2 2  ---------------------------------&gt;(after sort)------------------------&gt;2 2 3 （两个2的相对位置变了）</span><br><span class="line">  3                                                                             2</span><br><span class="line">/   \                                                                         /   \</span><br><span class="line">2   2                                                                         2   3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        0</span></span><br><span class="line"><span class="comment">//    1      2</span></span><br><span class="line"><span class="comment">//   3  4  5   6   ==&gt; left_child = index * 2 + 1</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">left_child</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123; <span class="keyword">return</span> index &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust_down</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child, temp;</span><br><span class="line">    <span class="keyword">for</span> (temp = arr[index]; left_child(index) &lt; size; index = child) &#123;</span><br><span class="line">        child = left_child(index);  <span class="comment">// left child</span></span><br><span class="line">        <span class="keyword">if</span> (child != size - <span class="number">1</span> &amp;&amp;</span><br><span class="line">            arr[child] &lt; arr[child + <span class="number">1</span>]) &#123;  <span class="comment">// has right child and left child</span></span><br><span class="line">                                            <span class="comment">// less than right child</span></span><br><span class="line">            ++child;                        <span class="comment">// make child point greater node</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; arr[child]) &#123;</span><br><span class="line">            arr[index] = arr[child];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[index] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Max heap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// make heap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        adjust_down(arr, i, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">        arr[i] = max;         <span class="comment">// swap(arr[0], arr[last])</span></span><br><span class="line">        adjust_down(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，得出结论: 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前看人利用口诀记忆排序的稳定性：考研好痛苦，一堆（堆排序）专业课，情绪不稳定（不稳定排序），快（快速排序）来选（选择排序）一些（希尔排序）朋友聊聊天吧，剩下的都是稳定的。&lt;/p&gt;
&lt;p&gt;感觉不错。。。。。。&lt;/p&gt;
&lt;p&gt;接下来是八大排序总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="算法" scheme="http://linthan.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="面试" scheme="http://linthan.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>GoLang Context包详解</title>
    <link href="http://linthan.github.io/blog/2020/07/15/tech/golang/daiery-2020-07-15-2130/"/>
    <id>http://linthan.github.io/blog/2020/07/15/tech/golang/daiery-2020-07-15-2130/</id>
    <published>2020-07-15T13:30:00.000Z</published>
    <updated>2020-07-15T14:06:50.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Context 是一个在 go 中经常用到的程序包，谷歌官方开发。特别常见的一个应用场景是有一个请求衍生出来的各个 goroutine 之间需要满足一定的约束条件，以实现一些诸如有效期、终止 routline 树、传递请求全局变量之类的功能。使用 Context 实现上下文功能约定需要在你的方法中传入参数的第一个传入 context.Context 类型的变量，我们将通过源码的阅读和一些示例代码来说明 context 的用法。</p><a id="more"></a><h2 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认错误：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">"context canceled"</span>)</span><br><span class="line"><span class="keyword">var</span> DeadlineExceeded error = deadlineExceededError&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> deadlineExceededError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>   &#123; <span class="keyword">return</span> <span class="string">"context deadline exceeded"</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span> <span class="title">Timeout</span><span class="params">()</span> <span class="title">bool</span></span>   &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span> <span class="title">Temporary</span><span class="params">()</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>空 Context</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An emptyCtx is never canceled, has no values, and has no deadline. It is not</span></span><br><span class="line"><span class="comment">// struct&#123;&#125;, since vars of this type must have distinct addresses.</span></span><br><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *emptyCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> e &#123;</span><br><span class="line">    <span class="keyword">case</span> background:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"context.Background"</span></span><br><span class="line">    <span class="keyword">case</span> todo:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"context.TODO"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"unknown empty Context"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码包中提供了两个空 Context</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">    todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Background returns a non-nil, empty Context. It is never canceled, has no</span></span><br><span class="line"><span class="comment">// values, and has no deadline. It is typically used by the main function,</span></span><br><span class="line"><span class="comment">// initialization, and tests, and as the top-level Context for incoming</span></span><br><span class="line"><span class="comment">// requests.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO returns a non-nil, empty Context. Code should use context.TODO when</span></span><br><span class="line"><span class="comment">// it's unclear which Context to use or it is not yet available (because the</span></span><br><span class="line"><span class="comment">// surrounding function has not yet been extended to accept a Context</span></span><br><span class="line"><span class="comment">// parameter). TODO is recognized by static analysis tools that determine</span></span><br><span class="line"><span class="comment">// whether Contexts are propagated correctly in a program.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="canceler"><a href="#canceler" class="headerlink" title="canceler"></a>canceler</h2><p>cancelCtx 结构体继承了 Context，实现了 canceler 方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*cancelCtx 和 *timerCtx都实现了canceler接口，实现该接口的类型都可以直接被cancel</span></span><br><span class="line"><span class="comment">// A canceler is a context type that can be canceled directly. The</span></span><br><span class="line"><span class="comment">// implementations are *cancelCtx and *timerCtx.</span></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">    cancel(removeFromParent <span class="keyword">bool</span>, err error)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A cancelCtx can be canceled. When canceled, it also cancels any children</span></span><br><span class="line"><span class="comment">// that implement canceler.</span></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line"></span><br><span class="line">    done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// closed by the first cancel call.</span></span><br><span class="line"></span><br><span class="line">    mu       sync.Mutex</span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      error                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> c.done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v.WithCancel"</span>, c.Context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心是关闭c.done</span></span><br><span class="line"><span class="comment">//同时会设置c.err = err, c.children = nil</span></span><br><span class="line"><span class="comment">//依次遍历c.children，每个child分别cancel</span></span><br><span class="line"><span class="comment">//如果设置了removeFromParent，则将c从其parent的children中删除</span></span><br><span class="line"><span class="comment">// cancel closes c.done, cancels each of c's children, and, if</span></span><br><span class="line"><span class="comment">// removeFromParent is true, removes c from its parent's children.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"context: internal error: missing cancel error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.err = err</span><br><span class="line">    <span class="built_in">close</span>(c.done)</span><br><span class="line">    <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> acquiring the child's lock while holding parent's lock.</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    c.children = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        removeChild(c.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一些 cancel 相关的方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">WithCancel</span>方法返回一个继承自<span class="title">parent</span>的<span class="title">Context</span>对象，同时返回的<span class="title">cancel</span>方法可以用来关闭返回的<span class="title">Context</span>当中的<span class="title">Done</span> <span class="title">channel</span></span></span><br><span class="line"><span class="function">// 其将新建立的节点挂载在最近的可以被<span class="title">cancel</span>的父节点下（向下方向）</span></span><br><span class="line"><span class="function">// 如果传入的<span class="title">parent</span>是不可被<span class="title">cancel</span>的节点，则直接只保留向上关系</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span> <span class="title">cancelCtx</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cancelCtx&#123;</span><br><span class="line">        Context: parent,</span><br><span class="line">        done:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递cancel</span></span><br><span class="line"><span class="comment">// 从当前传入的parent开始（包括该parent），向上查找最近的一个可以被cancel的parent</span></span><br><span class="line"><span class="comment">// 如果找到的parent已经被cancel，则将方才传入的child树给cancel掉</span></span><br><span class="line"><span class="comment">// 否则，将child节点直接连接为找到的parent的children中（Context字段不变，即向上的父亲指针不变，但是向下的孩子指针变直接了）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果没有找到最近的可以被cancel的parent，即其上都不可被cancel，则启动一个goroutine等待传入的parent终止，则cancel传入的child树，或者等待传入的child终结。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> parent.Done() == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        p.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// parent has already been canceled</span></span><br><span class="line">            child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">                p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">bool</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            p.children[child] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">                child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">            <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从传入的parent对象开始，依次往上找到一个最近的可以被cancel的对象，即cancelCtx或者timerCtx</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span> <span class="params">(*cancelCtx, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> c := parent.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> *cancelCtx:</span><br><span class="line">            <span class="keyword">return</span> c, <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> *timerCtx:</span><br><span class="line">            <span class="keyword">return</span> &amp;c.cancelCtx, <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> *valueCtx:</span><br><span class="line">            parent = c.Context</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从parent开始往上找到最近的一个可以cancel的父对象</span></span><br><span class="line"><span class="comment">// 从父对象的children map中删除这个child</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    p, ok := parentCancelCtx(parent)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    p.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(p.children, child)</span><br><span class="line">    &#125;</span><br><span class="line">    p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Deadline 和 TimeOut<br>首先看一个继承自 cancelCtx 的结构体：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    cancelCtx <span class="comment">//此处的封装为了继承来自于cancelCtx的方法，cancelCtx.Context才是父亲节点的指针</span></span><br><span class="line">    timer *time.Timer <span class="comment">// Under cancelCtx.mu. 是一个计时器</span></span><br><span class="line">    deadline time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v.WithDeadline(%s [%s])"</span>, c.cancelCtx.Context, c.deadline, c.deadline.Sub(time.Now()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与cencelCtx有所不同，其除了处理cancelCtx.cancel，还回对c.timer进行Stop()，并将c.timer=nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        <span class="comment">// Remove this timerCtx from its parent cancelCtx's children.</span></span><br><span class="line">        removeChild(c.cancelCtx.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.timer.Stop()</span><br><span class="line">        c.timer = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此结构体衍生出的两个方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果parent的deadline比新传入的deadline已经要早，则直接WithCancel，因为新传入的deadline没有效，父亲的deadline会先到期。</span></span><br><span class="line">    <span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(deadline) &#123;</span><br><span class="line">        <span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line">        <span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">    &#125;</span><br><span class="line">    c := &amp;timerCtx&#123;</span><br><span class="line">        cancelCtx: newCancelCtx(parent),</span><br><span class="line">        deadline:  deadline,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接入树</span></span><br><span class="line">    propagateCancel(parent, c)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查如果已经过期，则cancel新的子树</span></span><br><span class="line">    d := deadline.Sub(time.Now())</span><br><span class="line">    <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line">        <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 还没有被cancel的话，就设置deadline之后cancel的计时器</span></span><br><span class="line">        c.timer = time.AfterFunc(d, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// timeout和deadline本质一样</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Value<br>valueCtx 主要用来传递一些元数据，通过 WithValue()来传入继承，通过 Value()来读取，简单，不赘述.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key <span class="keyword">interface</span>&#123;&#125;, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v.WithValue(%#v, %#v)"</span>, c.Context, c.key, c.val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">        <span class="keyword">return</span> c.val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h2><ul><li>Programs that use Contexts should follow these rules to keep interfaces consistent across packages and enable static analysis tools to check context propagation:<br>使用 Context 的程序包需要遵循如下的原则来满足接口的一致性以及便于静态分析</li><li>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. The Context should be the first parameter, typically named ctx:<br>不要把 Context 存在一个结构体当中，显式地传入函数。Context 变量需要作为第一个参数使用，一般命名为 ctx</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">(ctx context.Context, arg Arg)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"> ... use ctx ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>Do not pass a nil Context, even if a function permits it. Pass context.TODO if you are unsure about which Context to use.<br>即使方法允许，也不要传入一个 nil 的 Context，如果你不确定你要用什么 Context 的时候传一个 context.TODO</li><li><p>Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.<br>使用 context 的 Value 相关方法只应该用于在程序和接口中传递的和请求相关的元数据，不要用它来传递一些可选的参数</p></li><li><p>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.<br>同样的 Context 可以用来传递到不同的 goroutine 中，Context 在多个 goroutine 中是安全的</p></li></ul><h2 id="使用要点："><a href="#使用要点：" class="headerlink" title="使用要点："></a>使用要点：</h2><p>其实本身非常简单，在导入这个包之后，初始化 Context 对象，在每个资源访问方法中都调用它，然后在使用时检查 Context 对象是否已经被 Cancel，如果是就释放绑定的资源。如下所示（下面的代码截取自<a href="http://blog.golang.org/context中的示例程序）" target="_blank" rel="noopener">http://blog.golang.org/context中的示例程序）</a><br>初始化并设置最终 cancel：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleSearch</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ctx is the Context for this handler. Calling cancel closes the</span></span><br><span class="line">    <span class="comment">// ctx.Done channel, which is the cancellation signal for requests</span></span><br><span class="line">    <span class="comment">// started by this handler.</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        ctx    context.Context</span><br><span class="line">        cancel context.CancelFunc</span><br><span class="line">    )</span><br><span class="line">    timeout, err := time.ParseDuration(req.FormValue(<span class="string">"timeout"</span>))</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// The request has a timeout, so create a context that is</span></span><br><span class="line">        <span class="comment">// canceled automatically when the timeout expires.</span></span><br><span class="line">        ctx, cancel = context.WithTimeout(context.Background(), timeout)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx, cancel = context.WithCancel(context.Background())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> cancel() <span class="comment">// Cancel ctx as soon as handleSearch returns.</span></span><br></pre></td></tr></table></figure><p>在中间过程传递，并在资源相关操作时判断是否 ctx.Done()传出了值，关于 Done()的使用应该参考<a href="http://blog.golang.org/pipelines" target="_blank" rel="noopener">http://blog.golang.org/pipelines</a> 意外终结的程序返回值应该为对应的 ctx.Err()</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpDo</span><span class="params">(ctx context.Context, req *http.Request, f <span class="keyword">func</span>(*http.Response, error)</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Run the HTTP request in a goroutine and pass the response to f.</span></span><br><span class="line">    tr := &amp;http.Transport&#123;&#125;</span><br><span class="line">    client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- f(client.Do(req)) &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        tr.CancelRequest(req)</span><br><span class="line">        &lt;-c <span class="comment">// Wait for f to return.</span></span><br><span class="line">        <span class="keyword">return</span> ctx.Err()</span><br><span class="line">    <span class="keyword">case</span> err := &lt;-c:</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Context 是一个在 go 中经常用到的程序包，谷歌官方开发。特别常见的一个应用场景是有一个请求衍生出来的各个 goroutine 之间需要满足一定的约束条件，以实现一些诸如有效期、终止 routline 树、传递请求全局变量之类的功能。使用 Context 实现上下文功能约定需要在你的方法中传入参数的第一个传入 context.Context 类型的变量，我们将通过源码的阅读和一些示例代码来说明 context 的用法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="golang" scheme="http://linthan.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>图解Go select语句原理</title>
    <link href="http://linthan.github.io/blog/2020/07/10/tech/golang/daiery-2020-0710-0801/"/>
    <id>http://linthan.github.io/blog/2020/07/10/tech/golang/daiery-2020-0710-0801/</id>
    <published>2020-07-10T00:00:00.000Z</published>
    <updated>2020-07-10T00:22:24.072Z</updated>
    
    <content type="html"><![CDATA[<p>Golang<br>Go 的 select 语句是一种仅能用于 channl 发送和接收消息的专用语句，此语句运行期间是阻塞的；当 select 中没有 case 语句的时候，会阻塞当前的 groutine。所以，有人也会说 select 是用来阻塞监听 goroutine 的。<br>还有人说：select 是 Golang 在语言层面提供的 I/O 多路复用的机制，其专门用来检测多个 channel 是否准备完毕：可读或可写。</p><p>以上说法都正确。</p><a id="more"></a><h2 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h2><p>我们来回顾一下是什么是 I/O 多路复用。</p><h2 id="普通多线程（或进程）I-O"><a href="#普通多线程（或进程）I-O" class="headerlink" title="普通多线程（或进程）I/O"></a>普通多线程（或进程）I/O</h2><p><img src="/blog/assets/golang/select/select-principle_0.png" alt="principle_0"></p><p>每来一个进程，都会建立连接，然后阻塞，直到接收到数据返回响应。<br>普通这种方式的缺点其实很明显：系统需要创建和维护额外的线程或进程。因为大多数时候，大部分阻塞的线程或进程是处于等待状态，只有少部分会接收并处理响应，而其余的都在等待。系统为此还需要多做很多额外的线程或者进程的管理工作。</p><p><img src="/blog/assets/golang/select/select-principle_1.png" alt="select-principle_1"></p><p>为了解决图中这些多余的线程或者进程，于是有了”I/O 多路复用”</p><h2 id="I-O-多路复用-1"><a href="#I-O-多路复用-1" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h2><p><img src="/blog/assets/golang/select/select-principle_2.png" alt="select-principle_2"></p><p>每个线程或者进程都先到图中”装置“中注册，然后阻塞，然后只有一个线程在”运输“，当注册的线程或者进程准备好数据后，”装置“会根据注册的信息得到相应的数据。从始至终 kernel 只会使用图中这个黄黄的线程，无需再对额外的线程或者进程进行管理，提升了效率。</p><h2 id="select-组成结构"><a href="#select-组成结构" class="headerlink" title="select 组成结构"></a>select 组成结构</h2><p>select 的实现经历了多个版本的修改，当前版本为：1.11<br>select 这个语句底层实现实际上主要由两部分组成：case 语句和执行函数。<br>源码地址为：/go/src/runtime/select.go</p><p>每个 case 语句，单独抽象出以下结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> scase <span class="keyword">struct</span> &#123;</span><br><span class="line">    c           *hchan         <span class="comment">// chan</span></span><br><span class="line">    elem        unsafe.Pointer <span class="comment">// 读或者写的缓冲区地址</span></span><br><span class="line">    kind        <span class="keyword">uint16</span>   <span class="comment">//case语句的类型，是default、传值写数据(channel &lt;-) 还是  取值读数据(&lt;- channel)</span></span><br><span class="line">    pc          <span class="keyword">uintptr</span> <span class="comment">// race pc (for race detector / msan)</span></span><br><span class="line">    releasetime <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体可以用下图表示：<br><img src="/blog/assets/golang/select/select-principle_3.png" alt="select-principle_3"></p><p>其中比较关键的是：hchan，它是 channel 的指针。<br>在一个 select 中，所有的 case 语句会构成一个 scase 结构体的数组。<br><img src="/blog/assets/golang/select/select-principle_4.png" alt="select-principle_4"></p><p>然后执行 select 语句实际上就是调用 func selectgo(cas0 <em>scase, order0 </em>uint16, ncases int) (int, bool)函数。<br><img src="/blog/assets/golang/select/select-principle_5.png" alt="select-principle_5"><br>func selectgo(cas0 <em>scase, order0 </em>uint16, ncases int) (int, bool)函数参数：</p><ul><li>cas0 为上文提到的 case 语句抽象出的结构体 scase 数组的第一个元素地址</li><li>order0 为一个两倍 cas0 数组长度的 buffer，保存 scase 随机序列 pollorder 和 scase 中 channel 地址序列 lockorder。</li><li>nncases 表示 scase 数组的长度</li></ul><p>selectgo 返回所选 scase 的索引(该索引与其各自的 select {recv，send，default}调用的序号位置相匹配)。此外，如果选择的 scase 是接收操作(recv)，则返回是否接收到值。</p><p>谁负责调用 func selectgo(cas0 <em>scase, order0 </em>uint16, ncases int) (int, bool)函数呢？</p><p>在/reflect/value.go 中有个 func rselect([]runtimeSelect) (chosen int, recvOK bool)函数，此函数的实现在/runtime/select.go 文件中的 func reflect_rselect(cases []runtimeSelect) (int, bool)函数中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_rselect</span><span class="params">(cases []runtimeSelect)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//如果cases语句为空，则阻塞当前groutine</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cases) == <span class="number">0</span> &#123;</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实例化case的结构体</span></span><br><span class="line">    sel := <span class="built_in">make</span>([]scase, <span class="built_in">len</span>(cases))</span><br><span class="line">    order := <span class="built_in">make</span>([]<span class="keyword">uint16</span>, <span class="number">2</span>*<span class="built_in">len</span>(cases))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> cases &#123;</span><br><span class="line">        rc := &amp;cases[i]</span><br><span class="line">        <span class="keyword">switch</span> rc.dir &#123;</span><br><span class="line">        <span class="keyword">case</span> selectDefault:</span><br><span class="line">            sel[i] = scase&#123;kind: caseDefault&#125;</span><br><span class="line">        <span class="keyword">case</span> selectSend:</span><br><span class="line">            sel[i] = scase&#123;kind: caseSend, c: rc.ch, elem: rc.val&#125;</span><br><span class="line">        <span class="keyword">case</span> selectRecv:</span><br><span class="line">            sel[i] = scase&#123;kind: caseRecv, c: rc.ch, elem: rc.val&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> raceenabled || msanenabled &#123;</span><br><span class="line">            selectsetpc(&amp;sel[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selectgo(&amp;sel[<span class="number">0</span>], &amp;order[<span class="number">0</span>], <span class="built_in">len</span>(cases))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那谁调用的 func rselect([]runtimeSelect) (chosen int, recvOK bool)呢？<br>在/refect/value.go 中，有一个 func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)的函数，其调用了 rselect 函数，并将最终 Go 中 select 语句的返回值的返回。</p><p>以上这三个函数的调用栈按顺序如下：</p><ul><li>func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</li><li>func rselect([]runtimeSelect) (chosen int, recvOK bool)</li><li>func selectgo(cas0 <em>scase, order0 </em>uint16, ncases int) (int, bool)</li></ul><p>这仨函数中无论是返回值还是参数都大同小异，可以简单粗暴的认为：函数参数传入的是 case 语句，返回值返回被选中的 case 语句。<br>那谁调用了 func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)呢？<br>可以简单的认为是系统了。<br>来个简单的图：<br><img src="/blog/assets/golang/select/select-principle_18.png" alt="select-principle_18"></p><p>前两个函数 Select 和 rselect 都是做了简单的初始化参数，调用下一个函数的操作。select 真正的核心功能，是在最后一个函数 func selectgo(cas0 <em>scase, order0 </em>uint16, ncases int) (int, bool)中实现的。</p><h2 id="selectgo-函数做了什么"><a href="#selectgo-函数做了什么" class="headerlink" title="selectgo 函数做了什么"></a>selectgo 函数做了什么</h2><p>打乱传入的 case 结构体顺序<br><img src="/blog/assets/golang/select/select-principle_6.png" alt="select-principle_6"></p><p>锁住其中的所有的 channel<br><img src="/blog/assets/golang/select/select-principle_7.png" alt="select-principle_7"></p><p>遍历所有的 channel，查看其是否可读或者可写<br><img src="/blog/assets/golang/select/select-principle_8.png" alt="select-principle_8"></p><p>如果其中的 channel 可读或者可写，则解锁所有 channel，并返回对应的 channel 数据<br><img src="/blog/assets/golang/select/select-principle_9.png" alt="select-principle_9"><br><img src="/blog/assets/golang/select/select-principle_10.png" alt="select-principle_10"><br>假如没有 channel 可读或者可写，但是有 default 语句，则同上:返回 default 语句对应的 scase 并解锁所有的 channel。<br><img src="/blog/assets/golang/select/select-principle_11.png" alt="select-principle_11"></p><p>假如既没有 channel 可读或者可写，也没有 default 语句，则将当前运行的 groutine 阻塞，并加入到当前所有 channel 的等待队列中去。<br><img src="/blog/assets/golang/select/select-principle_12.png" alt="select-principle_12"><br>然后解锁所有 channel，等待被唤醒。<br><img src="/blog/assets/golang/select/select-principle_13.png" alt="select-principle_13"><br>此时如果有个 channel 可读或者可写 ready 了，则唤醒，并再次加锁所有 channel，<br><img src="/blog/assets/golang/select/select-principle_14.png" alt="select-principle_14"></p><p>遍历所有 channel 找到那个对应的 channel 和 G，唤醒 G，并将没有成功的 G 从所有 channel 的等待队列中移除。<br><img src="/blog/assets/golang/select/select-principle_15.png" alt="select-principle_15"><br>如果对应的 scase 值不为空，则返回需要的值，并解锁所有 channel<br><img src="/blog/assets/golang/select/select-principle_16.png" alt="select-principle_16"><br>如果对应的 scase 为空，则循环此过程。</p><p>select 和 channel 之间的关系<br>在想想 select 和 channel 做了什么事儿，我觉得和多路复用是一回事儿<br><img src="/blog/assets/golang/select/select-principle_17.png" alt="select-principle_17"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Golang&lt;br&gt;Go 的 select 语句是一种仅能用于 channl 发送和接收消息的专用语句，此语句运行期间是阻塞的；当 select 中没有 case 语句的时候，会阻塞当前的 groutine。所以，有人也会说 select 是用来阻塞监听 goroutine 的。&lt;br&gt;还有人说：select 是 Golang 在语言层面提供的 I/O 多路复用的机制，其专门用来检测多个 channel 是否准备完毕：可读或可写。&lt;/p&gt;
&lt;p&gt;以上说法都正确。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="golang" scheme="http://linthan.github.io/blog/tags/golang/"/>
    
      <category term="基础原理" scheme="http://linthan.github.io/blog/tags/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Go语言之defer</title>
    <link href="http://linthan.github.io/blog/2020/07/07/tech/interview/daiery-2020-0707-1600/"/>
    <id>http://linthan.github.io/blog/2020/07/07/tech/interview/daiery-2020-0707-1600/</id>
    <published>2020-07-07T08:40:00.000Z</published>
    <updated>2020-07-07T10:00:45.081Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/8cbe666adeab" target="_blank" rel="noopener">来自</a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>defer 语句被用于预定对一个函数的调用。我们把这类被 defer 语句调用的函数称为延迟函数。</p><a id="more"></a><p><strong>注意，defer 语句只能出现在函数或方法的内部。</strong></p><p>一条 defer 语句总是以关键字 defer 开始。在 defer 的右边还必会有一条表达式语句,且它们之间要以空格” “分隔，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"The finishing touches."</span>)</span><br></pre></td></tr></table></figure><p>这里的表达式语句必须代表一个函数或方法的调用。注意，既然是表达式语句，那么一些调用表达式就是不被允许出现在这里的。比如，针对各种内建函数的那些调用表达式。因为它们不能被称为表达式语句。另外，在这个位置上出现的表达式语句是不能被圆括号括起来的。</p><p><strong>defer 语句的执行时机总是在直接包含它的那个函数把流程控制权交还给它的调用方的前一刻，无论 defer 语句出现在外围函数的函数体中的哪一个位置上。</strong><br>具体分为下面几种情况：</p><ul><li>当外围函数的函数体中的相应语句全部被正常执行完毕的时候，只有在该函数中的所有 defer 语句都被执行完毕之后该函数才会真正地结束执行。</li><li>当外围函数的函数体中的 return 语句被执行的时候，只有在该函数中的所有 defer 语句都被执行完毕之后该函数才会真正地返回。</li><li>当在外围函数中有运行时恐慌发生的时候，只有在该函数中的所有 defer 语句都被执行完毕之后该运行时恐慌才会真正地被扩散至该函数的调用方。</li></ul><p>总之，外围函数的执行的结束会由于其中 defer 语句的执行而被推迟。</p><p>正因为 defer 语句有着这样的特性，所以它成为了执行释放资源或异常处理等收尾任务的首选。</p><h2 id="defer-优势"><a href="#defer-优势" class="headerlink" title="defer 优势"></a>defer 优势</h2><p>使用 defer 语句的优势有两个：</p><ol><li>收尾任务总会被执行，我们不会再因粗心大意而造成资源的浪费；</li><li>我们可以把它们放到外围函数的函数体中的任何地方（一般是函数体开始处或紧跟在申请资源的语句的后面），而不是只能放在函数体的最后。这使得代码逻辑变得更加清晰，并且收尾任务是否被合理的指定也变得一目了然。</li></ol><p>在 defer 语句中，我们调用的函数不但可以是已声明的命名函数，还可以是临时编写的匿名函数，就像这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       fmt.Println(<span class="string">"The finishing touches."</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>注意，一个针对匿名函数的调用表达式是由一个函数字面量和一个代表了调用操作的一对圆括号组成的。<br>我们在这里选择匿名函数的好处是可以使该函数的收尾任务的内容更加直观。不过，我们也可以把比较通用的收尾任务单独放在一个命名函数中，然后再将其添加到需要它的 defer 语句中。无论在 defer 关键字右边的是命名函数还是匿名函数，我们都可以称之为延迟函数。因为它总是会被延迟到外围函数执行结束前一刻才被真正的调用。<br>每当 defer 语句被执行的时候，传递给延迟函数的参数都会以通常的方式被求值。如下例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">begin</span><span class="params">(funcName <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Enter function %s.\n"</span>, funcName)</span><br><span class="line">    <span class="keyword">return</span> funcName</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">end</span><span class="params">(funcName <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Exit function %s.\n"</span>, funcName)</span><br><span class="line">    <span class="keyword">return</span> funcName</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">record</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> end(begin(<span class="string">"record"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"In function record."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>outputs:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　Enter function record.</span><br><span class="line">　In function record.</span><br><span class="line">　Exit function record.</span><br></pre></td></tr></table></figure><p>示例中，调用表达式 begin(“record”)是作为 record 函数的参数出现的。它会在 defer 语句被执行的时候被求值。也就是说，在 record 函数的函数体被执行之处，begin 函数就被调用了。然而，end 函数却是在外围函数 record 执行结束的前一刻被调用的。</p><p>这样做除了可以避免参数值在延迟函数被真正调用之前再次发生改变而给该函数的执行造成影响之外，还是处于同一条 defer 语句可能会被多次执行的考虑。如下例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">defer</span> fmt.Printf(<span class="string">"%d "</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>outputs:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 1 0</span><br></pre></td></tr></table></figure><p>在 for 语句的每次迭代的过程中都会执行一次其中的 defer 语句。在第一次迭代中，针对延迟函数的调用表达式最终会是 fmt.Printf(“%d”, 0)。这是由于在 defer 语句被执行的时候，参数 i 先被求值为了 0，随后这个值被代入到了原来的调用表达式中，并形成了最终的延迟函数调用表达式。显然，这时的调用表达式已经与原来的表达式有所不同了。所以，Go 语言会把代入参数值之后的调用表达式另行存储。以此类推，后面几次迭代所产生的延迟函数调用表达式依次为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%d "</span>, <span class="number">1</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%d "</span>, <span class="number">2</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%d "</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%d "</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="defer-语句执行顺序"><a href="#defer-语句执行顺序" class="headerlink" title="defer 语句执行顺序"></a>defer 语句执行顺序</h2><p>对延迟函数调用表达式的求值顺序是与它们所在的 defer 语句被执行的顺序完全相反的。每当 Go 语言把已代入参数值的延迟函数调用表达式另行存储后，还会把它追加到一个专门为当前外围函数存储延迟函数调用表达式的列表中。而这个列表总是 LIFO(Last In First Out,即后进先出)的。因此，这些延迟函数调用表达式的求值顺序会是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%d "</span>, <span class="number">4</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%d "</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%d "</span>, <span class="number">2</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%d "</span>, <span class="number">1</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%d "</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendNumbers</span><span class="params">(ints []<span class="keyword">int</span>)</span> <span class="params">(result []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    result = <span class="built_in">append</span>(ints, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(result)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">          result = <span class="built_in">append</span>(result, <span class="number">2</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    result = <span class="built_in">append</span>(result, <span class="number">3</span>)</span><br><span class="line">    fmt.Println(result)    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">           result = <span class="built_in">append</span>(result, <span class="number">4</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    result = <span class="built_in">append</span>(result, <span class="number">5</span>)</span><br><span class="line">    fmt.Println(result)    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, <span class="number">6</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>outputs:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　[<span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">       <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">             fmt.Printf(<span class="string">"%d "</span>, i)</span><br><span class="line">       &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>outputs:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　5 5 5 5 5</span><br></pre></td></tr></table></figure><p>在 defer 语句被执行的时候传递给延迟函数的参数都会被求值，但是延迟函数调用表达式并不会在那时被求值。当我们把<br>fmt.Printf(“%d “, i)<br>改为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%d "</span>, i)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>}()<br>之后，虽然变量 i 依然是有效的，但是它所代表的值却已经完全不同了。在 for 语句的迭代过程中，其中 defer 语句被执行了 5 次。但是，由于我们并没有给延迟函数传递任何参数，所以 Go 语言运行时系统也就不需要对任何作为延迟函数的参数值的表达式进行求值（因为它们根本不存在）。在 for 语句被执行完毕的时候，共有 5 个延迟函数调用表达式被存储到了它们的专属列表中。注意，被存储在专属列表中的是 5 个相同的调用表达式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d "</span>, i)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>在 printNumbers 函数的执行即将结束的时候，那个专属列表中的延迟函数调用表达式就会被逆序的取出并被逐个的求值。然而，这时的变量 i 已经被修改为了 5。因此，对 5 个相同的调用表达式的求值都会使标准输出上打印出 5.<br>　　如何修正这个问题呢？<br>　　将 defer 语句修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d "</span>, i)</span><br><span class="line">&#125;(i)</span><br></pre></td></tr></table></figure><p>我们虽然还是以匿名函数作为延迟函数，但是却为这个匿名函数添加了一个参数声明，并在代表调用操作的圆括号中加入了作为参数的变量 i。这样，在 defer 语句被执行的时候，传递给延迟函数的这个参数 i 就会被求值。最终的延迟函数调用表达式也会类似于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%d "</span>, i)</span><br><span class="line">&#125;(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>又因为延迟函数声明中的参数 i 屏蔽了在 for 语句中声明的变量 i，所以在延迟函数被执行的时候，其中那条打印语句中所使用的 i 值即为传递给延迟函数的那个参数值。</p><p>如果延迟函数是一个匿名函数，并且在外围函数的声明中存在命名的结果声明，那么在延迟函数中的代码是可以对命名结果的值进行访问和修改的。如下例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(number <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(number)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">           number += n</span><br><span class="line">    &#125;()</span><br><span class="line">    number++</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>modify(2)，结果为：3</p><p>虽然在延迟函数的声明中可以包含结果声明，但是其返回的结果值会在它被执行完毕时丢弃。因此，作为惯例，我们在编写延迟函数的声明的时候不会为其添加结果声明。另一方面，推荐以传参的方式提供延迟函数所需的外部值。如下例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(number <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(number)</span><br><span class="line">     <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(plus <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">             result = n + plus</span><br><span class="line">             number += result</span><br><span class="line">             <span class="keyword">return</span></span><br><span class="line">    &#125;(<span class="number">3</span>)</span><br><span class="line">    number++</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>modify(2)，结果为：6</p><p>我们可以把想要传递给延迟函数的参数值依照规则放入到那个代表调用操作的圆括号中，就像调用普通函数那样。另一方面，虽然我们在延迟函数的函数体中返回了结果值，但是却不会产生任何效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/8cbe666adeab&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来自&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;defer 语句被用于预定对一个函数的调用。我们把这类被 defer 语句调用的函数称为延迟函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="面试" scheme="http://linthan.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="golang" scheme="http://linthan.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang中的struct能不能比较</title>
    <link href="http://linthan.github.io/blog/2020/07/07/tech/interview/daiery-2020-0707-1538/"/>
    <id>http://linthan.github.io/blog/2020/07/07/tech/interview/daiery-2020-0707-1538/</id>
    <published>2020-07-07T07:38:00.000Z</published>
    <updated>2020-07-07T07:51:47.896Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/d84a2a067cef" target="_blank" rel="noopener">来自</a></p><a id="more"></a><h2 id="同一个-struct-的-2-个实例能不能比较"><a href="#同一个-struct-的-2-个实例能不能比较" class="headerlink" title="同一个 struct 的 2 个实例能不能比较"></a>同一个 struct 的 2 个实例能不能比较</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Age   <span class="keyword">int</span></span><br><span class="line">    Arr   [<span class="number">2</span>]<span class="keyword">bool</span></span><br><span class="line">    ptr   *<span class="keyword">int</span></span><br><span class="line">    slice []<span class="keyword">int</span></span><br><span class="line">    map1  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t1 := T1&#123;</span><br><span class="line">        Name:  <span class="string">"yxc"</span>,</span><br><span class="line">        Age:   <span class="number">1</span>,</span><br><span class="line">        Arr:   [<span class="number">2</span>]<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">        ptr:   <span class="built_in">new</span>(<span class="keyword">int</span>),</span><br><span class="line">        slice: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        map1:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    t2 := T1&#123;</span><br><span class="line">        Name:  <span class="string">"yxc"</span>,</span><br><span class="line">        Age:   <span class="number">1</span>,</span><br><span class="line">        Arr:   [<span class="number">2</span>]<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">        ptr:   <span class="built_in">new</span>(<span class="keyword">int</span>),</span><br><span class="line">        slice: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        map1:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错 实例不能比较 Invalid operation: t1 == t2 (operator == not defined on T1)</span></span><br><span class="line">    <span class="comment">// fmt.Println(t1 == t2)</span></span><br><span class="line">    <span class="comment">// 指针可以比较</span></span><br><span class="line">    fmt.Println(&amp;t1 == &amp;t2) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    t3 := &amp;T1&#123;</span><br><span class="line">        Name:  <span class="string">"yxc"</span>,</span><br><span class="line">        Age:   <span class="number">1</span>,</span><br><span class="line">        Arr:   [<span class="number">2</span>]<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">        ptr:   <span class="built_in">new</span>(<span class="keyword">int</span>),</span><br><span class="line">        slice: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        map1:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t4 := &amp;T1&#123;</span><br><span class="line">        Name:  <span class="string">"yxc"</span>,</span><br><span class="line">        Age:   <span class="number">1</span>,</span><br><span class="line">        Arr:   [<span class="number">2</span>]<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">        ptr:   <span class="built_in">new</span>(<span class="keyword">int</span>),</span><br><span class="line">        slice: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        map1:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(t3 == t4)                  <span class="comment">// false</span></span><br><span class="line">    fmt.Println(reflect.DeepEqual(t3, t4)) <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p, %p \n"</span>, t3, t4)        <span class="comment">// 0xc000046050, 0xc0000460a0</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p, %p \n"</span>, &amp;t3, &amp;t4)      <span class="comment">// 0xc000006030, 0xc000006038</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前面加*，表示指针指向的值，即结构体实例，不能用==</span></span><br><span class="line">    <span class="comment">// Invalid operation: *t3 == *t4 (operator == not defined on T1)</span></span><br><span class="line">    <span class="comment">// fmt.Println(*t3 == *t4)</span></span><br><span class="line"></span><br><span class="line">    t5 := t3</span><br><span class="line">    fmt.Println(t3 == t5)                  <span class="comment">// true</span></span><br><span class="line">    fmt.Println(reflect.DeepEqual(t3, t5)) <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p, %p \n"</span>, t3, t5)        <span class="comment">// 0xc000046050, 0xc000046050</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p, %p \n"</span>, &amp;t3, &amp;t5)      <span class="comment">// 0xc000006030, 0xc000006040</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>t1, t2 是同一个 struct 两个赋值相同的实例，因为成员变量带有了不能比较的成员，所以只要写 == 就报错</li><li>t3 t4 虽然能用 == ，但是本质上是比较的指针类型，<em>t3 == </em>t4 一样的一写就报错</li></ul><h2 id="两个不同的-struct-的实例能不能比较"><a href="#两个不同的-struct-的实例能不能比较" class="headerlink" title="两个不同的 struct 的实例能不能比较"></a>两个不同的 struct 的实例能不能比较</h2><p>可以能，也可以不能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Age   <span class="keyword">int</span></span><br><span class="line">    Arr   [<span class="number">2</span>]<span class="keyword">bool</span></span><br><span class="line">    ptr   *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T3 <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Age   <span class="keyword">int</span></span><br><span class="line">    Arr   [<span class="number">2</span>]<span class="keyword">bool</span></span><br><span class="line">    ptr   *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ss1 T2</span><br><span class="line">    <span class="keyword">var</span> ss2 T3</span><br><span class="line">    <span class="comment">// Cannot use 'ss2' (type T3) as type T2 in assignment</span></span><br><span class="line">    <span class="comment">//ss1 = ss2</span></span><br><span class="line">    ss3 := T2(ss2)</span><br><span class="line">    fmt.Println(ss3==ss1) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T2 和 T3 是不同的结构体，但可以强制转换，所以强转之后可以比较</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Age   <span class="keyword">int</span></span><br><span class="line">    Arr   [<span class="number">2</span>]<span class="keyword">bool</span></span><br><span class="line">    ptr   *<span class="keyword">int</span></span><br><span class="line">    map1  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T3 <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Age   <span class="keyword">int</span></span><br><span class="line">    Arr   [<span class="number">2</span>]<span class="keyword">bool</span></span><br><span class="line">    ptr   *<span class="keyword">int</span></span><br><span class="line">    map1  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ss1 T2</span><br><span class="line">    <span class="keyword">var</span> ss2 T3</span><br><span class="line">    <span class="comment">// Cannot use 'ss2' (type T3) as type T2 in assignment</span></span><br><span class="line">    <span class="comment">//ss1 = ss2</span></span><br><span class="line">    ss3 := T2(ss2)</span><br><span class="line">    <span class="comment">// Invalid operation: ss3==ss1 (operator == not defined on T2)</span></span><br><span class="line">    <span class="comment">// fmt.Println(ss3==ss1)   含有不可比较成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成员变量含有不可比较成员变量，即使可以强制转换，也不可以比较</p><h2 id="可排序、可比较和不可比较"><a href="#可排序、可比较和不可比较" class="headerlink" title="可排序、可比较和不可比较"></a>可排序、可比较和不可比较</h2><ul><li>可排序的数据类型有三种，Integer，Floating-point，和 String</li><li>可比较的数据类型除了上述三种外，还有 Boolean，Complex，Pointer，Channel，Interface 和 Array</li><li>不可比较的数据类型包括，Slice, Map, 和 Function</li></ul><h2 id="struct-可以作为-map-的-key-么？"><a href="#struct-可以作为-map-的-key-么？" class="headerlink" title="struct 可以作为 map 的 key 么？"></a>struct 可以作为 map 的 key 么？</h2><p>可以，也不可以</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Age   <span class="keyword">int</span></span><br><span class="line">    Arr   [<span class="number">2</span>]<span class="keyword">bool</span></span><br><span class="line">    ptr   *<span class="keyword">int</span></span><br><span class="line">    slice []<span class="keyword">int</span></span><br><span class="line">    map1  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Age   <span class="keyword">int</span></span><br><span class="line">    Arr   [<span class="number">2</span>]<span class="keyword">bool</span></span><br><span class="line">    ptr   *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">make</span>(<span class="keyword">map</span>[T2]<span class="keyword">string</span>, <span class="number">0</span>)   <span class="comment">// 无报错</span></span><br><span class="line">    fmt.Print(n)   <span class="comment">// map[]</span></span><br><span class="line">    <span class="comment">// lnvalid map key type: the comparison operators == and != must be fully defined for key type</span></span><br><span class="line">    <span class="comment">// m := make(map[T1]string, 0)</span></span><br><span class="line">    <span class="comment">// fmt.Println(m)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>struct 必须是可比较的，才能作为 key，否则编译时报错</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/d84a2a067cef&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来自&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="面试" scheme="http://linthan.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="golang" scheme="http://linthan.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>2020 腾讯社招Golang后端面试经验分享</title>
    <link href="http://linthan.github.io/blog/2020/07/07/tech/interview/daiery-2020-0707-1536/"/>
    <id>http://linthan.github.io/blog/2020/07/07/tech/interview/daiery-2020-0707-1536/</id>
    <published>2020-07-07T07:19:00.000Z</published>
    <updated>2020-07-16T14:10:56.281Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/4485c31b4ab5" target="_blank" rel="noopener">来自</a></p><a id="more"></a><h2 id="技术一面-基础面试"><a href="#技术一面-基础面试" class="headerlink" title="技术一面 基础面试"></a>技术一面 基础面试</h2><p>一面是通过电话直接沟通</p><ul><li>go 的调度。<a href="/blog/2020/05/01/tech/golang/daiery-2020-0501-1200/">Go 并发原理</a></li><li><a href="/blog/2020/07/07/tech/interview/daiery-2020-0707-1538/">go struct 能不能比较</a></li><li><a href="/blog/2020/07/07/tech/interview/daiery-2020-0707-1600/">go defer（for defer）</a></li><li>select 可以用于什么。 <a href="/blog/2020/07/10/tech/golang/daiery-2020-0710-0801/">图解 go select</a></li><li><a href="/blog/2020/07/15/tech/algorithm/daiery-2020-07-15-2200/">基本排序，哪些是稳定的</a></li><li><a href="/blog/2020/07/30/tech/interview/daiery-2020-0715-2300/">http head get</a></li><li>tcp 与 udp 区别，udp 优点，适用场景</li><li><a href="/blog/2020/07/16/tech/database/daiery-2020-0716-0830/">数据库如何建索引</a></li><li><a href="/blog/2020/07/16/tech/interview/daiery-2020-0716-2000/">http 常见的状态码，400,401,403 状态码分别代表什么？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/4485c31b4ab5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来自&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="面试" scheme="http://linthan.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="golang" scheme="http://linthan.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>图解各路分布式ID生成算法</title>
    <link href="http://linthan.github.io/blog/2020/07/06/tech/algorithm/daiery-2020-07-06-1331/"/>
    <id>http://linthan.github.io/blog/2020/07/06/tech/algorithm/daiery-2020-07-06-1331/</id>
    <published>2020-07-06T05:31:00.000Z</published>
    <updated>2020-07-06T05:56:35.150Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，通常会用到分布式 ID 来标注数据的唯一性，而分布式 ID 的生成方式又多种多样，今天我们就来讨论一下主流的分布式 ID 生成策略。</p><a id="more"></a><h2 id="分布式-ID-基本需求"><a href="#分布式-ID-基本需求" class="headerlink" title="分布式 ID 基本需求"></a>分布式 ID 基本需求</h2><ul><li>全局唯一</li><li>趋势递增</li><li>信息安全</li></ul><h3 id="全局唯一"><a href="#全局唯一" class="headerlink" title="全局唯一"></a>全局唯一</h3><p>这是基本要求，不必解释</p><h3 id="趋势递增"><a href="#趋势递增" class="headerlink" title="趋势递增"></a>趋势递增</h3><p>为什么要趋势递增呢？<br>第一，由于我们的分布式 ID，是用来标识数据唯一性的，所以多数时候会被定义为主键或者唯一索引。<br>第二，并且绝大多数互联网公司使用的数据库是：MySQL，存储引擎为 innoDB。<br>对于 B + Tree 这个数据结构来讲，数据以自增顺序来写入的话，b+tree 的结构不会时常被打乱重塑，存取效率是最高的。</p><h3 id="信息安全"><a href="#信息安全" class="headerlink" title="信息安全"></a>信息安全</h3><p>由于数据是递增的，所以，恶意用户的可以根据当前 ID 推测出下一个，非常危险，所以，我们的分布式 ID 尽量做到不易被破解。</p><h2 id="数据库主键自增-Flicker"><a href="#数据库主键自增-Flicker" class="headerlink" title="数据库主键自增(Flicker)"></a>数据库主键自增(Flicker)</h2><p>基于数据库主键自增的方案，名为 Flicker。<br>主要是利用 MySQL 的自增主键来实现分布式 ID。</p><p>以下为 Flicker 实现分布式 ID 的主流做法：</p><h3 id="1、需要单独建立一个数据库实例：flicker"><a href="#1、需要单独建立一个数据库实例：flicker" class="headerlink" title="1、需要单独建立一个数据库实例：flicker"></a>1、需要单独建立一个数据库实例：flicker</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="string">`flicker`</span>;</span><br></pre></td></tr></table></figure><p>2、创建一张表：sequence_id</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sequence_id(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">    stub <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">''</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> stub (stub)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM;</span><br></pre></td></tr></table></figure><p>为什么用 MyISAM？不用 InnoDB？个人推测原因是：flicker 算法出来的时候，MySQL 的默认引擎还依旧是 MyISAM 而不是 InnoDB，作者只是想用默认引擎而已，并无其他原因。</p><p>3、使用以下 SQL 来获取 ID</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REPLACE</span> <span class="keyword">INTO</span> ticket_center (stub) <span class="keyword">VALUES</span> (<span class="string">'test'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LAST_INSERT_ID</span>();</span><br></pre></td></tr></table></figure><p>Replace into 先尝试插入数据到表中，如果发现表中已经有此行数据（根据主键或者唯一索引判断）则先删除此行数据，然后插入新的数据， 否则直接插入新数据。<br>一般 stub 为特殊的相同的值。</p><p>这样，一个分布式 ID 系统算是可以搭建运行了。但是，有人要问：“这是一个单实例、单点的系统，万一挂了，岂不是影响所有关联的业务方？”</p><h3 id="改进升华"><a href="#改进升华" class="headerlink" title="改进升华"></a>改进升华</h3><p>是的。确实如此，因此又有人说：“可以利用 MySQL 主从模式，主库挂了，使用从库。”<br>这只能算是一种比较 low 的策略，因为如果主库挂了，从库没来得及同步，就会生成重复的 ID。<br>有没有更好的方法呢？<br>我们可以使用“双主模式“，也就是有两个 MySQL 实例，这两个都能生成 ID。<br>如图所示，我们原来的模式：<br><img src="/blog/assets/algorithm/mysql1.png" alt="mysql1"></p><h3 id="奇数那一台："><a href="#奇数那一台：" class="headerlink" title="奇数那一台："></a>奇数那一台：</h3><p>set @@auto_increment_offset = 1; – 起始值<br>set @@auto_increment_increment = 2; – 步长</p><h3 id="偶数那一台："><a href="#偶数那一台：" class="headerlink" title="偶数那一台："></a>偶数那一台：</h3><p>set @@auto_increment_offset = 2; – 起始值<br>set @@auto_increment_increment = 2; – 步长</p><p>当两台都 OK 的时候，随机取其中的一台生成 ID；若其中一台挂了，则取另外一台生成 ID。<br>如图所示：<br><img src="/blog/assets/algorithm/mysql2.png" alt="mysql2"></p><p>细心会发现，N 个节点，只要起始值为 1，2，…N，然后步长为 N，就会生成各不相同的 ID。(PS:后文有推导公式)</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优点：</p><ul><li>简单。充分利用了数据库自增 ID 机制，生成的 ID 有序递增。</li><li><p>ID 递增<br>缺点：</p></li><li><p>并发量不大。</p></li><li>水平扩展困难，系统定义好了起始值、步长和机器台数，跑起来之后，添加额外的机器困难。</li><li>安全系数低</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis 为单线程的，所以操作为原子操作，利用 incrby 命令可以生成唯一的递增 ID。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="/blog/assets/algorithm/redis1.png" alt="redis1"><br>单机单点，吞吐不够，加集群<br><img src="/blog/assets/algorithm/redis2.png" alt="redis2"><br>假设 N 个节点，则步长为 N，节点起始值为 1，2，…… N。则三个节点生成的 ID 一定不同！<br>想想为什么？<br>以上信息条件可以转化为数学推理：<br>1 + x _ N = 2 + y _ N 且 x、y、N 都为整成数且 N 不为 1，试问等式存不存在？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">假设存在在起始值是1的节点上叠加x次之后等于起始值为2、叠加y次的值，</span><br><span class="line">既 “1 + x * N = 2 + y * N” 等式成立</span><br><span class="line">则：</span><br><span class="line">x * N = 1 + y * N</span><br><span class="line">x * N - y * N = 1</span><br><span class="line">(x - y) * N = 1</span><br><span class="line">(x - y) = 1 / N</span><br><span class="line"></span><br><span class="line">又因为 x、y都为整成数；</span><br><span class="line">所以x - y 必为整成数；</span><br><span class="line">又因为只有N等于1的时候，1/N才为整成数；</span><br><span class="line">与条件N为1不符合，所以不存在。</span><br></pre></td></tr></table></figure><p>优点</p><ul><li>性能显然高于基于数据库的 Flicker 方案</li><li>ID 递增<br>缺点</li><li>水平扩展困难</li><li>Redis 集群宕机可能会产生重复的 id</li><li>易破解</li></ul><h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>想必这个大家都熟悉。<br>UUID 是通用唯一识别码（Universally Unique Identifier）的缩写，是一种软件建构的标准，亦为开放软件基金会组织在分布式计算环境领域的一部分。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><img src="/blog/assets/algorithm/uuid1.png" alt="uuid1"></p><p>UUID 是由一组 32 位数的 16 进制数字所构成，是故 UUID 理论上的总数为 16^32 = 2^128，约等于 3.4 x 10^38。也就是说若每纳秒产生 1 兆个 UUID，要花 100 亿年才会将所有 UUID 用完。</p><p>UUID 是利用同一时空中的所有机器都是唯一的这一规则来确保唯一性的。<br><img src="/blog/assets/algorithm/uuid3.png" alt="uuid3"></p><p>具体外形为：</p><p><img src="/blog/assets/algorithm/uuid2.png" alt="uuid2"></p><p>通常由以下几部分组成：</p><p>系统时间</p><ul><li>时钟序列</li><li>全局唯一的 IEEE 机器识别，如网卡 MAC、机器 SN 等</li><li>生成方式多种多样，业界公认的是五种，分别是 uuid1,uuid2,uuid3,uuid4,uuid5。<br>目前使用最广泛的 UUID 是微软的 GUID。</li></ul><p>优点</p><ul><li>本地生成，性能极佳。无网络消耗</li><li>全局唯一<br>缺点</li><li>存储麻烦。16 字节 128 位，通常以 36 长度的字符串表示，很多场景不适用</li><li>通常是字符串，非自增，无序，不利于做主键。每次插入都会对 B+tree 结构进行修改</li><li>破解相对困难，但是也不安全。参考”梅丽莎病毒事件，病毒作者制作的 UUID 包含 Mac 地址，被警方破解后，直接定位，抓捕归案 😝”</li></ul><h2 id="snowflake"><a href="#snowflake" class="headerlink" title="snowflake"></a>snowflake</h2><p>snowflake 即雪花算法，Twitter 发明的。</p><h3 id="外形长这样："><a href="#外形长这样：" class="headerlink" title="外形长这样："></a>外形长这样：</h3><p><img src="/blog/assets/algorithm/snowflake.jpeg" alt="snowflake"></p><ul><li>41 位，用来记录毫秒的时间戳。41 位可以表示的数值范围是：0 至 2^{41}-1，减 1 是因为可表示的数值范围是从 0 开始算的，而不是 1，转化为年则是 2^{41}-1) / (1000 _ 60 _ 60 _ 24 _ 365) = 69 年。</li><li>10 位，用来记录工作机器 id。最多可以部署在 2^{10} = 1024 个节点，我们可以根据具体的业务来定制具体分配的机器数量和每台机器 1 毫秒产生的 id 序号- number 数。例如可以把 10bit 分 5bit 给 IDC，分 5bit 给工作机器。这样就可以表示 32 个 IDC，每个 IDC 下可以有 32 台机器，可以将内容配置在配置文件中，服务去获取。</li><li>12 位。用来表示单台机器每毫秒生成的 id 序号，12 位 bit 可以表示的最大正整数为 2^12 - 1 = 4096，若超过 4096，则重新从 0 开始。即，每台机器 1 毫秒内最多产生 4096 个 ID，足够用了。</li></ul><p>最后将上述 4 段 bit 通过位运算拼接起来组成 64 位 bit.<br>由于是 64 位 bit,所以完全可以用数字来表示 ID。</p><p>基本是根据：</p><p><img src="/blog/assets/algorithm/snowflake1.png" alt="snowflake1"></p><p>优点</p><ul><li>ID 为数字且时间位在高位，整个 ID 都是趋势递增的。</li><li>不依赖任何第三方库，完全可以自己写，且性能非常高。</li><li>可根据业务定制分配 bit 位，非常灵活。得益于 10 位机器 IDbit 位。</li><li>不太容易破解<br>缺点</li><li>依赖机器</li></ul><p>总结<br>在国内也得到了比较普遍的应用，各大厂根据其基本原理，生成了自己的规则：</p><ul><li>百度的 uid-generator：<a href="https://github.com/baidu/uid-generator" target="_blank" rel="noopener">https://github.com/baidu/uid-generator</a></li><li>美团 Leaf：<a href="https://github.com/zhuzhong/idleaf" target="_blank" rel="noopener">https://github.com/zhuzhong/idleaf</a></li></ul><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p>[flicker 算法原文] <a href="http://code.flickr.com/blog/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">http://code.flickr.com/blog/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/</a></p><p>[分布式唯一 ID 极简教程] <a href="https://mp.weixin.qq.com/s/cqIK5Bv1U0mT97C7EOxmnA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/cqIK5Bv1U0mT97C7EOxmnA</a></p><p>[分布式 ID 生成策略] <a href="https://mp.weixin.qq.com/s/UAvSUDFJ8Fr0a-Na2Vr22g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/UAvSUDFJ8Fr0a-Na2Vr22g</a></p><p>[分布式 ID 系列（2）——UUID 适合做分布式 ID 吗] <a href="https://mp.weixin.qq.com/s/kZAnYz_Jj4aBrtsk8Q9w_A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/kZAnYz_Jj4aBrtsk8Q9w_A</a></p><p><a href="https://segmentfault.com/a/1190000011282426" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011282426</a></p><p><a href="https://juejin.im/post/5d6fc8eff265da03ef7a324b#comment" target="_blank" rel="noopener">https://juejin.im/post/5d6fc8eff265da03ef7a324b#comment</a></p><p><a href="https://segmentfault.com/a/1190000010978305" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010978305</a></p><p>[Leaf——美团点评分布式 ID 生成系统] <a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/04/21/mt-leaf.html</a></p><p>[UUID 的含义及实现原理]<a href="https://blog.csdn.net/reggergdsg/article/details/92091404" target="_blank" rel="noopener">https://blog.csdn.net/reggergdsg/article/details/92091404</a></p><p>[通用唯一标识码 UUID 的介绍及使用] <a href="https://mp.weixin.qq.com/s/BjCL076USuhLj9GjhXDaTA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/BjCL076USuhLj9GjhXDaTA</a><br>[UUID 简史] <a href="https://www.infoq.cn/article/talk-about-the-history-of-uuid/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">https://www.infoq.cn/article/talk-about-the-history-of-uuid/?utm_source=tuicool&amp;utm_medium=referral</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在分布式系统中，通常会用到分布式 ID 来标注数据的唯一性，而分布式 ID 的生成方式又多种多样，今天我们就来讨论一下主流的分布式 ID 生成策略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="算法" scheme="http://linthan.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="面试" scheme="http://linthan.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Golang 垃圾回收剖析</title>
    <link href="http://linthan.github.io/blog/2020/07/06/tech/golang/daiery-2020-0706-1300/"/>
    <id>http://linthan.github.io/blog/2020/07/06/tech/golang/daiery-2020-0706-1300/</id>
    <published>2020-07-06T05:00:00.000Z</published>
    <updated>2020-07-06T05:26:04.998Z</updated>
    
    <content type="html"><![CDATA[<p>Golang 从第一个版本以来，GC 一直是大家诟病最多的。但是每一个版本的发布基本都伴随着 GC 的改进。下面列出一些比较重要的改动。</p><p>以下是 Golang GC 算法的里程碑：</p><ul><li>v1.1 STW</li><li>v1.3 Mark STW, Sweep 并行</li><li>v1.5 三色标记法</li><li>v1.8 hybrid write barrier<a id="more"></a></li></ul><h2 id="GC-算法简介"><a href="#GC-算法简介" class="headerlink" title="GC 算法简介"></a>GC 算法简介</h2><p>这一小节介绍三种经典的 GC 算法：引用计数（reference counting）、标记-清扫（mark &amp; sweep）、节点复制（Copying Garbage Collection），分代收集（Generational Garbage Collection）。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数的思想非常简单：每个单元维护一个域，保存其它单元指向它的引用数量（类似有向图的入度）。当引用数量为 0 时，将其回收。引用计数是渐进式的，能够将内存管理的开销分布到整个程序之中。C++ 的 share_ptr 使用的就是引用计算方法。</p><p>引用计数算法实现一般是把所有的单元放在一个单元池里，比如类似 free list。这样所有的单元就被串起来了，就可以进行引用计数了。新分配的单元计数值被设置为 1（注意不是 0，因为申请一般都说 ptr = new object 这种）。每次有一个指针被设为指向该单元时，该单元的计数值加 1；而每次删除某个指向它的指针时，它的计数值减 1。当其引用计数为 0 的时候，该单元会被进行回收。虽然这里说的比较简单，实现的时候还是有很多细节需要考虑，比如删除某个单元的时候，那么它指向的所有单元都需要对引用计数减 1。那么如果这个时候，发现其中某个指向的单元的引用计数又为 0，那么是递归的进行还是采用其他的策略呢？递归处理的话会导致系统颠簸。关于这些细节这里就不讨论了，可以参考文章后面的给的参考资料。</p><p>优点</p><ol><li><p>渐进式。内存管理与用户程序的执行交织在一起，将 GC 的代价分散到整个程序。不像标记-清扫算法需要 STW (Stop The World，GC 的时候挂起用户程序)。</p></li><li><p>算法易于实现。</p></li><li><p>内存单元能够很快被回收。相比于其他垃圾回收算法，堆被耗尽或者达到某个阈值才会进行垃圾回收。</p></li></ol><p>缺点</p><ol><li><p>原始的引用计数不能处理循环引用。大概这是被诟病最多的缺点了。不过针对这个问题，也除了很多解决方案，比如强引用等。</p></li><li><p>维护引用计数降低运行效率。内存单元的更新删除等都需要维护相关的内存单元的引用计数，相比于一些追踪式的垃圾回收算法并不需要这些代价。</p></li><li><p>单元池 free list 实现的话不是 cache-friendly 的，这样会导致频繁的 cache miss，降低程序运行效率。</p></li></ol><h3 id="标记-清扫"><a href="#标记-清扫" class="headerlink" title="标记-清扫"></a>标记-清扫</h3><p>标记-清扫算法是第一种自动内存管理，基于追踪的垃圾收集算法。算法思想在 70 年代就提出了，是一种非常古老的算法。内存单元并不会在变成垃圾立刻回收，而是保持不可达状态，直到到达某个阈值或者固定时间长度。这个时候系统会挂起用户程序，也就是 STW，转而执行垃圾回收程序。垃圾回收程序对所有的存活单元进行一次全局遍历确定哪些单元可以回收。算法分两个部分：标记（mark）和清扫（sweep）。标记阶段表明所有的存活单元，清扫阶段将垃圾单元回收。可视化可以参考下图。<br><img src="/blog/assets/golang/gc/640.webp" alt="640"></p><p>标记-清扫算法的优点也就是基于追踪的垃圾回收算法具有的优点：避免了引用计数算法的缺点（不能处理循环引用，需要维护指针）。缺点也很明显，需要 STW。</p><h3 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h3><p>三色标记算法是对标记阶段的改进，原理如下：</p><ol><li><p>起初所有对象都是白色。</p></li><li><p>从根出发扫描所有可达对象，标记为灰色，放入待处理队列。</p></li><li><p>从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。</p></li><li><p>重复 3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。<br>可视化如下。<br><img src="/blog/assets/golang/gc/641.webp" alt="641"></p></li></ol><p>三色标记的一个明显好处是能够让用户程序和 mark 并发的进行，具体可以参考论文：《On-the-fly garbage collection: an exercise in cooperation.》。Golang 的 GC 实现也是基于这篇论文，后面再具体说明。</p><h3 id="节点复制"><a href="#节点复制" class="headerlink" title="节点复制"></a>节点复制</h3><p>节点复制也是基于追踪的算法。其将整个堆等分为两个半区（semi-space），一个包含现有数据，另一个包含已被废弃的数据。节点复制式垃圾收集从切换（flip）两个半区的角色开始，然后收集器在老的半区，也就是 Fromspace 中遍历存活的数据结构，在第一次访问某个单元时把它复制到新半区，也就是 Tospace 中去。在 Fromspace 中所有存活单元都被访问过之后，收集器在 Tospace 中建立一个存活数据结构的副本，用户程序可以重新开始运行了。</p><p>优点<br>所有存活的数据结构都缩并地排列在 Tospace 的底部，这样就不会存在内存碎片的问题。<br>获取新内存可以简单地通过递增自由空间指针来实现。</p><p>缺点<br>内存得不到充分利用，总有一半的内存空间处于浪费状态。</p><h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><p>基于追踪的垃圾回收算法（标记-清扫、节点复制）一个主要问题是在生命周期较长的对象上浪费时间（长生命周期的对象是不需要频繁扫描的）。同时，内存分配存在这么一个事实 “most object die young”。基于这两点，分代垃圾回收算法将对象按生命周期长短存放到堆上的两个（或者更多）区域，这些区域就是分代（generation）。对于新生代的区域的垃圾回收频率要明显高于老年代区域。</p><p>分配对象的时候从新生代里面分配，如果后面发现对象的生命周期较长，则将其移到老年代，这个过程叫做 promote。随着不断 promote，最后新生代的大小在整个堆的占用比例不会特别大。收集的时候集中主要精力在新生代就会相对来说效率更高，STW 时间也会更短。</p><h2 id="Golang-的-GC"><a href="#Golang-的-GC" class="headerlink" title="Golang 的 GC"></a>Golang 的 GC</h2><h3 id="三⾊标记"><a href="#三⾊标记" class="headerlink" title="三⾊标记"></a>三⾊标记</h3><p>⾸先当垃圾回收器第⼀次启动的时候，它把所有的对象都看成⽩⾊的，如果这个对象引⽤了另外⼀个对象，那么被引⽤的对象称之为灰⾊的，把灰⾊的放⼊⼀个队列⾥去，那么当它第⼀次扫描完了以后这个⽆⾮就是变成两种状态，⽩⾊的和灰⾊的，⽩⾊的不属于我们要管的。</p><p>接下来扫描所有灰⾊的对象，灰⾊对象从队列⾥拿出来进⾏扫描，灰⾊对象被拿出来以后灰⾊对象本⾝被标记为⿊⾊的。如果它引⽤了其他对象那么这个对象重新变成灰⾊的，它会放⼊队列⾥⾯去，那么⿊⾊对象肯定是活着的不⽤管了，那么通过这样⼀级⼀级的扫描最终因为灰⾊对象被放⼊队列⾥⾯然后灰⾊对象拿出来进⾏扫描，灰⾊对象本⾝变成⿊⾊的，最终⾥就变成两种对象，⼀种是活下来⿊⾊的，第⼆种是所有扫描都没有⼈碰过的⽩⾊，那么⿊⾊的都是活着的，⽩⾊的都是统统干掉的。</p><p>那么最早的扫描是从哪来的呢，我们称之为从根 Root 对象来的，⽣命周期可以保证的对象是根对象，线程栈本⾝就是⼀个根，线程栈⾥⾯可能存了某个对象的指针，那线程栈就会引⽤那个对象，所以像全局变量、线程栈这些就是根对象。从它们开始扫描，如果全局变量没有引⽤任何东⻄，线程栈也没有引⽤任何东⻄，那这些根对象引⽤的对象肯定可以干掉。全局变量就不说了，线程栈就表⽰了当前正在引⽤的那对象，如果线程栈都没有引⽤过，那些对象肯定不要了，⽩⾊对象可以去掉了。</p><p>从根对象开始扫描从⼀开始⼤家都是⽩的，如果根对象有引⽤，那个对象变成灰⾊的，灰⾊对象依次扫描以后就剩下变成两种对象，⽩⾊对象和灰⾊对象，⽩⾊对象先放在这，灰⾊对象放⼊队列⾥⾯去，接下来我们从队列⾥把灰⾊对象取出来，看看灰⾊对象引⽤了什么对象，灰⾊对象本⾝变成⿊⾊的它肯定活下来的，因为它是被别⼈引⽤了才会放⼊队列⾥⾯，所以它从灰⾊变成⿊⾊肯定是活下来的。通过这样把灰⾊对象⼀级⼀级进⾏递归扫描以后最后这个队列被清空了，剩下来的世界只有两种对象，⼀种是⿊⾊的肯定被引⽤过，第⼆种是没有被引⽤过的⽩⾊对象，⿊⽩两⾊，⿊⾊活着⽩⾊干掉，这就是很典型的三⾊标记</p><h3 id="golang-垃圾回收使用的标记清理"><a href="#golang-垃圾回收使用的标记清理" class="headerlink" title="golang 垃圾回收使用的标记清理"></a>golang 垃圾回收使用的标记清理</h3><p>STW(stop the world）<br>在扫描之前执⾏ STW（Stop The World）操作，就是 Runtime 把所有的线程全部冻结掉，所有的线程全部冻结掉意味着⽤户逻辑肯定都是暂停的，所有的⽤户对象都不会被修改了，这时候去扫描肯定是安全的，对象要么活着要么死着，所以会造成在 STW 操作时所有的线程全部暂停，⽤户逻辑全部停掉，中间暂停时间可能会很⻓，⽤户逻辑对于⽤户的反应就中⽌了。</p><p>如何减短这个过程呢， STW 过程中有两部分逻辑可以分开处理。我们看⿊⽩对象，扫描完结束以后对象只有⿊⽩对象，⿊⾊对象是接下来程序恢复之后需要使⽤的对象，如果不碰⿊⾊对象只回收⽩⾊对象的话肯定不会给⽤户逻辑产⽣关联，因为⽩⾊对象肯定不会被⽤户线程引⽤的，所以回收操作实际上可以和⽤户逻辑并发的，因为可以保证回收的所有目标都不会被⽤户线程使⽤，所以第⼀步回收操作和⽤户逻辑可以并发，因为我们回收的是⽩⾊对象，扫描完以后⽩⾊对象不会被全局变量引⽤、线程栈引⽤。回收⽩⾊对象肯定不会对⽤户线程产⽣竞争，⾸先回收操作肯定可以并发的，既然可以和⽤户逻辑并发，这样回收操作不放在 STW 时间段⾥⾯缩短 STW 时间。</p><p>写屏障<br>写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。</p><p>刚把⼀个对象标记为⽩⾊的，⽤户逻辑执⾏了突然引⽤了它，或者说刚刚扫描了 100 个对象正准备回收结果⼜创建了 1000 个对象在⾥⾯，因为没法结束没办法扫描状态不稳定，像扫描操作就⽐较⿇烦。于是引⼊了写屏障的技术。</p><p>，先做⼀次很短暂的 STW，为什么需要很短暂的呢，它⾸先要执⾏⼀些简单的状态处理，接下来对内存进⾏扫描，这个时候⽤户逻辑也可以执⾏。⽤户所有新建的对象认为就是⿊⾊的，这次不扫描了下次再说，新建对象不关⼼了，剩下来处理已经扫描过的对象是不是可能会出问题，已经扫描后的对象可能因为⽤户逻辑造成对象状态发⽣改变，所以对扫描过后的对象使⽤操作系统写屏障功能⽤来监控⽤户逻辑这段内存。任何时候这段内存发⽣引⽤改变的时候就会造成写屏障发⽣⼀个信号，垃圾回收器会捕获到这样的信号后就知道这个对象发⽣改变，然后重新扫描这个对象，看看它的引⽤或者被引⽤是否被改变，这样利⽤状态的重置从⽽实现当对象状态发⽣改变的时候依然可以判断它是活着的还是死的，这样扫描操作实际上可以做到⼀定程度上的并发，因为它没有办法完全屏蔽 STW 起码它当开始启动先拿到⼀个状态，但是它的确可以把扫描时间缩短，现在知道了扫描操作和回收操作都可以⽤户并发。</p><h3 id="golang-回收的本质"><a href="#golang-回收的本质" class="headerlink" title="golang 回收的本质"></a>golang 回收的本质</h3><p>实际上把单次暂停时间分散掉了，本来程序执⾏可能是“⽤户逻辑、⼤段 GC、⽤户逻辑”，那么分散以后实际上变成了“⽤户逻辑、⼩段 GC、⽤户逻辑、⼩段 GC、⽤户逻辑”这样。其实这个很难说 GC 快了。因为被分散各个地⽅以后可能会频繁的保存⽤户状态，因为垃圾回收之前要保证⽤户状态是稳定的，原来只需要保存⼀次就可以了现在需要保存多次，很难说这种⽅式就⼀定让程序变的快了</p><h3 id="辅助回收"><a href="#辅助回收" class="headerlink" title="辅助回收"></a>辅助回收</h3><p>Go 语⾔“⼀段⽤户逻辑，⼀段并发扫描 Scan，⼀段并发回收 Collect”，那可能会造成这种状态：描的速度跟不上⽤户分配的速度，会造成扫描永远结束不了，结束不了的情况下很⼤的⿇烦在于垃圾回收就会出问题，⽤户内存膨胀，必须在性能和内存膨胀之间做出平衡。</p><p>以 Go 语⾔如果发现扫描后回收的速度跟不上分配的速度它依然会把⽤户逻辑暂停，⽤户逻辑暂停了以后也就意味着不会有新的对象出现，同时会把⽤户线程抢过来加⼊到垃圾回收⾥⾯加快垃圾回收的速度。因为并⾏有四个核，有三个核⽤户线程执⾏只有⼀个核在做垃圾回收，那⼀个核就有可能跑不过三个核，那把那三个核也抢过来做垃圾回收。这样⼀来原来的并发还是变成了 STW，还是得把⽤户线程暂停掉，要不然扫描和回收没完没了了停不下来，因为新分配对象⽐回收快，所以这种东⻄叫做辅助回收</p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>很多语⾔⽐如 Java 对垃圾回收器做了很多控制开关，是因为那些算法未必适合当前的这种算法，有些语⾔⽐较适合并发扫描有些语⾔不适合，甚⾄是像做⼤数据计算完全把 GC 关掉就是⼀直把内存⽤完了导致系统崩溃了为⽌，只不过崩溃之前保证把状态保存然后重新执⾏这个进程然后进⾏密集计算，把垃圾回收那段时间抢出来⽤来做密集计算。所以说垃圾回收器的算法不是万能的，它也没有办法做到真正意义上的智能。</p><p>Java、 Go 语⾔都有垃圾回收预值，甚⾄来决定预值什么时候启动垃圾回收，像 Go 语⾔有百分⽐来控制到底有多⼤合适，这个 GC 堆到底分配多⼤合理，这都需要在了解垃圾回收器原理情况下做动态调节。因为我们的服务程序很复杂，在服务器上可能⻓时间运⾏，垃圾回收器算法对性能影响很关键的.</p><p>Go 语⾔垃圾回收器⼀直被⼤家说实现的是原始版，因为 Go 早期版本对垃圾回收器预值怎么触发的特别蠢，第⼀次回收的时候回收完了剩下来对象是 2M，那么下次垃圾回收的内存消耗变成 4M，假设第⼀次回收之前内存是 100G，下次回收可能就变成 200G，可问题是下次回收⽤不了 200G，可能第⼀次回收⽤的 100G 是引⽤了⼤字典，在下次回收之前这字典清空了接下来⼀直⽤⼏⼗ M，垃圾回收器很难启动，所以 Go 语⾔在后台⽤⼀个循环线程扫描，每 2 分钟发现不执⾏就强制回收⼀次，这样的做法显然⽐较蠢。后来在 1.5 版本引⼊⼀个控制器，控制器有点像 Java 语⾔动态概念，当这次回收释放⽐例、或者是这些对象相关⼀些数据，控制器和辅助回收的作⽤ GitChat 来对预值动态调整决定下次回收</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Golang 从第一个版本以来，GC 一直是大家诟病最多的。但是每一个版本的发布基本都伴随着 GC 的改进。下面列出一些比较重要的改动。&lt;/p&gt;
&lt;p&gt;以下是 Golang GC 算法的里程碑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v1.1 STW&lt;/li&gt;
&lt;li&gt;v1.3 Mark STW, Sweep 并行&lt;/li&gt;
&lt;li&gt;v1.5 三色标记法&lt;/li&gt;
&lt;li&gt;v1.8 hybrid write barrier
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="面试" scheme="http://linthan.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="golang" scheme="http://linthan.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>图解Golang的GC算法</title>
    <link href="http://linthan.github.io/blog/2020/07/06/tech/golang/daiery-2020-0706-1021/"/>
    <id>http://linthan.github.io/blog/2020/07/06/tech/golang/daiery-2020-0706-1021/</id>
    <published>2020-07-06T02:21:00.000Z</published>
    <updated>2020-07-06T05:27:37.004Z</updated>
    
    <content type="html"><![CDATA[<p>虽然 Golang 的 GC 自打一开始，就被人所诟病，但是经过这么多年的发展，Golang 的 GC 已经改善了非常多，变得非常优秀了。</p><a id="more"></a><p>以下是 Golang GC 算法的里程碑：</p><ul><li>v1.1 STW</li><li>v1.3 Mark STW, Sweep 并行</li><li>v1.5 三色标记法</li><li>v1.8 hybrid write barrier</li></ul><p>经典的 GC 算法有三种：引用计数(reference counting)、标记-清扫(mark &amp; sweep)、复制收集(Copy and Collection)。</p><p>Golang 的 GC 算法主要是基于标记-清扫(mark and sweep)算法，并在此基础上做了改进。因此，在此主要介绍一下标记-清扫(mark and sweep)算法，关于引用计数(reference counting)和复制收集(copy and collection)可自行百度。</p><h2 id="标记-清扫-Mark-And-Sweep-算法"><a href="#标记-清扫-Mark-And-Sweep-算法" class="headerlink" title="标记-清扫(Mark And Sweep)算法"></a>标记-清扫(Mark And Sweep)算法</h2><p>此算法主要有两个主要的步骤：</p><ul><li>标记(Mark phase)</li><li>清除(Sweep phase)</li></ul><p>操作非常简单，但是有一点需要额外注意：mark and sweep 算法在执行的时候，需要程序暂停！即 stop the world。<br>也就是说，这段时间程序会卡在哪儿。故中文翻译成卡顿。</p><p>我们来看一下图解：</p><p>开始标记，程序暂停。程序和对象的此时关系是这样的：<br><img src="/blog/assets/golang/gc/mark_sweep_1.png" alt="mark_sweep_1"><br>然后开始标记，process 找出它所有可达的对象，并做上标记。如下图所示：<br><img src="/blog/assets/golang/gc/mark_sweep_2.png" alt="mark_sweep_2"><br>标记完了之后，然后开始清除未标记的对象：<br><img src="/blog/assets/golang/gc/mark_sweep_3.png" alt="mark_sweep_3"><br>然后垃圾清除了，变成了下图这样。<br><img src="/blog/assets/golang/gc/mark_sweep_4.png" alt="mark_sweep_4"><br>最后，停止暂停，让程序继续跑。然后循环重复这个过程，直到 process 生命周期结束。</p><h2 id="标记-清扫-Mark-And-Sweep-算法存在什么问题？"><a href="#标记-清扫-Mark-And-Sweep-算法存在什么问题？" class="headerlink" title="标记-清扫(Mark And Sweep)算法存在什么问题？"></a>标记-清扫(Mark And Sweep)算法存在什么问题？</h2><p>标记-清扫(Mark And Sweep)算法这种算法虽然非常的简单，但是还存在一些问题：</p><ul><li>STW，stop the world；让程序暂停，程序出现卡顿。</li><li>标记需要扫描整个 heap</li><li>清除数据会产生 heap 碎片</li></ul><p>这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序。</p><p>Go 是如何面对并这个问题的呢？</p><h2 id="三色并发标记法"><a href="#三色并发标记法" class="headerlink" title="三色并发标记法"></a>三色并发标记法</h2><p>我们先来看看 Golang 的三色标记法的大体流程。</p><p>首先：程序创建的对象都标记为白色。<br><img src="/blog/assets/golang/gc/mark_sweep_5.png" alt="mark_sweep_5"><br>gc 开始：扫描所有可到达的对象，标记为灰色<br><img src="/blog/assets/golang/gc/mark_sweep_6.png" alt="mark_sweep_6"><br>从灰色对象中找到其引用对象标记为灰色，把灰色对象本身标记为黑色<br><img src="/blog/assets/golang/gc/mark_sweep_7.png" alt="mark_sweep_7"><br>监视对象中的内存修改，并持续上一步的操作，直到灰色标记的对象不存在<br><img src="/blog/assets/golang/gc/mark_sweep_8.png" alt="mark_sweep_8"><br>此时，gc 回收白色对象。<br><img src="/blog/assets/golang/gc/mark_sweep_9.png" alt="mark_sweep_9"><br>最后，将所有黑色对象变为白色，并重复以上所有过程。<br><img src="/blog/assets/golang/gc/mark_sweep_10.png" alt="mark_sweep_10"><br>好了，大体的流程就是这样的，让我们回到刚才的问题：Go 是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？</p><h2 id="gc-和用户逻辑如何并行操作？"><a href="#gc-和用户逻辑如何并行操作？" class="headerlink" title="gc 和用户逻辑如何并行操作？"></a>gc 和用户逻辑如何并行操作？</h2><p>标记-清除(mark and sweep)算法的 STW(stop the world)操作，就是 runtime 把所有的线程全部冻结掉，所有的线程全部冻结意味着用户逻辑是暂停的。这样所有的对象都不会被修改了，这时候去扫描是绝对安全的。</p><p>Go 如何减短这个过程呢？标记-清除(mark and sweep)算法包含两部分逻辑：标记和清除。<br>我们知道 Golang 三色标记法中最后只剩下的黑白两种对象，黑色对象是程序恢复后接着使用的对象，如果不碰触黑色对象，只清除白色的对象，肯定不会影响程序逻辑。所以：清除操作和用户逻辑可以并发。</p><p>标记操作和用户逻辑也是并发的，用户逻辑会时常生成对象或者改变对象的引用，那么标记和用户逻辑如何并发呢？</p><h2 id="process-新生成对象的时候，GC-该如何操作呢？不会乱吗？"><a href="#process-新生成对象的时候，GC-该如何操作呢？不会乱吗？" class="headerlink" title="process 新生成对象的时候，GC 该如何操作呢？不会乱吗？"></a>process 新生成对象的时候，GC 该如何操作呢？不会乱吗？</h2><p>我们看如下图，在此状态下：process 程序又新生成了一个对象，我们设想会变成这样：<br><img src="/blog/assets/golang/gc/mark_sweep_11.png" alt="mark_sweep_11"><br>但是这样显然是不对的，因为按照三色标记法的步骤，这样新生成的对象 A 最后会被清除掉，这样会影响程序逻辑。</p><p>Golang 为了解决这个问题，引入了写屏障这个机制。<br>写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。<br>通俗的讲：就是在 gc 跑的过程中，可以监控对象的内存修改，并对对象进行重新标记。(实际上也是超短暂的 stw，然后对对象进行标记)</p><p>在上述情况中，新生成的对象，一律都标位灰色！<br>即下图：<br><img src="/blog/assets/golang/gc/mark_sweep_12.png" alt="mark_sweep_12"></p><p>那么，灰色或者黑色对象的引用改为白色对象的时候，Golang 是该如何操作的？<br>看如下图，一个黑色对象引用了曾经标记的白色对象。<br><img src="/blog/assets/golang/gc/mark_sweep_13.png" alt="mark_sweep_13"><br>这时候，写屏障机制被触发，向 GC 发送信号，GC 重新扫描对象并标位灰色。<br><img src="/blog/assets/golang/gc/mark_sweep_14.png" alt="mark_sweep_14"><br>因此，gc 一旦开始，无论是创建对象还是对象的引用改变，都会先变为灰色。</p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/" target="_blank" rel="noopener">Golang’s Real-time GC in Theory and Practice</a><br><a href="https://www.youtube.com/watch?v=n59VtiRx34s&amp;t=1151" target="_blank" rel="noopener">Golang’s realtime garbage collector</a><br><a href="/blog/2020/07/06/tech/golang/daiery-2020-0706-1300/">Golang 垃圾回收剖析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然 Golang 的 GC 自打一开始，就被人所诟病，但是经过这么多年的发展，Golang 的 GC 已经改善了非常多，变得非常优秀了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="面试" scheme="http://linthan.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="golang" scheme="http://linthan.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>epoll的本质</title>
    <link href="http://linthan.github.io/blog/2020/07/01/tech/os/daiery-2020-0701-2100/"/>
    <id>http://linthan.github.io/blog/2020/07/01/tech/os/daiery-2020-0701-2100/</id>
    <published>2020-07-01T13:00:00.000Z</published>
    <updated>2020-07-01T14:18:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>从事服务端开发，少不了要接触网络编程。epoll 作为 linux 下高性能网络服务器的必备技术至关重要，nginx、redis、skynet 和大部分游戏服务器都使用到这一多路复用技术。</p><a id="more"></a><p>因为 epoll 的重要性，不少游戏公司（如某某九九）在招聘服务端同学时，可能会问及 epoll 相关的问题。比如 epoll 和 select 的区别是什么？epoll 高效率的原因是什么？如果只靠背诵，显然不能算上深刻的理解。</p><p>网上虽然也有不少讲解 epoll 的文章，但要不是过于浅显，就是陷入源码解析，很少能有通俗易懂的。于是决定编写此文，让缺乏专业背景知识的读者也能够明白 epoll 的原理。文章核心思想是：<strong>要让读者清晰明白 EPOLL 为什么性能好。</strong></p><p>本文会从网卡接收数据的流程讲起，串联起 CPU 中断、操作系统进程调度等知识；再一步步分析阻塞接收数据、select 到 epoll 的进化过程；最后探究 epoll 的实现细节。目录：</p><h2 id="一、从网卡接收数据说起"><a href="#一、从网卡接收数据说起" class="headerlink" title="一、从网卡接收数据说起"></a>一、从网卡接收数据说起</h2><p>下图是一个典型的计算机结构图，计算机由 CPU、存储器（内存）、网络接口等部件组成。了解 epoll 本质的第一步，要从硬件的角度看计算机怎样接收网络数据。<br><img src="/blog/assets/os/computer_structure.jpg" alt="computer_structure"><br>下图展示了网卡接收数据的过程。在 ① 阶段，网卡收到网线传来的数据；经过 ② 阶段的硬件电路的传输；最终将数据写入到内存中的某个地址上（③ 阶段）。这个过程涉及到 DMA 传输、IO 通路选择等硬件有关的知识，但我们只需知道：网卡会把接收到的数据写入内存。<br><img src="/blog/assets/os/computer_mother_board.jpg" alt="computer_mother_board"><br>通过硬件传输，网卡接收的数据存放到内存中。操作系统就可以去读取它们。</p><h2 id="二、如何知道接收了数据？"><a href="#二、如何知道接收了数据？" class="headerlink" title="二、如何知道接收了数据？"></a>二、如何知道接收了数据？</h2><p>了解 epoll 本质的第二步，要从 CPU 的角度来看数据接收。要理解这个问题，要先了解一个概念——中断。</p><p>计算机执行程序时，会有优先级的需求。比如，当计算机收到断电信号时（电容可以保存少许电量，供 CPU 运行很短的一小段时间），它应立即去保存数据，保存数据的程序具有较高的优先级。</p><p>一般而言，由硬件产生的信号需要 cpu 立马做出回应（不然数据可能就丢失），所以它的优先级很高。cpu 理应中断掉正在执行的程序，去做出响应；当 cpu 完成对硬件的响应后，再重新执行用户程序。中断的过程如下图，和函数调用差不多。只不过函数调用是事先定好位置，而中断的位置由“信号”决定。<br><img src="/blog/assets/os/os_interruption.jpg" alt="os_interruption"><br>以键盘为例，当用户按下键盘某个按键时，键盘会给 cpu 的中断引脚发出一个高电平。cpu 能够捕获这个信号，然后执行键盘中断程序。下图展示了各种硬件通过中断与 cpu 交互。<br><img src="/blog/assets/os/os_infra_interface.jpg" alt="os_infra_interface"><br>现在可以回答本节提出的问题了：当网卡把数据写入到内存后，网卡向 cpu 发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。</p><h2 id="三、进程阻塞为什么不占用-cpu-资源？"><a href="#三、进程阻塞为什么不占用-cpu-资源？" class="headerlink" title="三、进程阻塞为什么不占用 cpu 资源？"></a>三、进程阻塞为什么不占用 cpu 资源？</h2><p>了解 epoll 本质的第三步，要从操作系统进程调度的角度来看数据接收。阻塞是进程调度的关键一环，指的是进程在等待某事件（如接收到网络数据）发生之前的等待状态，recv、select 和 epoll 都是阻塞方法。了解“进程阻塞为什么不占用 cpu 资源？”，也就能够了解这一步。</p><p>为简单起见，我们从普通的 recv 接收开始分析，先看看下面代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建socket</span></span><br><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//绑定</span></span><br><span class="line">bind(s, ...)</span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">listen(s, ...)</span><br><span class="line"><span class="comment">//接受客户端连接</span></span><br><span class="line"><span class="keyword">int</span> c = accept(s, ...)</span><br><span class="line"><span class="comment">//接收客户端数据</span></span><br><span class="line">recv(c, ...);</span><br><span class="line"><span class="comment">//将数据打印出来</span></span><br><span class="line"><span class="built_in">printf</span>(...)</span><br></pre></td></tr></table></figure><p>这是一段最基础的网络编程代码，先新建 socket 对象，依次调用 bind、listen、accept，最后调用 recv 接收数据。recv 是个阻塞方法，当程序运行到 recv 时，它会一直等待，直到接收到数据才往下执行。</p><p>插入：如果您还不太熟悉网络编程，欢迎阅读我编写的《Unity3D 网络游戏实战(第 2 版)》，会有详细的介绍。</p><p>那么阻塞的原理是什么？</p><p><strong>工作队列</strong><br>操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态。运行状态是进程获得 cpu 使用权，正在执行代码的状态；等待状态是阻塞状态，比如上述程序运行到 recv 时，程序会从运行状态变为等待状态，接收到数据后又变回运行状态。操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。</p><p>下图中的计算机中运行着 A、B、C 三个进程，其中进程 A 执行着上述基础网络程序，一开始，这 3 个进程都被操作系统的工作队列所引用，处于运行状态，会分时执行。<br><img src="/blog/assets/os/current_demo1.jpg" alt="current_demo1"></p><p><strong>等待队列</strong><br>当进程 A 执行到创建 socket 的语句时，操作系统会创建一个由文件系统管理的 socket 对象（如下图）。这个 socket 对象包含了发送缓冲区、接收缓冲区、等待队列等成员。等待队列是个非常重要的结构，它指向所有需要等待该 socket 事件的进程。<br><img src="/blog/assets/os/current_demo2.jpg" alt="current_demo2"></p><p>当程序执行到 recv 时，操作系统会将进程 A 从工作队列移动到该 socket 的等待队列中（如下图）。由于工作队列只剩下了进程 B 和 C，依据进程调度，cpu 会轮流执行这两个进程的程序，不会执行进程 A 的程序。所以进程 A 被阻塞，不会往下执行代码，也不会占用 cpu 资源。<br><img src="/blog/assets/os/current_demo3.jpg" alt="current_demo3"><br>ps：操作系统添加等待队列只是添加了对这个“等待中”进程的引用，以便在接收到数据时获取进程对象、将其唤醒，而非直接将进程管理纳入自己之下。上图为了方便说明，直接将进程挂到等待队列之下。</p><p><strong>唤醒进程</strong><br>当 socket 接收到数据后，操作系统将该 socket 等待队列上的进程重新放回到工作队列，该进程变成运行状态，继续执行代码。也由于 socket 的接收缓冲区已经有了数据，recv 可以返回接收到的数据。</p><h2 id="四、内核接收网络数据全过程"><a href="#四、内核接收网络数据全过程" class="headerlink" title="四、内核接收网络数据全过程"></a>四、内核接收网络数据全过程</h2><p><strong>这一步，贯穿网卡、中断、进程调度的知识，叙述阻塞 recv 下，内核接收数据全过程。</strong><br>如下图所示，进程在 recv 阻塞期间，计算机收到了对端传送的数据（步骤 ①）。数据经由网卡传送到内存（步骤 ②），然后网卡通过中断信号通知 cpu 有数据到达，cpu 执行中断程序（步骤 ③）。此处的中断程序主要有两项功能，先将网络数据写入到对应 socket 的接收缓冲区里面（步骤 ④），再唤醒进程 A（步骤 ⑤），重新将进程 A 放入工作队列中。<br><img src="/blog/assets/os/current_demo4.jpg" alt="current_demo4"><br>唤醒进程的过程如下图所示。<br><img src="/blog/assets/os/current_demo5.jpg" alt="current_demo5"><br><strong>以上是内核接收数据全过程</strong><br>这里留有两个思考题，大家先想一想。</p><p>其一，操作系统如何知道网络数据对应于哪个 socket？</p><p>其二，如何同时监视多个 socket 的数据？</p><p>（——我是分割线，想好了才能往下看哦~）</p><p>公布答案的时刻到了。</p><p>第一个问题：因为一个 socket 对应着一个端口号，而网络数据包中包含了 ip 和端口的信息，内核可以通过端口号找到对应的 socket。当然，为了提高处理速度，操作系统会维护端口号到 socket 的索引结构，以快速读取。</p><p>第二个问题是多路复用的重中之重，是本文后半部分的重点！</p><h2 id="五、同时监视多个-socket-的简单方法"><a href="#五、同时监视多个-socket-的简单方法" class="headerlink" title="五、同时监视多个 socket 的简单方法"></a>五、同时监视多个 socket 的简单方法</h2><p>服务端需要管理多个客户端连接，而 recv 只能监视单个 socket，这种矛盾下，人们开始寻找监视多个 socket 的方法。epoll 的要义是高效的监视多个 socket。从历史发展角度看，必然先出现一种不太高效的方法，人们再加以改进。只有先理解了不太高效的方法，才能够理解 epoll 的本质。</p><p>假如能够预先传入一个 socket 列表，如果列表中的 socket 都没有数据，挂起进程，直到有一个 socket 收到数据，唤醒进程。这种方法很直接，也是 select 的设计思想。</p><p>为方便理解，我们先复习 select 的用法。在如下的代码中，先准备一个数组（下面代码中的 fds），让 fds 存放着所有需要监视的 socket。然后调用 select，如果 fds 中的所有 socket 都没有数据，select 会阻塞，直到有一个 socket 接收到数据，select 返回，唤醒进程。用户可以遍历 fds，通过 FD_ISSET 判断具体哪个 socket 收到数据，然后做出处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">bind(s, ...)</span><br><span class="line">listen(s, ...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fds[] =  存放需要监听的socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = select(..., fds, ...)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; fds.count; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fds[i], ...))&#123;</span><br><span class="line">            <span class="comment">//fds[i]的数据处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>select 的流程</strong><br>select 的实现思路很直接。假如程序同时监视如下图的 sock1、sock2 和 sock3 三个 socket，那么在调用 select 之后，操作系统把进程 A 分别加入这三个 socket 的等待队列中。<br><img src="/blog/assets/os/current_demo6.jpg" alt="current_demo6"><br>当任何一个 socket 收到数据后，中断程序将唤起进程。下图展示了 sock2 接收到了数据的处理流程。</p><p>ps：recv 和 select 的中断回调可以设置成不同的内容。<br><img src="/blog/assets/os/current_demo7.jpg" alt="current_demo7"><br>所谓唤起进程，就是将进程从所有的等待队列中移除，加入到工作队列里面。如下图所示。<br><img src="/blog/assets/os/current_demo8.jpg" alt="current_demo8"></p><p>经由这些步骤，当进程 A 被唤醒后，它知道至少有一个 socket 接收了数据。程序只需遍历一遍 socket 列表，就可以得到就绪的 socket。</p><p>这种简单方式行之有效，在几乎所有操作系统都有对应的实现。<br><strong>但是简单的方法往往有缺点，主要是：</strong><br>其一，每次调用 select 都需要将进程加入到所有监视 socket 的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个 fds 列表传递给内核，有一定的开销。正是因为遍历操作开销大，出于效率的考量，才会规定 select 的最大监视数量，默认只能监视 1024 个 socket。</p><p>其二，进程被唤醒后，程序并不知道哪些 socket 收到数据，还需要遍历一次。</p><p>那么，有没有减少遍历的方法？有没有保存就绪 socket 的方法？这两个问题便是 epoll 技术要解决的。</p><p>补充说明： 本节只解释了 select 的一种情形。当程序调用 select 时，内核会先遍历一遍 socket，如果有一个以上的 socket 接收缓冲区有数据，那么 select 直接返回，不会阻塞。这也是为什么 select 的返回值有可能大于 1 的原因之一。如果没有 socket 有数据，进程才会阻塞。</p><h2 id="六、epoll-的设计思路"><a href="#六、epoll-的设计思路" class="headerlink" title="六、epoll 的设计思路"></a>六、epoll 的设计思路</h2><p>epoll 是在 select 出现 N 多年后才被发明的，是 select 和 poll 的增强版本。epoll 通过以下一些措施来改进效率。</p><p><strong>措施一：功能分离</strong></p><p>select 低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一。如下图所示，每次调用 select 都需要这两步操作，然而大多数应用场景中，需要监视的 socket 相对固定，并不需要每次都修改。epoll 将这两个操作分开，先用 epoll_ctl 维护等待队列，再调用 epoll_wait 阻塞进程。显而易见的，效率就能得到提升。<br><img src="/blog/assets/os/select_epoll_compare.jpg" alt="select_epoll_compare"><br>为方便理解后续的内容，我们先复习下 epoll 的用法。如下的代码中，先用 epoll_create 创建一个 epoll 对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到 epfd 中，最后调用 epoll_wait 等待数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">bind(s, ...)</span><br><span class="line">listen(s, ...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> epfd = epoll_create(...);</span><br><span class="line">epoll_ctl(epfd, ...); <span class="comment">//将所有需要监听的socket添加到epfd中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = epoll_wait(...)</span><br><span class="line">    <span class="keyword">for</span>(接收到数据的socket)&#123;</span><br><span class="line">        <span class="comment">//处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能分离，使得 epoll 有了优化的可能。</p><p><strong>措施二：就绪列表</strong></p><p>select 低效的另一个原因在于程序不知道哪些 socket 收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的 socket，就能避免遍历。如下图所示，计算机共有三个 socket，收到数据的 sock2 和 sock3 被 rdlist（就绪列表）所引用。当进程被唤醒后，只要获取 rdlist 的内容，就能够知道哪些 socket 收到数据。<br><img src="/blog/assets/os/current_demo9.jpg" alt="current_demo9"></p><h2 id="七、epoll-的原理和流程"><a href="#七、epoll-的原理和流程" class="headerlink" title="七、epoll 的原理和流程"></a>七、epoll 的原理和流程</h2><p>本节会以示例和图表来讲解 epoll 的原理和流程。</p><p><strong>创建 epoll 对象</strong><br>如下图所示，当某个进程调用 epoll_create 方法时，内核会创建一个 eventpoll 对象（也就是程序中 epfd 所代表的对象）。eventpoll 对象也是文件系统中的一员，和 socket 一样，它也会有等待队列。<br><img src="/blog/assets/os/current_demo10.jpg" alt="current_demo10"><br>创建一个代表该 epoll 的 eventpoll 对象是必须的，因为内核要维护“就绪列表”等数据，“就绪列表”可以作为 eventpoll 的成员。</p><p><strong>维护监视列表</strong><br>创建 epoll 对象后，可以用 epoll_ctl 添加或删除所要监听的 socket。以添加 socket 为例，如下图，如果通过 epoll_ctl 添加 sock1、sock2 和 sock3 的监视，内核会将 eventpoll 添加到这三个 socket 的等待队列中。<br><img src="/blog/assets/os/current_demo11.jpg" alt="current_demo11"><br>当 socket 收到数据后，中断程序会操作 eventpoll 对象，而不是直接操作进程。</p><p><strong>接收数据</strong><br>当 socket 收到数据后，中断程序会给 eventpoll 的“就绪列表”添加 socket 引用。如下图展示的是 sock2 和 sock3 收到数据后，中断程序让 rdlist 引用这两个 socket。<br><img src="/blog/assets/os/current_demo12.jpg" alt="current_demo12"><br>eventpoll 对象相当于是 socket 和进程之间的中介，socket 的数据接收并不直接影响进程，而是通过改变 eventpoll 的就绪列表来改变进程状态。</p><p>当程序执行到 epoll_wait 时，如果 rdlist 已经引用了 socket，那么 epoll_wait 直接返回，如果 rdlist 为空，阻塞进程。</p><h2 id="阻塞和唤醒进程"><a href="#阻塞和唤醒进程" class="headerlink" title="阻塞和唤醒进程"></a>阻塞和唤醒进程</h2><p>假设计算机中正在运行进程 A 和进程 B，在某时刻进程 A 运行到了 epoll_wait 语句。如下图所示，内核会将进程 A 放入 eventpoll 的等待队列中，阻塞进程。<br><img src="/blog/assets/os/current_demo13.jpg" alt="current_demo13"><br>当 socket 接收到数据，中断程序一方面修改 rdlist，另一方面唤醒 eventpoll 等待队列中的进程，进程 A 再次进入运行状态（如下图）。也因为 rdlist 的存在，进程 A 可以知道哪些 socket 发生了变化。<br><img src="/blog/assets/os/current_demo14.jpg" alt="current_demo14"></p><h2 id="八、epoll-的实现细节"><a href="#八、epoll-的实现细节" class="headerlink" title="八、epoll 的实现细节"></a>八、epoll 的实现细节</h2><p>至此，相信读者对 epoll 的本质已经有一定的了解。但我们还留有一个问题，eventpoll 的数据结构是什么样子？</p><p>再留两个问题，就绪队列应该应使用什么数据结构？eventpoll 应使用什么数据结构来管理通过 epoll_ctl 添加或删除的 socket？</p><p>（——我是分割线，想好了才能往下看哦~）<br>如下图所示，eventpoll 包含了 lock、mtx、wq（等待队列）、rdlist 等成员。rdlist 和 rbr 是我们所关心的。<br><img src="/blog/assets/os/epoll_struct.jpg" alt="epoll_struct"></p><p><strong>就绪列表的数据结构</strong><br>就绪列表引用着就绪的 socket，所以它应能够快速的插入数据。</p><p>程序可能随时调用 epoll_ctl 添加监视 socket，也可能随时删除。当删除时，若该 socket 已经存放在就绪列表中，它也应该被移除。</p><p>所以就绪列表应是一种能够快速插入和删除的数据结构。双向链表就是这样一种数据结构，epoll 使用双向链表来实现就绪队列（对应上图的 rdllist）。</p><p><strong>索引结构</strong><br>既然 epoll 将“维护监视队列”和“进程阻塞”分离，也意味着需要有个数据结构来保存监视的 socket。至少要方便的添加和移除，还要便于搜索，以避免重复添加。红黑树是一种自平衡二叉查找树，搜索、插入和删除时间复杂度都是 O(log(N))，效率较好。epoll 使用了红黑树作为索引结构（对应上图的 rbr）。</p><p>ps：因为操作系统要兼顾多种功能，以及由更多需要保存的数据，rdlist 并非直接引用 socket，而是通过 epitem 间接引用，红黑树的节点也是 epitem 对象。同样，文件系统也并非直接引用着 socket。为方便理解，本文中省略了一些间接结构。</p><p>九、结论<br>epoll 在 select 和 poll（poll 和 select 基本一样，有少量改进）的基础引入了 eventpoll 作为中间层，使用了先进的数据结构，是一种高效的多路复用技术。</p><p>再留一点作业！</p><p>下表是个很常见的表，描述了 select、poll 和 epoll 的区别。读完本文，读者能否解释 select 和 epoll 的时间复杂度为什么是 O(n)和 O(1)？<br><img src="/blog/assets/os/select_poll_epoll_diff.jpg" alt="select_poll_epoll_diff"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从事服务端开发，少不了要接触网络编程。epoll 作为 linux 下高性能网络服务器的必备技术至关重要，nginx、redis、skynet 和大部分游戏服务器都使用到这一多路复用技术。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="操作系统" scheme="http://linthan.github.io/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用的三种机制Select，Poll，Epoll</title>
    <link href="http://linthan.github.io/blog/2020/07/01/tech/os/daiery-2020-0701-1600/"/>
    <id>http://linthan.github.io/blog/2020/07/01/tech/os/daiery-2020-0701-1600/</id>
    <published>2020-07-01T08:00:00.000Z</published>
    <updated>2020-07-01T12:37:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>I/O 多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲 I/O 数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作</p><a id="more"></a><p>select、poll 和 epoll 都是 Linux API 提供的 IO 复用方式。<br>[1] blocking IO - 阻塞 IO<br>[2] nonblocking IO - 非阻塞 IO<br>[3] IO multiplexing - IO 多路复用<br>[4] signal driven IO - 信号驱动 IO<br>[5] asynchronous IO - 异步 IO</p><p>其中前面 4 种 IO 都可以归类为 synchronous IO - 同步 IO，而 select、poll、epoll 本质上也都是同步 I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</p><p>与多进程和多线程技术相比，I/O 多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p><p>在介绍 select、poll、epoll 之前，首先介绍一下 Linux 操作系统中基础的概念：</p><ul><li><strong>用户空间 / 内核空间</strong><br>现在操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。<br>操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</li><li><strong>进程切换</strong><br>为了控制进程的执行，内核必须有能力挂起正在 CPU 上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的，并且进程切换是非常耗费资源的。</li><li><strong>进程阻塞</strong><br>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得了 CPU 资源），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用 CPU 资源的。</li><li><strong>文件描述符</strong><br>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。<br>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。</li><li><strong>缓存 IO</strong><br>缓存 I/O 又称为标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</li></ul><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>我们先分析一下 select 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,<span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>【参数说明】</strong><br>int maxfdp1 指定待测试的文件描述字个数，它的值是待测试的最大描述字加 1。<br>fd_set <em>readset , fd_set </em>writeset , fd_set <em>exceptset<br>fd_set 可以理解为一个集合，这个集合中存放的是文件描述符(file descriptor)，即文件句柄。中间的三个参数指定我们要让内核测试读、写和异常条件的文件描述符集合。如果对某一个的条件不感兴趣，就可以把它设为空指针。<br>const struct timeval </em>timeout timeout 告知内核等待所指定文件描述符集合中的任何一个就绪可花多少时间。其 timeval 结构用于指定这段时间的秒数和微秒数。<br><strong>【返回值】</strong></p><p>int 若有就绪描述符返回其数目，若超时则为 0，若出错则为-1</p><p><strong>select 运行机制</strong><br>select()的机制中提供一种 fd_set 的数据结构，实际上是一个 long 类型的数组，每一个数组元素都能与一打开的文件句柄（不管是 Socket 句柄,还是其他文件或命名管道或设备句柄）建立联系，建立联系的工作由程序员完成，当调用 select()时，由内核根据 IO 状态修改 fd_set 的内容，由此来通知执行了 select()的进程哪一 Socket 或文件可读。</p><p>从流程上来看，使用 select 函数进行 IO 请求和同步阻塞模型没有太大的区别，甚至还多了添加监视 socket，以及调用 select 函数的额外操作，效率更差。但是，使用 select 以后最大的优势是用户可以在一个线程内同时处理多个 socket 的 IO 请求。用户可以注册多个 socket，然后不断地调用 select 读取被激活的 socket，即可达到在同一个线程内同时处理多个 IO 请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。<br><strong>select 机制的问题</strong></p><ol><li>每次调用 select，都需要把 fd_set 集合从用户态拷贝到内核态，如果 fd_set 集合很大时，那这个开销也很大</li><li>同时每次调用 select 都需要在内核遍历传递进来的所有 fd_set，如果 fd_set 集合很大时，那这个开销也很大</li><li>为了减少数据拷贝带来的性能损坏，内核对被监控的 fd_set 集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为 1024)</li></ol><h2 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h2><p>poll 的机制与 select 类似，与 select 在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是 poll 没有最大文件描述符数量的限制。也就是说，poll 只解决了上面的问题 3，并没有解决问题 1，2 的性能开销问题。</p><p>下面是 pll 的函数原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br><span class="line"></span><br><span class="line">typedef struct pollfd &#123;</span><br><span class="line">        int fd;                         // 需要被检测或选择的文件描述符</span><br><span class="line">        short events;                   // 对文件描述符fd上感兴趣的事件</span><br><span class="line">        short revents;                  // 文件描述符fd上当前实际发生的事件</span><br><span class="line">&#125; pollfd_t;</span><br></pre></td></tr></table></figure><p>poll 改变了文件描述符集合的描述方式，使用了 pollfd 结构而不是 select 的 fd_set 结构，使得 poll 支持的文件描述符集合限制远大于 select 的 1024</p><p><strong>【参数说明】</strong><br>struct pollfd *fds fds 是一个 struct pollfd 类型的数组，用于存放需要检测其状态的 socket 描述符，并且调用 poll 函数之后 fds 数组不会被清空；一个 pollfd 结构体表示一个被监视的文件描述符，通过传递 fds 指示 poll() 监视多个文件描述符。其中，结构体的 events 域是监视该文件描述符的事件掩码，由用户来设置这个域，结构体的 revents 域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域</p><p>nfds_t nfds 记录数组 fds 中描述符的总数量</p><p><strong>【返回值】</strong><br>int 函数返回 fds 集合中就绪的读、写，或出错的描述符数量，返回 0 表示超时，返回-1 表示出错；</p><h2 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h2><p>epoll 在 Linux2.6 内核正式提出，是基于事件驱动的 I/O 方式，相对于 select 来说，epoll 没有描述符个数限制，使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。</p><p>Linux 中提供的 epoll 相关函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ol><li><p>epoll_create 函数创建一个 epoll 句柄，参数 size 表明内核要监听的描述符数量。调用成功时返回一个 epoll 句柄描述符，失败时返回-1。</p></li><li><p>epoll_ctl 函数注册要监听的事件类型。四个参数解释如下：</p></li></ol><ul><li>epfd 表示 epoll 句柄</li><li>op 表示 fd 操作类型，有如下 3 种<ul><li>EPOLL_CTL_ADD 注册新的 fd 到 epfd 中</li><li>EPOLL_CTL_MOD 修改已注册的 fd 的监听事件</li><li>EPOLL_CTL_DEL 从 epfd 中删除一个 fd</li></ul></li><li>fd 是要监听的描述符</li><li>event 表示要监听的事件</li></ul><p>epoll_event 结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">__uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>epoll_wait 函数等待事件的就绪，成功时返回就绪的事件数目，调用失败时返回 -1，等待超时返回 0。</li></ol><ul><li>epfd 是 epoll 句柄</li><li>events 表示从内核得到的就绪事件集合</li><li>maxevents 告诉内核 events 的大小</li><li>timeout 表示等待的超时事件</li></ul><p>epoll 是 Linux 内核为处理大批量文件描述符而作了改进的 poll，是 Linux 下多路复用 IO 接口 select/poll 的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核 IO 事件异步唤醒而加入 Ready 队列的描述符集合就行了。</p><ul><li><p>epoll 除了提供 select/poll 那种 IO 事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存 IO 状态，减少 epoll_wait/epoll_pwait 的调用，提高应用程序效率。</p></li><li><p>水平触发（LT）：默认工作模式，即当 epoll_wait 检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用 epoll_wait 时，会再次通知此事件<br>边缘触发（ET）： 当 epoll_wait 检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时只通知一次）。</p></li></ul><p>LT 和 ET 原本应该是用于脉冲信号的，可能用它来解释更加形象。Level 和 Edge 指的就是触发点，Level 为只要处于水平，那么就一直触发，而 Edge 则为上升沿和下降沿的时候触发。比如：0-&gt;1 就是 Edge，1-&gt;1 就是 Level。</p><p>ET 模式很大程度上减少了 epoll 事件的触发次数，因此效率比 LT 模式下高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一张图总结一下 select,poll,epoll 的区别：</p><table><thead><tr><th></th><th>select</th><th>poll</th><th>epoll</th></tr></thead><tbody><tr><td>操作方式</td><td>遍历</td><td>遍历</td><td>回调</td></tr><tr><td>底层实现</td><td>数组</td><td>链表</td><td>哈希表</td></tr><tr><td>IO 效率</td><td>每次调用都进行线性遍历，时间复杂度为 O(n)</td><td>每次调用都进行线性遍历，时间复杂度为 O(n) 事件通知方式</td><td>每当 fd 就绪，系统注册的回调函数就会被调用，将就绪 fd 放到 readyList 里面，时间复杂度 O(1)</td></tr><tr><td>最大连接数</td><td>1024（x86）或 2048（x64）</td><td>无上限</td><td>无上限</td></tr><tr><td>fd 拷贝</td><td>每次调用 select，都需要把 fd 集合从用户态拷贝到内核态</td><td>每次调用 poll，都需要把 fd 集合从用户态拷贝到内核态</td><td>调用 epoll_ctl 时拷贝进内核并保存，之后每次 epoll_wait 不拷贝</td></tr></tbody></table><p>epoll 是 Linux 目前大规模网络并发程序开发的首选模型。在绝大多数情况下性能远超 select 和 poll。目前流行的高性能 web 服务器 Nginx 正式依赖于 epoll 提供的高效网络套接字轮询服务。但是，在并发连接不高的情况下，多线程+阻塞 I/O 方式可能性能更好。</p><p>既然 select，poll，epoll 都是 I/O 多路复用的具体的实现，之所以现在同时存在，其实他们也是不同历史时期的产物</p><ul><li>select 出现是 1984 年在 BSD 里面实现的</li><li>14 年之后也就是 1997 年才实现了 poll，其实拖那么久也不是效率问题， 而是那个时代的硬件实在太弱，一台服务器处理 1 千多个- 链接简直就是神一样的存在了，select 很长段时间已经满足需求</li><li>2002, 大神 Davide Libenzi 实现了 epoll</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I/O 多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲 I/O 数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="操作系统" scheme="http://linthan.github.io/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>动图了解I/O多路复用</title>
    <link href="http://linthan.github.io/blog/2020/07/01/tech/os/daiery-2020-0701-1500/"/>
    <id>http://linthan.github.io/blog/2020/07/01/tech/os/daiery-2020-0701-1500/</id>
    <published>2020-07-01T02:00:00.000Z</published>
    <updated>2020-07-01T08:07:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>啥叫 I/O 多路复用？<br>epoll 又是个什么东西？<br>你或许看过很多文章，但是还是感觉云里雾里的，今天，我们抛开文字，释放动图，或许你就理解了。</p><a id="more"></a><h2 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h2><p>通常的一次的请求结果如下图所示：</p><p><img src="/blog/assets/os/normal.gif" alt="normal"></p><p>但是，服务器往往不会只处理一次请求，往往是多个请求，这一个请求，这时候每来一个请求，就会生成一个进程或线程。<br><img src="/blog/assets/os/normal_1.png" alt="normal_1"><br>在这些请求线程或者进程中，大部分都处于等待阶段，只有少部分是接收数据。这样一来，非常耗费资源，而且这些线程或者进程的管理，也是个事儿。<br><img src="/blog/assets/os/normal_2.png" alt="normal_2"><br>于是，有人想到一个办法：我们只用一个线程或者进程来和系统内核打交道，并想办法把每个应用的 I/O 流状态记录下来，一有响应变及时返回给相应的应用。<br><img src="/blog/assets/os/io_multi.png" alt="io_multi"><br>或者下图：<br><img src="/blog/assets/os/io_multi.jpeg" alt="io_multi"></p><h2 id="select、poll、epoll"><a href="#select、poll、epoll" class="headerlink" title="select、poll、epoll"></a>select、poll、epoll</h2><p>select, poll, epoll 都是 I/O 多路复用的具体实现，他们出现是有先后顺序的。</p><p>select 是第一个实现 (1983 左右在 BSD 里面实现的)。</p><p>select 被实现后，发现诸多问题，然后 1997 年实现了 poll，对 select 进行了改进，select 和 poll 是很类似的。</p><p>再后来，2002 做出重大改进实现了 epoll。</p><p>epoll 和 select/poll 有着很大的不同：</p><p>例如：select/poll 的处理流程如下：</p><p><img src="/blog/assets/os/select.gif" alt="select"><br>而 epoll 的处理流程如下：<br><img src="/blog/assets/os/epoll.gif" alt="epoll"></p><p>这样，就无需遍历成千上万个消息列表了，直接可以定位哪个 socket 有数据。</p><p>那么，这是如何实现的呢？</p><p>早期的时候 epoll 的实现是一个哈希表，但是后来由于占用空间比较大，改为了红黑树和链表。<br><img src="/blog/assets/os/epoll_rbtree.png" alt="epoll_rbtree"></p><p>其中链表中全部为活跃的链接，红黑树中放的是所有事件。两部分各司其职。<br>这样一来，当收到内核的数据时，只需遍历链表中的数据就行了，而注册 read 事件或者 write 事件的时候，向红黑树中记录。</p><p>结果导致：</p><ul><li>创建\修改\删除消息效率非常高：O(logN)。</li><li>获取活跃链接也非常快，因为在一个时间内，大部分是不活跃的链接，活跃的链接是少数，只需要遍历少数活跃的链接就好了</li></ul><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ul><li><a href="/blog/2018/10/05/tech/unix/dairy-2018-1005-1011/">同步 IO、异步 IO、阻塞 IO 和非阻塞 IO</a></li><li><a href="https://blog.csdn.net/qq_28098067/article/details/80537564" target="_blank" rel="noopener">https://blog.csdn.net/qq_28098067/article/details/80537564</a></li><li><a href="https://www.jianshu.com/p/397449cadc9a" target="_blank" rel="noopener">https://www.jianshu.com/p/397449cadc9a</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;啥叫 I/O 多路复用？&lt;br&gt;epoll 又是个什么东西？&lt;br&gt;你或许看过很多文章，但是还是感觉云里雾里的，今天，我们抛开文字，释放动图，或许你就理解了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="操作系统" scheme="http://linthan.github.io/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>一文读懂什么是进程、线程、协程</title>
    <link href="http://linthan.github.io/blog/2020/07/01/tech/os/daiery-2020-0701-1011/"/>
    <id>http://linthan.github.io/blog/2020/07/01/tech/os/daiery-2020-0701-1011/</id>
    <published>2020-07-01T02:00:00.000Z</published>
    <updated>2020-07-01T04:25:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>我们都知道计算机的核心是 CPU，它承担了所有的计算任务；而操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序则是具有某种功能的程序，程序是运行于操作系统之上的。</p><p>进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p><a id="more"></a><p>进程一般由程序、数据集合和进程控制块三部分组成。</p><ul><li>程序用于描述进程要完成的功能，是控制进程执行的指令集；</li><li>数据集合是程序在执行时所需要的数据和工作区；</li><li>程序控制块(Program Control Block，简称 PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。</li></ul><p>进程具有的特征：</p><ul><li>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；</li><li>并发性：任何进程都可以同其他进程一起并发执行；</li><li>独立性：进程是系统进行资源分配和调度的一个独立单位；</li><li>结构性：进程由程序、数据和进程控制块三部分组成。</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。</p><p>后来，随着计算机的发展，对 CPU 的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程。</p><p>线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程 ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。<br>（读到这里可能有的读者迷糊，感觉这和 Java 的内存空间模型不太一样，但如果你深入的读过深入理解 Java 虚拟机这本书的话你就会恍然大悟）<br><img src="/blog/assets/os/process.png" alt="process"><br>如上图，在任务管理器的进程一栏里，有道词典和有道云笔记就是进程，而在进程下又有着多个执行不同任务的线程。</p><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>线程是什么？要理解这个概念，需要先了解一下操作系统的一些相关概念。大部分操作系统(如 Windows、Linux)的任务调度是采用时间片轮转的抢占式调度方式。</p><p>在一个进程中，当一个线程任务执行几毫秒后，会由操作系统的内核（负责管理各个任务）进行调度，通过硬件的计数器中断处理器，让该线程强制暂停并将该线程的寄存器放入内存中，通过查看线程列表决定接下来执行哪一个线程，并从内存中恢复该线程的寄存器，最后恢复该线程的执行，从而去执行下一个任务。<br>上述过程中，任务执行的那一小段时间叫做时间片，任务正在执行时的状态叫运行状态，被暂停的线程任务状态叫做就绪状态，意为等待下一个属于它的时间片的到来。</p><p>这种方式保证了每个线程轮流执行，由于 CPU 的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发(别觉得并发有多高深，它的实现很复杂，但它的概念很简单，就是一句话：多个任务同时执行)。多任务运行过程的示意图如下：<br><img src="/blog/assets/os/task_scheduler.png" alt="task_scheduler"></p><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><p>前面讲了进程与线程，但可能你还觉得迷糊，感觉他们很类似。的确，进程与线程有着千丝万缕的关系，下面就让我们一起来理一理：</p><ol><li>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；</li><li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；<br>3。 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；</li><li>调度和切换：线程上下文切换比进程上下文切换要快得多。</li></ol><p>线程与进程关系的示意图：<br><img src="/blog/assets/os/resource_sharing.png" alt="resource_sharing"><br><img src="/blog/assets/os/task_scheduler.png" alt="task_scheduler"><br>   总之，线程和进程都是一种抽象的概念，线程是一种比进程更小的抽象，线程和进程都可用于实现并发。 在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。它相当于一个进程里只有一个线程，进程本身就是线程。所以线程有时被称为轻量级进程(Lightweight Process，LWP）。<br><img src="/blog/assets/os/course.png" alt="course"><br>后来，随着计算机的发展，对多个任务之间上下文切换的效率要求越来越高，就抽象出一个更小的概念——线程，一般一个进程会有多个(也可是一个)线程。<br><img src="/blog/assets/os/multithreading.png" alt="multithreading"></p><h2 id="多线程与多核"><a href="#多线程与多核" class="headerlink" title="多线程与多核"></a>多线程与多核</h2><p>上面提到的时间片轮转的调度方式说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。很多操作系统的书都说“同一时间点只有一个任务在执行”。那有人可能就要问双核处理器呢？难道两个核不是同时运行吗？</p><p>其实“同一时间点只有一个任务在执行”这句话是不准确的，至少它是不全面的。那多核处理器的情况下，线程是怎样执行呢？这就需要了解内核线程。</p><p>多核(心)处理器是指在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。<br>内核线程（Kernel Thread，KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。</p><p>现在的电脑一般是双核四线程、四核八线程，是采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，所以在操作系统中看到的 CPU 数量是实际物理 CPU 数量的两倍，如你的电脑是双核四线程，打开“任务管理器\性能”可以看到 4 个 CPU 的监视器，四核八线程可以看到 8 个 CPU 的监视器。<br><img src="/blog/assets/os/task_manager.png" alt="task_manager"><br>超线程技术就是利用特殊的硬件指令，把一个物理芯片模拟成两个逻辑处理核心，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了 CPU 的闲置时间，提高的 CPU 的运行效率。这种超线程技术(如双核四线程)由处理器硬件的决定，同时也需要操作系统的支持才能在计算机中表现出来。</p><p>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Lightweight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，也被叫做用户线程。由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。用户线程与内核线程的对应关系有三种模型：一对一模型、多对一模型、多对多模型，在这以 4 个内核线程、3 个用户线程为例对三种模型进行说明。</p><h2 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h2><p>对于一对一模型来说，一个用户线程就唯一地对应一个内核线程(反过来不一定成立，一个内核线程不一定有对应的用户线程)。这样，如果 CPU 没有采用超线程技术(如四核四线程的计算机)，一个用户线程就唯一地映射到一个物理 CPU 的内核线程，线程之间的并发是真正的并发。一对一模型使用户线程具有与内核线程一样的优点，一个线程因某种原因阻塞时其他线程的执行不受影响；此处，一对一模型也可以让多线程程序在多处理器的系统上有更好的表现。</p><p>但一对一模型也有两个缺点：</p><ol><li>许多操作系统限制了内核线程的数量，因此一对一模型会使用户线程的数量受到限制；</li><li>许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。<br><img src="/blog/assets/os/one_on_one.png" alt="one_on_one"></li></ol><h2 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h2><p>多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，系统内核感受不到线程的实现方式。用户线程的建立、同步、销毁等都在用户态中完成，不需要内核的介入。因此相对一对一模型，多对一模型的线程上下文切换速度要快许多；此外，多对一模型对用户线程的数量几乎无限制。</p><p>但多对一模型也有两个缺点：</p><ol><li>如果其中一个用户线程阻塞，那么其它所有线程都将无法执行，因为此时内核线程也随之阻塞了；</li><li>在多处理器系统上，处理器数量的增加对多对一模型的线程性能不会有明显的增加，因为所有的用户线程都映射到一个处理器上了。<br><img src="/blog/assets/os/many_to_one.png" alt="many_to_one"></li></ol><h2 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h2><p>多对多模型结合了一对一模型和多对一模型的优点，将多个用户线程映射到多个内核线程上。由线程库负责在可用的可调度实体上调度用户线程，这使得线程的上下文切换非常快，因为它避免了系统调用。但是增加了复杂性和优先级倒置的可能性，以及在用户态调度程序和内核调度程序之间没有广泛（且高昂）协调的次优调度。</p><p>多对多模型的优点有：</p><ol><li>一个用户线程的阻塞不会导致所有线程的阻塞，因为此时还有别的内核线程被调度来执行；</li><li>多对多模型对用户线程的数量没有限制；</li><li>在多处理器的操作系统中，多对多模型的线程也能得到一定的性能提升，但提升的幅度不如一对一模型的高。<br><img src="/blog/assets/os/many_to_many.png" alt="many_to_many"></li></ol><p>在现在流行的操作系统中，大都采用多对多的模型。</p><h2 id="查看进程与线程"><a href="#查看进程与线程" class="headerlink" title="查看进程与线程"></a>查看进程与线程</h2><p>一个应用程序可能是多线程的，也可能是多进程的，如何查看呢？在 Windows 下我们只须打开任务管理器就能查看一个应用程序的进程和线程数。按“Ctrl+Alt+Del”或右键快捷工具栏打开任务管理器。</p><p>查看进程数和线程数：<br><img src="/blog/assets/os/check_processes.png" alt="check_processes"><br>在“进程”选项卡下，我们可以看到一个应用程序包含的线程数。如果一个应用程序有多个进程，我们能看到每一个进程，如在上图中，Google 的 Chrome 浏览器就有多个进程。同时，如果打开了一个应用程序的多个实例也会有多个进程，如上图中我打开了两个 cmd 窗口，就有两个 cmd 进程。如果看不到线程数这一列，可以再点击“查看\选择列”菜单，增加监听的列。</p><p>查看 CPU 和内存的使用率：</p><p>在性能选项卡中，我们可以查看 CPU 和内存的使用率，根据 CPU 使用记录的监视器的个数还能看出逻辑处理核心的个数，如我的双核四线程的计算机就有四个监视器。<br><img src="/blog/assets/os/check_performance.png" alt="check_performance"><br>线程的生命周期</p><p>当线程的数量小于处理器的数量时，线程的并发是真正的并发，不同的线程运行在不同的处理器上。但当线程的数量大于处理器的数量时，线程的并发会受到一些阻碍，此时并不是真正的并发，因为此时至少有一个处理器会运行多个线程。</p><p>在单个处理器运行多个线程时，并发是一种模拟出来的状态。操作系统采用时间片轮转的方式轮流执行每一个线程。现在，几乎所有的现代操作系统采用的都是时间片轮转的抢占式调度方式，如我们熟悉的 Unix、Linux、Windows 及 macOS 等流行的操作系统。</p><p>我们知道线程是程序执行的最小单位，也是任务执行的最小单位。在早期只有进程的操作系统中，进程有五种状态，创建、就绪、运行、阻塞(等待)、退出。早期的进程相当于现在的只有单个线程的进程，那么现在的多线程也有五种状态，现在的多线程的生命周期与早期进程的生命周期类似。<br><img src="/blog/assets/os/process_life_cycle.png" alt="process_life_cycle"><br>进程在运行过程有三种状态：就绪、运行、阻塞，创建和退出状态描述的是进程的创建过程和退出过程。</p><ul><li>创建：进程正在创建，还不能运行。操作系统在创建进程时要进行的工作包括分配和建立进程控制块表项、建立资源表格并分配资源、加载程序并建立地址空间；</li><li>就绪：时间片已用完，此线程被强制暂停，等待下一个属于它的时间片到来；</li><li>运行：此线程正在执行，正在占用时间片；</li><li>阻塞：也叫等待状态，等待某一事件(如 IO 或另一个线程)执行完；</li><li><p>退出：进程已结束，所以也称结束状态，释放操作系统分配的资源。<br><img src="/blog/assets/os/thread_lifecycle.png" alt="thread_lifecycle"></p></li><li><p>创建：一个新的线程被创建，等待该线程被调用执行；</p></li><li>就绪：时间片已用完，此线程被强制暂停，等待下一个属于它的时间片到来；</li><li>运行：此线程正在执行，正在占用时间片；</li><li>阻塞：也叫等待状态，等待某一事件(如 IO 或另一个线程)执行完；</li><li>退出：一个线程完成任务或者其他终止条件发生，该线程终止进入退出状态，退出状态释放该线程所分配的资源。</li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程，英文 Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p><p>因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（Fiber），或者绿色线程（GreenThread）。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。<br><img src="/blog/assets/os/process_thread_coroutine_relation.jpeg" alt="process_thread_coroutine_relation"></p><h2 id="协程的目的"><a href="#协程的目的" class="headerlink" title="协程的目的"></a>协程的目的</h2><p>在传统的 J2EE 系统中都是基于每个请求占用一个线程去完成完整的业务逻辑（包括事务）。所以系统的吞吐能力取决于每个线程的操作耗时。如果遇到很耗时的 I/O 行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。</p><p>最常见的例子就是 JDBC（它是同步阻塞的），这也是为什么很多人都说数据库是瓶颈的原因。这里的耗时其实是让 CPU 一直在等待 I/O 返回，说白了线程根本没有利用 CPU 去做运算，而是处于空转状态。而另外过多的线程，也会带来更多的 ContextSwitch 开销。</p><p>对于上述问题，现阶段行业里的比较流行的解决方案之一就是单线程加上异步回调。其代表派是 node.js 以及 Java 里的新秀 Vert.x。</p><p>而协程的目的就是当出现长时间的 I/O 操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除 ContextSwitch 上的开销。</p><h2 id="协程的特点"><a href="#协程的特点" class="headerlink" title="协程的特点"></a>协程的特点</h2><ol><li>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。</li><li>线程的默认 Stack 大小是 1M，而协程更轻量，接近 1K。因此可以在相同的内存中开启更多的协程。</li><li>由于在同一个线程上，因此可以避免竞争关系而使用锁。</li><li>适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。</li></ol><h2 id="协程的原理"><a href="#协程的原理" class="headerlink" title="协程的原理"></a>协程的原理</h2><p>当出现 IO 阻塞的时候，由协程的调度器进行调度，通过将数据流立刻 yield 掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑，这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为 coroutine，而跑在由 coroutine 负责调度的线程称为 Fiber。比如 Golang 里的 go 关键字其实就是负责开启一个 Fiber，让 func 逻辑跑在上面。</p><p>由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。<br>因此，协程的开销远远小于线程的开销，也就没有了 ContextSwitch 上的开销。</p><h2 id="协程和线程的比较"><a href="#协程和线程的比较" class="headerlink" title="协程和线程的比较"></a>协程和线程的比较</h2><table><thead><tr><th>比较项</th><th>线程</th><th>协程</th></tr></thead><tbody><tr><td>占用资源</td><td>初始单位为 1MB,固定不可变</td><td>初始一般为 2KB，可随需要而增大</td></tr><tr><td>调度所属</td><td>由 OS 的内核完成</td><td>由用户完成</td></tr><tr><td>切换开销</td><td>涉及模式切换(从用户态切换到内核态)、16 个寄存器、PC、SP…等</td><td>寄存器的刷新等 只有三个寄存器的值修改 - PC / SP / DX.</td></tr><tr><td>性能问题</td><td>资源占用太高，频繁创建销毁会带来严重的性能问题</td><td>资源占用小,不会带来严重的性能问题</td></tr><tr><td>数据同步</td><td>需要用锁等机制确保数据的一直性和可见性</td><td>不需要多线程的锁机制，因为只有一个线程,也不存在同时写变量冲突，在协程中控制 共享资源不加锁，只需要判断状就好了，所以执行效率比多线程高很多。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;我们都知道计算机的核心是 CPU，它承担了所有的计算任务；而操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序则是具有某种功能的程序，程序是运行于操作系统之上的。&lt;/p&gt;
&lt;p&gt;进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="操作系统" scheme="http://linthan.github.io/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Go语言interface底层实现</title>
    <link href="http://linthan.github.io/blog/2020/06/29/tech/golang/daiery-2020-0629-1700/"/>
    <id>http://linthan.github.io/blog/2020/06/29/tech/golang/daiery-2020-0629-1700/</id>
    <published>2020-06-29T09:00:00.000Z</published>
    <updated>2020-07-01T03:00:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>Go 的 interface 源码在 Golang 源码的 runtime 目录中。<br>Go 在不同版本之间的 interface 结构可能会有所不同，但是，整体的结构是不会改变的，此文章用的 Go 版本是 1.11。</p><a id="more"></a><p>Go 的 interface 是由两种类型来实现的：iface 和 eface。<br>其中，iface 表示的是包含方法的 interface，例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 eface 代表的是不包含方法的 interface，即</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person <span class="keyword">interface</span>&#123;&#125; = xxxx实体</span><br></pre></td></tr></table></figure><p>eface<br>eface 的具体结构是：<br><img src="/blog/assets/golang/channel/eface.png" alt="eface"><br>一共有两个属性构成，一个是类型信息_type，一个是数据信息。<br>其中，_type 可以认为是 Go 语言中所有类型的公共描述，Go 语言中几乎所有的数据结构都可以抽象成_type，是所有类型的表现，可以说是万能类型，<br>data 是指向具体数据的指针。</p><p>type 的具体代码为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">size       <span class="keyword">uintptr</span></span><br><span class="line">ptrdata    <span class="keyword">uintptr</span> <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">hash       <span class="keyword">uint32</span></span><br><span class="line">tflag      tflag</span><br><span class="line">align      <span class="keyword">uint8</span></span><br><span class="line">fieldalign <span class="keyword">uint8</span></span><br><span class="line">kind       <span class="keyword">uint8</span></span><br><span class="line">alg        *typeAlg</span><br><span class="line"><span class="comment">// gcdata stores the GC type data for the garbage collector.</span></span><br><span class="line"><span class="comment">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span></span><br><span class="line"><span class="comment">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></span><br><span class="line">gcdata    *<span class="keyword">byte</span></span><br><span class="line">str       nameOff</span><br><span class="line">ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eface 的整体结构是：<br><img src="/blog/assets/golang/channel/eface_all.png" alt="eface_all"></p><p>对于没有方法的 interface 赋值后的内部结构是怎样的呢？<br>可以先看段代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Binary <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">b := Binary(<span class="number">200</span>)</span><br><span class="line">any := (<span class="keyword">interface</span>&#123;&#125;)(b)</span><br><span class="line">fmt.Println(any)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 200，赋值后的结构图是这样的：<br><img src="/blog/assets/golang/channel/eface_fuzhi.png" alt="eface_fuzhi"></p><p>对于将不同类型转化成 type 万能结构的方法，是运行时的 convT2E 方法，在 runtime 包中。<br>以上，是对于没有方法的接口说明。<br>对于包含方法的函数，用到的是另外的一种结构，叫 iface</p><p>iface<br>所有包含方法的接口，都会使用 iface 结构。包含方法的接口就是一下这种最常见，最普通的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Person interface &#123;</span><br><span class="line">Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iface 的源代码是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type iface struct &#123;</span><br><span class="line">tab  *itab</span><br><span class="line">data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iface 的具体结构是：<br><img src="/blog/assets/golang/channel/iface.png" alt="iface"><br>itab 是 iface 不同于 eface 比较关键的数据结构。其可包含两部分：一部分是确定唯一的包含方法的 interface 的具体结构类型，一部分是指向具体方法集的指针。<br>具体结构为：<br><img src="/blog/assets/golang/channel/iface_itable.png" alt="iface_itable"><br>属性 itab 的源代码是：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">inter *interfacetype <span class="comment">//此属性用于定位到具体interface</span></span><br><span class="line">_type *_type <span class="comment">//此属性用于定位到具体interface</span></span><br><span class="line">hash  <span class="keyword">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">_     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">fun   [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized. fun[0]==0 means _type does not implement inter.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性 interfacetype 类似于_type，其作用就是 interface 的公共描述，类似的还有 maptype、arraytype、chantype…其都是各个结构的公共描述，可以理解为一种外在的表现信息。interfacetype 源码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">typ     _type</span><br><span class="line">pkgpath name</span><br><span class="line">mhdr    []imethod</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> imethod <span class="keyword">struct</span> &#123;</span><br><span class="line">name nameOff</span><br><span class="line">ityp typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iface 的整体结构为：<br><img src="/blog/assets/golang/channel/iface_all.png" alt="iface_all"></p><p>对于含有方法的 interface 赋值后的内部结构是怎样的呢？<br>一下代码运行后</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Binary <span class="keyword">uint64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Binary)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> strconv.FormatUint(i.Get(), <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Binary)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uint64</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">b := Binary(<span class="number">200</span>)</span><br><span class="line">any := fmt.Stringer(b)</span><br><span class="line">fmt.Println(any)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，要知道代码运行结果为:200。<br>其次，了解到 fmt.Stringer 是一个包含 String 方法的接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，赋值后接口 Stringer 的内部结构为：</p><p><img src="/blog/assets/golang/channel/iface_fuzhi.png" alt="iface_fuzhi"></p><p>参考文献：<br>《Go in action》<br><a href="https://research.swtch.com/interfaces" target="_blank" rel="noopener">https://research.swtch.com/interfaces</a><br><a href="https://juejin.im/entry/5a7d08d3f265da4e865a6200" target="_blank" rel="noopener">https://juejin.im/entry/5a7d08d3f265da4e865a6200</a><br><a href="https://i6448038.github.io/2018/10/01/Golang-interface/" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go 的 interface 源码在 Golang 源码的 runtime 目录中。&lt;br&gt;Go 在不同版本之间的 interface 结构可能会有所不同，但是，整体的结构是不会改变的，此文章用的 Go 版本是 1.11。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="golang" scheme="http://linthan.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang错题集</title>
    <link href="http://linthan.github.io/blog/2020/06/29/tech/golang/dairy-2020-0629-1519/"/>
    <id>http://linthan.github.io/blog/2020/06/29/tech/golang/dairy-2020-0629-1519/</id>
    <published>2020-06-29T07:19:00.000Z</published>
    <updated>2020-06-29T07:45:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>golang 错题集</p><a id="more"></a><h2 id="不要对-Go-并发函数的执行时机做任何假设"><a href="#不要对-Go-并发函数的执行时机做任何假设" class="headerlink" title="不要对 Go 并发函数的执行时机做任何假设"></a>不要对 Go 并发函数的执行时机做任何假设</h2><p>请看下列的列子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">names := []<span class="keyword">string</span>&#123;<span class="string">"lily"</span>, <span class="string">"yoyo"</span>, <span class="string">"cersei"</span>, <span class="string">"rose"</span>, <span class="string">"annei"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> names&#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(name)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问输出什么？</p><p>答案:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">annei</span><br><span class="line">annei</span><br><span class="line">annei</span><br><span class="line">annei</span><br><span class="line">annei</span><br></pre></td></tr></table></figure><p>为什么呢？是不是有点诧异？</p><p>输出的都是“annei”，而“annei”又是“names”的最后一个元素，那么也就是说程序打印出了最后一个元素的值，而 name 对于匿名函数来讲又是一个外部的值。因此，我们可以做一个推断：虽然每次循环都启用了一个协程，但是这些协程都是引用了外部的变量，当协程创建完毕，再执行打印动作的时候，name 的值已经不知道变为啥了，因为主函数协程也在跑，大家并行，但是在此由于 names 数组长度太小，当协程创建完毕后，主函数循环早已结束，所以，打印出来的都是遍历的 names 最后的那一个元素“annei”。<br>如何证实以上的推断呢？</p><p>其实很简单，每次循环结束后，停顿一段时间，等待协程打印当前的 name 便可。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">names := []<span class="keyword">string</span>&#123;<span class="string">"lily"</span>, <span class="string">"yoyo"</span>, <span class="string">"cersei"</span>, <span class="string">"rose"</span>, <span class="string">"annei"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> names&#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(name)</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lily</span><br><span class="line">yoyo</span><br><span class="line">cersei</span><br><span class="line">rose</span><br><span class="line">annei</span><br></pre></td></tr></table></figure><p>以上我们得出一个结论，不要对“go 函数”的执行时机做任何的假设，除非你确实能做出让这种假设成为绝对事实的保证。</p><h2 id="假设-T-类型的方法上接收器既有-T-类型的，又有T-指针类型的，那么就不可以在不能寻址的-T-值上调用T-接收器的方法"><a href="#假设-T-类型的方法上接收器既有-T-类型的，又有T-指针类型的，那么就不可以在不能寻址的-T-值上调用T-接收器的方法" class="headerlink" title="假设 T 类型的方法上接收器既有 T 类型的，又有T 指针类型的，那么就不可以在不能寻址的 T 值上调用T 接收器的方法"></a>假设 T 类型的方法上接收器既有 T 类型的，又有<em>T 指针类型的，那么就不可以在不能寻址的 T 值上调用</em>T 接收器的方法</h2><p>请看代码,试问能正常编译通过吗？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Lili <span class="keyword">struct</span>&#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili *Lili)</span> <span class="title">fmtPointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"poniter"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili Lili)</span> <span class="title">fmtReference</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"reference"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">li := Lili&#123;&#125;</span><br><span class="line">li.fmtPointer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">能正常编译通过，并输出&quot;poniter&quot;</span><br></pre></td></tr></table></figure><p>感觉有点诧异，请接着看以下的代码，试问能编译通过？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">type Lili struct&#123;</span><br><span class="line">Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (Lili *Lili) fmtPointer()&#123;</span><br><span class="line">fmt.Println(&quot;poniter&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (Lili Lili) fmtReference()&#123;</span><br><span class="line">fmt.Println(&quot;reference&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">Lili&#123;&#125;.fmtPointer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不能编译通过。</span><br><span class="line">“cannot call pointer method on Lili literal”</span><br><span class="line">“cannot take the address of Lili literal”</span><br></pre></td></tr></table></figure><p>是不是有点奇怪？这是为什么呢？其实在第一个代码示例中，main 主函数中的“li”是一个变量，li 的虽然是类型 Lili，但是 li 是可以寻址的，&amp;li 的类型是<em>Lili，因此可以调用</em>Lili 的方法。</p><h2 id="一个包含-nil-指针的接口不是-nil-接口"><a href="#一个包含-nil-指针的接口不是-nil-接口" class="headerlink" title="一个包含 nil 指针的接口不是 nil 接口"></a>一个包含 nil 指针的接口不是 nil 接口</h2><p>请看下列代码，试问返回什么</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debug = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line"><span class="keyword">if</span> debug&#123;</span><br><span class="line">buf = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">&#125;</span><br><span class="line">f(buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"surprise!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是输出：surprise。<br>ok，让我们吧 debug 开关关掉，及 debug 的值变为 false。那么输出什么呢？是不是什么都不输出？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debug = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line"><span class="keyword">if</span> debug&#123;</span><br><span class="line">buf = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">&#125;</span><br><span class="line">f(buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"surprise!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是：依然输出 surprise。</p><p>这是为什么呢？<br>这就牵扯到一个概念了，是关于接口值的。概念上讲一个接口的值分为两部分：一部分是类型，一部分是类型对应的值，他们分别叫：动态类型和动态值。类型系统是针对编译型语言的，类型是编译期的概念，因此类型不是一个值。<br>在上述代码中，给 f 函数的 out 参数赋了一个 *bytes.Buffer 的空指针，所以 out 的动态值是 nil。然而它的动态类型是 bytes.Buffer，意思是：“A non-nil interface containing a nil pointer”，所以“out!=nil”的结果依然是 true。<br>但是，对于直接的<code>bytes.Buffer</code>类型的判空不会出现此问题。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line"><span class="keyword">if</span> buf == <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"right"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是输出: right<br>只有 接口指针 传入函数的接口参数时，才会出现以上的坑。<br>修改起来也很方便，把*bytes.Buffer 改为 io.Writer 就好了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> debug = <span class="literal">false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buf  io.Writer <span class="comment">//原来是var buf *bytes.Buffer</span></span><br><span class="line"><span class="keyword">if</span> debug&#123;</span><br><span class="line">buf = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">&#125;</span><br><span class="line">f(buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"surprise!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将-map-转化为-json-字符串的时候，json-字符串中的顺序和-map-赋值顺序无关"><a href="#将-map-转化为-json-字符串的时候，json-字符串中的顺序和-map-赋值顺序无关" class="headerlink" title="将 map 转化为 json 字符串的时候，json 字符串中的顺序和 map 赋值顺序无关"></a>将 map 转化为 json 字符串的时候，json 字符串中的顺序和 map 赋值顺序无关</h2><p>请看下列代码，请问输出什么？若为 json 字符串，则 json 字符串中 key 的顺序是什么？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">params := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">params[<span class="string">"id"</span>] = <span class="string">"1"</span></span><br><span class="line">params[<span class="string">"id1"</span>] = <span class="string">"3"</span></span><br><span class="line">params[<span class="string">"controller"</span>] = <span class="string">"sections"</span></span><br><span class="line"></span><br><span class="line">data, _ := json.Marshal(params)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：输出{“controller”:”sections”,”id”:”1”,”id1”:”3”}<br>利用 Golang 自带的 json 转换包转换，会将 map 中 key 的顺序改为字母顺序，而不是 map 的赋值顺序。map 这个结构哪怕利用 for range 遍历的时候,其中的 key 也是无序的，可以理解为 map 就是个无序的结构，和 php 中的 array 要区分开来</p><h2 id="Json-反序列化数字到-interface-类型的值中，默认解析为-float64-类型"><a href="#Json-反序列化数字到-interface-类型的值中，默认解析为-float64-类型" class="headerlink" title="Json 反序列化数字到 interface{}类型的值中，默认解析为 float64 类型"></a>Json 反序列化数字到 interface{}类型的值中，默认解析为 float64 类型</h2><p>请看以下程序，程序想要输出 json 数据中整型 id 加上 3 的值,请问程序会报错吗？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">jsonStr := <span class="string">`&#123;"id":1058,"name":"RyuGou"&#125;`</span></span><br><span class="line"><span class="keyword">var</span> jsonData <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), &amp;jsonData)</span><br><span class="line"></span><br><span class="line">sum :=  jsonData[<span class="string">"id"</span>].(<span class="keyword">int</span>) + <span class="number">3</span></span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 答案是会报错，输出结果为：</span></span><br></pre></td></tr></table></figure><p>panic: interface conversion: interface {} is float64, not int</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 Golang 解析 JSON  格式数据时，若以 interface&#123;&#125; 接收数据，则会按照下列规则进行解析：</span><br></pre></td></tr></table></figure><p>bool, for JSON booleans</p><p>float64, for JSON numbers</p><p>string, for JSON strings</p><p>[]interface{}, for JSON arrays</p><p>map[string]interface{}, for JSON objects</p><p>nil for JSON null</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">jsonStr := <span class="string">`&#123;"id":1058,"name":"RyuGou"&#125;`</span></span><br><span class="line"><span class="keyword">var</span> jsonData <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), &amp;jsonData)</span><br><span class="line"></span><br><span class="line">sum :=  <span class="keyword">int</span>(jsonData[<span class="string">"id"</span>].(<span class="keyword">float64</span>)) + <span class="number">3</span></span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="即使在有多个变量、且有的变量存在有的变量不存在、且这些变量共同赋值的情况下，也不可以使用-来给全局变量赋值"><a href="#即使在有多个变量、且有的变量存在有的变量不存在、且这些变量共同赋值的情况下，也不可以使用-来给全局变量赋值" class="headerlink" title="即使在有多个变量、且有的变量存在有的变量不存在、且这些变量共同赋值的情况下，也不可以使用:=来给全局变量赋值"></a>即使在有多个变量、且有的变量存在有的变量不存在、且这些变量共同赋值的情况下，也不可以使用:=来给全局变量赋值</h2><p>:=往往是用来声明局部变量的，在多个变量赋值且有的值存在的情况下，:=也可以用来赋值使用,例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msgStr := &quot;hello wolrd&quot;</span><br><span class="line">msgStr, err := &quot;hello&quot;, errors.New(&quot;xxx&quot;)//err并不存在</span><br></pre></td></tr></table></figure><p>但是，假如全局变量也使用类似的方式赋值，就会出现问题，请看下列代码，试问能编译通过吗？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> varTest <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">varTest, err := function()</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">()</span><span class="params">(<span class="keyword">string</span>, error)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello world"</span>, errors.New(<span class="string">"error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是：通不过。输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">varTest declared and not used</span><br></pre></td></tr></table></figure><p>但是如果改成如下代码，就可以通过：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> varTest <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">err := errors.New(<span class="string">"error"</span>)</span><br><span class="line">varTest, err = function()</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">()</span><span class="params">(<span class="keyword">string</span>, error)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello world"</span>, errors.New(<span class="string">"error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error</span><br></pre></td></tr></table></figure><p>这是什么原因呢？<br>答案其实很简单，在 test 方法中，如果使用 varTest, err := function()这种方式的话，相当于在函数中又定义了一个和全局变量 varTest 名字相同的局部变量，而这个局部变量又没有使用，所以会编译不通过。</p><p><strong>interface 是一个指向 interface 的指针类型，而不是 interface 类型</strong><br>请问以下代码，能编译通过吗？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father <span class="keyword">interface</span> &#123;</span><br><span class="line">Hello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Child)</span><span class="title">Hello</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buf  Child</span><br><span class="line">buf = Child&#123;&#125;</span><br><span class="line">f(&amp;buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out *Father)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"surprise!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是：不能编译通过。输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*Father is pointer to interface, not interface</span><br></pre></td></tr></table></figure><p>注意了：接口类型的变量可以被赋值为实现接口的结构体的实例，但是并不能代表接口的指针可以被赋值为实现接口的结构体的指针实例。即：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf Father = Child&#123;&#125;</span><br></pre></td></tr></table></figure><p>是对的，但是</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf *Father = <span class="built_in">new</span>(Child)</span><br></pre></td></tr></table></figure><p>却是不对的。应该改为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf Father = Child&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> pointer *Father = &amp;buf</span><br></pre></td></tr></table></figure><p>要想让问题最开始的代码编译通过要将以上代码修改为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father <span class="keyword">interface</span> &#123;</span><br><span class="line">Hello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Child)</span><span class="title">Hello</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buf  Father</span><br><span class="line">buf = Child&#123;&#125;</span><br><span class="line">f(&amp;buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out *Father)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"surprise!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;golang 错题集&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="面试" scheme="http://linthan.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="golang" scheme="http://linthan.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>为什么Go语言不允许循环引入?</title>
    <link href="http://linthan.github.io/blog/2020/06/29/tech/golang/daiery-2020-0629-1011/"/>
    <id>http://linthan.github.io/blog/2020/06/29/tech/golang/daiery-2020-0629-1011/</id>
    <published>2020-06-29T02:11:00.000Z</published>
    <updated>2020-06-29T06:30:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>每当 Go 程序编译出现循环引入报错的时候就非常让人头疼。<br>那么，为什么 Go 不允许循环引入呢？</p><a id="more"></a><p>我觉得原因如下：</p><h2 id="搞清楚-package-包的定位"><a href="#搞清楚-package-包的定位" class="headerlink" title="搞清楚 package 包的定位"></a>搞清楚 package 包的定位</h2><p>首先，搞清楚 Go 语言中 package 包的定位；</p><p>Go 语言的 packa 和其他语言中的库、模块是相同的概念，在其他语言中，实现某个库或者模块需要建立”单独的项目”，而在 Go 中，仅仅是一个包就够了。<br>在正常 Coding 的时候，在我们项目中可以随便引入外来的项目(例如 PHP 项目引入 PHP 包)，但是，我们可以随意的修改引入的包吗？不可以！在我们写 PHP 的时候，我们可以引外来的包，并在引入的包中做修改，和现有项目循环依赖吗？更不可以！</p><p>从这个角度来讲，Go 语言不允许循环引入，算是合情合理的，因为 Go 中的 package 就是相当于其他语言中的“一个小项目”。</p><h2 id="语言设计层面"><a href="#语言设计层面" class="headerlink" title="语言设计层面"></a>语言设计层面</h2><p>第二，我们考虑一下，循环引入可能带来的坏处。</p><p>曾经有人提议 Go 语言作者 Rob Pike，想要在 Go 以后的版本去掉循环引入；Rob Pike 坚决不同意。Rob Pike 觉得假如你两个包之间存在循环引入的问题，那一定是你在设计之初就没考虑好模块的划分。</p><p>我们试想，假如允许循环引入，那么，模块和模块之间就存在相互的调用，随着项目的推进，模块之间的依赖关系越来越多，最后导致俩模块耦合性变的很高，最初模块之间的界限变的越来越模糊，最后都偶合在一起了，变的一团糟。一个好的设计，一个好的模块的划分，就不应该存在循环依赖的问题！</p><p>因此，Go 语言在设计之初，就强制要求不允许循环引入，这会迫使开发者在写代码之前就考虑模块与模块之间的依赖关系，保持依赖关系的整洁。否则，允许循环引入，虽然带来了 coding 的方便，但是从工程的长远角度来考虑，对整个工程的构建、代码的整洁都是非常不利的。</p><h2 id="其他原因"><a href="#其他原因" class="headerlink" title="其他原因"></a>其他原因</h2><p>最后一点，禁止循环引入会让编译变的更高效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每当 Go 程序编译出现循环引入报错的时候就非常让人头疼。&lt;br&gt;那么，为什么 Go 不允许循环引入呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="golang" scheme="http://linthan.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go并发原理</title>
    <link href="http://linthan.github.io/blog/2020/05/01/tech/golang/daiery-2020-0501-1200/"/>
    <id>http://linthan.github.io/blog/2020/05/01/tech/golang/daiery-2020-0501-1200/</id>
    <published>2020-05-01T04:00:00.000Z</published>
    <updated>2020-06-29T07:28:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言是为并发而生的语言，Go 语言是为数不多的在语言层面实现并发的语言；也正是 Go 语言的并发特性，吸引了全球无数的开发者。</p><a id="more"></a><h2 id="并发-concurrency-和并行-parallellism"><a href="#并发-concurrency-和并行-parallellism" class="headerlink" title="并发(concurrency)和并行(parallellism)"></a>并发(concurrency)和并行(parallellism)</h2><p><strong>并发(concurrency)</strong>：两个或两个以上的任务在一段时间内被执行。我们不必 care 这些任务在某一个时间点是否是同时执行，可能同时执行，也可能不是，我们只关心在一段时间内，哪怕是很短的时间（一秒或者两秒）是否执行解决了两个或两个以上任务。</p><p>并行(parallellism)：两个或两个以上的任务在同一时刻被同时执行。</p><p>并发说的是逻辑上的概念，而并行，强调的是物理运行状态。并发“包含”并行。<br>（详情请见：Rob Pike 的 <a href="https://talks.golang.org/2012/concurrency.slide#1" target="_blank" rel="noopener">PPT</a>）</p><h2 id="Go-的-CSP-并发模型"><a href="#Go-的-CSP-并发模型" class="headerlink" title="Go 的 CSP 并发模型"></a>Go 的 CSP 并发模型</h2><p>Go 实现了两种并发形式。第一种是大家普遍认知的：多线程共享内存。其实就是 Java 或者 C++等语言中的多线程开发。另外一种是 Go 语言特有的，也是 Go 语言推荐的：CSP（communicating sequential processes）并发模型。</p><p>CSP 并发模型是在 1970 年左右提出的概念，属于比较新的概念，不同于传统的多线程通过共享内存来通信，CSP 讲究的是“以通信的方式来共享内存”。</p><p>请记住下面这句话：</p><p><strong>Do not communicate by sharing memory; instead, share memory by communicating.</strong></p><p>“不要以共享内存的方式来通信，相反，要通过通信来共享内存。”</p><p>普通的线程并发模型，就是像 Java、C++、或者 Python，他们线程间通信都是通过共享内存的方式来进行的。非常典型的方式就是，在访问共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问，因此，在很多时候，衍生出一种方便操作的数据结构，叫做“线程安全的数据结构”。例如 Java 提供的包”java.util.concurrent”中的数据结构。Go 中也实现了传统的线程并发模型。</p><p>Go 的 CSP 并发模型，是通过 goroutine 和 channel 来实现的。</p><ul><li>goroutine 是 Go 语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。</li><li>channel 是 Go 语言中各个并发结构体(goroutine)之前的通信机制。 通俗的讲，就是各个 goroutine 之间通信的”管道“，有点类似于 Linux 中的管道。</li></ul><p>生成一个 goroutine 的方式非常的简单：Go 一下，就生成了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> f();</span><br></pre></td></tr></table></figure><p><strong>通信机制 channel 也很方便，传数据用 channel &lt;- data，取数据用&lt;-channel。</strong></p><p>在通信过程中，传数据 channel &lt;- data 和取数据&lt;-channel 必然会成对出现，因为这边传，那边取，两个 goroutine 之间才会实现通信。</p><p>而且不管传还是取，必阻塞，直到另外的 goroutine 传或者取为止。</p><p>有两个 goroutine，其中一个发起了向 channel 中发起了传值操作。（goroutine 为矩形，channel 为箭头）<br><img src="/blog/assets/golang/channel/send.png" alt="send"></p><p>左边的 goroutine 开始阻塞，等待有人接收。</p><p>这时候，右边的 goroutine 发起了接收操作。<br><img src="/blog/assets/golang/channel/accept.png" alt="accept"><br>右边的 goroutine 也开始阻塞，等待别人传送。</p><p>这时候，两边 goroutine 都发现了对方，于是两个 goroutine 开始一传，一收。<br><img src="/blog/assets/golang/channel/communicate.png" alt="communicate"><br>这便是 Golang CSP 并发模型最基本的形式。</p><h2 id="Go-并发模型的实现原理"><a href="#Go-并发模型的实现原理" class="headerlink" title="Go 并发模型的实现原理"></a>Go 并发模型的实现原理</h2><p>我们先从线程讲起，无论语言层面何种并发模型，到了操作系统层面，一定是以线程的形态存在的。而操作系统根据资源访问权限的不同，体系架构可分为用户空间和内核空间；内核空间主要操作访问 CPU 资源、I/O 资源、内存资源等硬件资源，为上层应用程序提供最基本的基础资源，用户空间呢就是上层应用程序的固定活动空间，用户空间不可以直接访问资源，必须通过“系统调用”、“库函数”或“Shell 脚本”来调用内核空间提供的资源。</p><p>我们现在的计算机语言，可以狭义的认为是一种“软件”，它们中所谓的“线程”，往往是用户态的线程，和操作系统本身内核态的线程（简称 KSE），还是有区别的。</p><p>线程模型的实现，可以分为以下几种方式：</p><h3 id="用户级线程模型"><a href="#用户级线程模型" class="headerlink" title="用户级线程模型"></a>用户级线程模型</h3><p><img src="/blog/assets/golang/channel/yonghutai.png" alt="yonghutai"><br>如图所示，多个用户态的线程对应着一个内核线程，程序线程的创建、终止、切换或者同步等线程工作必须自身来完成。</p><h3 id="内核级线程模型"><a href="#内核级线程模型" class="headerlink" title="内核级线程模型"></a>内核级线程模型</h3><p><img src="/blog/assets/golang/channel/neiheji.png" alt="neiheji"><br>这种模型直接调用操作系统的内核线程，所有线程的创建、终止、切换、同步等操作，都由内核来完成。C++就是这种。</p><h3 id="两级线程模型"><a href="#两级线程模型" class="headerlink" title="两级线程模型"></a>两级线程模型</h3><p><img src="/blog/assets/golang/channel/liangji.png" alt="liangji"></p><p>这种模型是介于用户级线程模型和内核级线程模型之间的一种线程模型。这种模型的实现非常复杂，和内核级线程模型类似，一个进程中可以对应多个内核级线程，但是进程中的线程不和内核线程一一对应；这种线程模型会先创建多个内核级线程，然后用自身的用户级线程去对应创建的多个内核级线程，自身的用户级线程需要本身程序去调度，内核级的线程交给操作系统内核去调度。</p><p>Go 语言的线程模型就是一种特殊的两级线程模型。暂且叫它“MPG”模型吧。</p><h2 id="Go-线程实现模型-MPG"><a href="#Go-线程实现模型-MPG" class="headerlink" title="Go 线程实现模型 MPG"></a>Go 线程实现模型 MPG</h2><ul><li><p>M 指的是 Machine，一个 M 直接关联了一个内核线程。</p></li><li><p>P 指的是”processor”，代表了 M 所需的上下文环境，也是处理用户级代码逻辑的处理器。</p></li><li><p>G 指的是 Goroutine，其实本质上也是一种轻量级的线程。</p></li></ul><p>三者关系如下图所示：<br><img src="/blog/assets/golang/channel/GMPrelation.png" alt="GMPrelation"></p><p>以上这个图讲的是两个线程(内核线程)的情况。一个 M 会对应一个内核线程，一个 M 也会连接一个上下文 P，一个上下文 P 相当于一个“处理器”，一个上下文连接一个或者多个 Goroutine。P(Processor)的数量是在启动时被设置为环境变量 GOMAXPROCS 的值，或者通过运行时调用函数 runtime.GOMAXPROCS()进行设置。Processor 数量固定意味着任意时刻只有固定数量的线程在运行 go 代码。Goroutine 中就是我们要执行并发的代码。图中 P 正在执行的 Goroutine 为蓝色的；处于待执行状态的 Goroutine 为灰色的，灰色的 Goroutine 形成了一个队列 runqueues</p><p>三者关系的宏观的图为：</p><p><strong>抛弃 P(Processor)</strong></p><p>你可能会想，为什么一定需要一个上下文，我们能不能直接除去上下文，让 Goroutine 的 runqueues 挂到 M 上呢？答案是不行，需要上下文的目的，是让我们可以直接放开其他线程，当遇到内核线程阻塞的时候。</p><p>一个很简单的例子就是系统调用 sysall，一个线程肯定不能同时执行代码和系统调用被阻塞，这个时候，此线程 M 需要放弃当前的上下文环境 P，以便可以让其他的 Goroutine 被调度执行。</p><p><img src="/blog/assets/golang/channel/giveupP.png" alt="giveupP"><br>如上图左图所示，M0 中的 G0 执行了 syscall，然后就创建了一个 M1(也有可能本身就存在，没创建)，（转向右图）然后 M0 丢弃了 P，等待 syscall 的返回值，M1 接受了 P，将·继续执行 Goroutine 队列中的其他 Goroutine。</p><p>当系统调用 syscall 结束后，M0 会“偷”一个上下文，如果不成功，M0 就把它的 Gouroutine G0 放到一个全局的 runqueue 中，然后自己放到线程池或者转入休眠状态。全局 runqueue 是各个 P 在运行完自己的本地的 Goroutine runqueue 后用来拉取新 goroutine 的地方。P 也会周期性的检查这个全局 runqueue 上的 goroutine，否则，全局 runqueue 上的 goroutines 可能得不到执行而饿死。</p><p><strong>均衡的分配工作</strong></p><p>按照以上的说法，上下文 P 会定期的检查全局的 goroutine 队列中的 goroutine，以便自己在消费掉自身 Goroutine 队列的时候有事可做。假如全局 goroutine 队列中的 goroutine 也没了呢？就从其他运行的中的 P 的 runqueue 里偷。</p><p>每个 P 中的 Goroutine 不同导致他们运行的效率和时间也不同，在一个有很多 P 和 M 的环境中，不能让一个 P 跑完自身的 Goroutine 就没事可做了，因为或许其他的 P 有很长的 goroutine 队列要跑，得需要均衡。<br>该如何解决呢？</p><p>Go 的做法倒也直接，从其他 P 中偷一半！</p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ol><li><a href="https://morsmachine.dk/go-scheduler" target="_blank" rel="noopener">The Go scheduler</a></li><li>《Go 并发编程第一版》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go 语言是为并发而生的语言，Go 语言是为数不多的在语言层面实现并发的语言；也正是 Go 语言的并发特性，吸引了全球无数的开发者。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="golang" scheme="http://linthan.github.io/blog/tags/golang/"/>
    
      <category term="并发编程" scheme="http://linthan.github.io/blog/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>好好学习天天向上</title>
    <link href="http://linthan.github.io/blog/2019/04/02/xinqing/dairy-2019-0401-0402/"/>
    <id>http://linthan.github.io/blog/2019/04/02/xinqing/dairy-2019-0401-0402/</id>
    <published>2019-04-02T02:40:00.000Z</published>
    <updated>2020-06-29T05:53:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近有一点点小焦虑。初略一算,自己都快工作两年了。然而自己的技术积累和生活状态远没有达到自己的预期。现在每天晚上都会逛 github 逛很久。发现蚂蚁金服团队的一些大牛，非常兴奋。每天看看大佬们在看什么，然后把这些项目荡下来，看看里面的东西。</p>  <a id="more"></a><p>自己虽然是一个后端工程师，但是在公司里面干了不少前端的活。对于前端的技术栈还是有一些了解。发现这些大牛后，真的是非常兴奋，感觉发现新大陆。非常想给他们提 issue。 今天就做了这个尝试，感觉自己的头像和大牛碰在一起的感觉贼棒。 今天还给语雀的一个项目提了一个 pull request。 突然发现自己好像中了一种叫开源的读。 虽然自己的能力还不是足够的强大，但是我已经找到了和强大的人沟通的方式了。 非常的有趣，这个真的是我空虚精神中的一个非常大不补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有一点点小焦虑。初略一算,自己都快工作两年了。然而自己的技术积累和生活状态远没有达到自己的预期。现在每天晚上都会逛 github 逛很久。发现蚂蚁金服团队的一些大牛，非常兴奋。每天看看大佬们在看什么，然后把这些项目荡下来，看看里面的东西。&lt;/p&gt;
    
    </summary>
    
    
      <category term="发骚" scheme="http://linthan.github.io/blog/tags/%E5%8F%91%E9%AA%9A/"/>
    
  </entry>
  
  <entry>
    <title>接口加密鉴权</title>
    <link href="http://linthan.github.io/blog/2019/03/01/tech/security/dairy-2019-0301-0302/"/>
    <id>http://linthan.github.io/blog/2019/03/01/tech/security/dairy-2019-0301-0302/</id>
    <published>2019-03-01T02:36:00.000Z</published>
    <updated>2020-06-19T08:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>先抽象的描述一下使用场景吧。客户端请求服务端获取系统资源的时候，会存在接口劫持篡改发回服务的数据。于是客户端就可以获取付费的本地使用特效，<br>包括付费皮肤,书籍,本地游戏特效等等。</p><h2 id="具体实践"><a href="#具体实践" class="headerlink" title="具体实践"></a>具体实践</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><ul><li><a href="https://baike.baidu.com/item/base64/8545775?fr=aladdin" title="base64 编码" target="_blank" rel="noopener">base64 编码 【中文】</a></li><li><a href="https://en.wikipedia.org/wiki/Base64" title="base64 编码" target="_blank" rel="noopener">base64 编码 【english】</a></li><li><a href="https://en.wikipedia.org/wiki/MD5" title="md5 加密" target="_blank" rel="noopener">md5 加密 【english】</a></li><li><a href="https://baike.baidu.com/item/MD5/212708?fr=aladdin" title="md5 加密" target="_blank" rel="noopener">md5 加密【中文】</a><a id="more"></a></li></ul><h3 id="具体使用场景"><a href="#具体使用场景" class="headerlink" title="具体使用场景"></a>具体使用场景</h3><p>app 客户端推出了一个一键换肤的功能,考虑到这个换肤的功能后期会存在付费的功能,还可能会计算挂钩的收益结算，需要的皮肤这种资源进行保护。<br>如果不进行保护的话会存在如下风险。</p><ul><li>用户通过篡改接口来更换皮肤包资源可以自己随意定制皮肤包。如果教程公布到网上，这样第三方的山寨皮肤包就会盛行。绕过审核，产生抹黑公司形象和难以想象的法律风险。</li><li>用户只要懂得抓包和接口劫持篡改的知识，就可以将网上流传的付费皮肤包资源篡改到付费皮肤包的网络请求中去。达到免费使用付费皮肤的目的。</li></ul><h3 id="具体操作方法"><a href="#具体操作方法" class="headerlink" title="具体操作方法"></a>具体操作方法</h3><p><strong>问题：</strong> 客户端需要相信接口下发的数据是真实的，接口端的数据不能被篡改，一旦被篡改客户端可以感知的到。</p><p><strong>思路：</strong> 客户端传一个随机字符串给服务端，服务端接受到请求后再参数一个随机字符串，根据这两个字符串加上需要返回的数据再加上约定要的秘钥 key 生成一个签名<br>然后将这个签名和服务端的随机数和需要传递的数据传递客户端，客户端根据这些数据来校验这个签名是否合法。</p><p><strong>代码 demo</strong>:<a href="https://github.com/linthan/encryptapi-demo" title="demo" target="_blank" rel="noopener">点我</a></p><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>返回的数据一般是 json 格式的数据，计算签名的时候需要使用 json 格式数据的字符串，经过 base64 编码以后的字符串来计算 sign。传递数据给客户端的数据是这个 base64 编码字符串。<br><strong>理由如下：</strong><br>实际操作中会存在服务端 json 字符串和客户端 json 字符串经过网络传输以后数据不一致的情况,计算的 sign 会不一致。直接使用 json 字符串，还有不必要的字符串转义的烦恼。</p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="/blog/assets/blogImg/security/dairy-20190301.png" alt></p><h4 id="接口格式"><a href="#接口格式" class="headerlink" title="接口格式"></a>接口格式</h4><p><strong>请求参数</strong>：</p><table><thead><tr><th>参数名</th><th>字段解释</th><th>字段类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>id</td><td>int</td><td>0</td><td>大于 0</td></tr><tr><td>ver</td><td>版本</td><td>int</td><td>0</td><td>大于 0</td></tr><tr><td>r</td><td>随机字符串</td><td>string</td><td>“”</td><td>长度 16</td></tr></tbody></table><p><strong>返回格式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;error&quot;: 0, // 一直为0</span><br><span class="line">    &quot;msg&quot;: &quot;ok&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">    &quot;e&quot;: 0, // 真实error值</span><br><span class="line">        &quot;r&quot;: &quot;uk!cntZs)qk+t&amp;gF&quot;,// 随机字符串</span><br><span class="line">        &quot;s&quot;: &quot;3eee660f7728b411a96b9a14cd8d2be6&quot;, // 签名</span><br><span class="line">        &quot;data&quot;: &quot;base64 字符串&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;先抽象的描述一下使用场景吧。客户端请求服务端获取系统资源的时候，会存在接口劫持篡改发回服务的数据。于是客户端就可以获取付费的本地使用特效，&lt;br&gt;包括付费皮肤,书籍,本地游戏特效等等。&lt;/p&gt;
&lt;h2 id=&quot;具体实践&quot;&gt;&lt;a href=&quot;#具体实践&quot; class=&quot;headerlink&quot; title=&quot;具体实践&quot;&gt;&lt;/a&gt;具体实践&lt;/h2&gt;&lt;h3 id=&quot;背景知识&quot;&gt;&lt;a href=&quot;#背景知识&quot; class=&quot;headerlink&quot; title=&quot;背景知识&quot;&gt;&lt;/a&gt;背景知识&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://baike.baidu.com/item/base64/8545775?fr=aladdin&quot; title=&quot;base64 编码&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;base64 编码 【中文】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Base64&quot; title=&quot;base64 编码&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;base64 编码 【english】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/MD5&quot; title=&quot;md5 加密&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;md5 加密 【english】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://baike.baidu.com/item/MD5/212708?fr=aladdin&quot; title=&quot;md5 加密&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;md5 加密【中文】&lt;/a&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="安全" scheme="http://linthan.github.io/blog/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>潜心下来，考虑未来</title>
    <link href="http://linthan.github.io/blog/2019/01/26/xinqing/dairy-2019-0226-0302/"/>
    <id>http://linthan.github.io/blog/2019/01/26/xinqing/dairy-2019-0226-0302/</id>
    <published>2019-01-26T01:42:00.000Z</published>
    <updated>2020-06-19T08:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近负能量爆棚。成人的世界里面，有些事情总是要自己独自消化。生活的各种事情让你就是不能活在自己想要生活的轨道上。说的是要生活的勇往向前，但是面对现实总是活得像一个鸵鸟，头埋的深深的。</p><p>愿早日度过低谷期。生活还有很多角落需要我来探索，没有时间停下脚步考虑太多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近负能量爆棚。成人的世界里面，有些事情总是要自己独自消化。生活的各种事情让你就是不能活在自己想要生活的轨道上。说的是要生活的勇往向前，但是面对现实总是活得像一个鸵鸟，头埋的深深的。&lt;/p&gt;
&lt;p&gt;愿早日度过低谷期。生活还有很多角落需要我来探索，没有时间停下脚步考虑太多。&lt;
      
    
    </summary>
    
    
      <category term="发骚" scheme="http://linthan.github.io/blog/tags/%E5%8F%91%E9%AA%9A/"/>
    
  </entry>
  
  <entry>
    <title>golang并发安全性Map</title>
    <link href="http://linthan.github.io/blog/2018/10/06/tech/golang/dairy-2018-1006-1007/"/>
    <id>http://linthan.github.io/blog/2018/10/06/tech/golang/dairy-2018-1006-1007/</id>
    <published>2018-10-06T14:10:00.000Z</published>
    <updated>2020-06-19T08:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>在 golang 并发编程中会常常设计到操作 map。 如何高性能的使用 map 就是本篇文章的目的</p></blockquote><a id="more"></a><p><strong>对整个 map 加读锁</strong></p><p>让 map 的读写在并发下安全，最容易想到的就是下面这种，直接在 struct 里内嵌读写锁</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    Counter <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//read</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SafeMap)</span><span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">    m.Rlock()</span><br><span class="line">    <span class="keyword">defer</span> m.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> m.Counter[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//write</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SafeMap)</span><span class="title">Set</span><span class="params">(key <span class="keyword">string</span>,count <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    m.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.Unlock()</span><br><span class="line">    m.Counter[key] = count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样加了读写锁后，整个 SafeMap 的实例在并发读写的时候就能保持数据一致了，能满足大部分常见的需求。<br>但是，它在一些场景下也有问题，对 SafeMap 中任意的 key 进行修改的时候，同一时刻只有一把读写锁在工作，这样就会导致当大量并发读写 key=a 的元素时，会堵塞对 key=b 的读写，key 越多时，key 之间的竞争会加剧这种情况。这把读写锁此时就会成为性能的瓶颈。熟悉 Java 的同学，可以对比一下 java 的 ConcurrentHashMap，在 map 的数据非常大的情况下，一把锁会导致大并发的客户端共争一把锁，Java 的解决方案是 shard, 内部使用多个锁，每个区间共享一把锁，这样减少了数据共享一把锁带来的性能影响。<br>本次需求中，刚好满足这样的场景，map 初始化的时候知道所有具体的 key（即 rpc 路由名称），这样就可以很方便的把这把大锁拆成与每个 key 对应的小锁，在并发时每个 key 的读写相互独立不堵塞。<br>对 map 中每个 key 加以吧读写锁</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SafeFastMap <span class="keyword">struct</span> &#123;</span><br><span class="line">syncMap <span class="keyword">map</span>[<span class="keyword">string</span>]*syncSturct</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> syncSturct <span class="keyword">struct</span> &#123;</span><br><span class="line">sync.RWMutex</span><br><span class="line">count     <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序启动时会初始化syncMap，只在程序启动时写入一次，程序运行时只读，所以syncMap不加锁也是并发安全的</span></span><br><span class="line"><span class="comment">//read</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SafeFastMap)</span><span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">    m.syncMap[key].RLock()</span><br><span class="line">    <span class="keyword">defer</span> m.syncMap[key].RUnlock</span><br><span class="line">    <span class="keyword">return</span> m.syncMap[key].count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//write</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SafeFastMap)</span><span class="title">Set</span><span class="params">(key <span class="keyword">string</span>,count <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    m.syncMap[key].Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.syncMap[key].Unlock</span><br><span class="line">    m.syncMap[key].count = count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>go1.9 中并发安全的 map</strong><br>开发中并不常有能像上面那样运行时只写入一次 map 的场景，所以更多的场景还是要手动对 map 加锁。 go1.9 在 sync 包中新增了并发安全的 map，无需我们自己手动加锁直接调用 Load、Store 方法即可。但是使用的时候需要做类型断言，也没有 api 直接获取 map 的 Len，这两点比较蛋疼。。。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"><span class="comment">//init</span></span><br><span class="line"><span class="keyword">var</span> m sync.Map</span><br><span class="line"><span class="comment">//读取存储在map中的值，如果没有值，则返回nil。OK的结果表示是否在map中找到值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;,<span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function">//存储一个设置的键值。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//返回键的现有值<span class="params">(如果存在)</span>，否则存储并返回给定的值，如果是读取则返回<span class="title">true</span>，如果是存储返回<span class="title">false</span>。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(m *Map)</span> <span class="title">LoadOrStore</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(actual <span class="keyword">interface</span>&#123;&#125;, loaded <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//删除键对应的值。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//循环读取<span class="title">map</span>中的值。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(m *Map)</span> <span class="title">Range</span><span class="params">(f <span class="keyword">func</span>(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在 golang 并发编程中会常常设计到操作 map。 如何高性能的使用 map 就是本篇文章的目的&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="golang" scheme="http://linthan.github.io/blog/tags/golang/"/>
    
      <category term="并发编程" scheme="http://linthan.github.io/blog/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="安全" scheme="http://linthan.github.io/blog/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>扯清同步IO、异步IO、阻塞IO和非阻塞IO的关系</title>
    <link href="http://linthan.github.io/blog/2018/10/05/tech/unix/dairy-2018-1005-1011/"/>
    <id>http://linthan.github.io/blog/2018/10/05/tech/unix/dairy-2018-1005-1011/</id>
    <published>2018-10-05T02:36:00.000Z</published>
    <updated>2020-07-01T08:06:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="扯清同步-IO、异步-IO、阻塞-IO-和非阻塞-IO-的关系"><a href="#扯清同步-IO、异步-IO、阻塞-IO-和非阻塞-IO-的关系" class="headerlink" title="扯清同步 IO、异步 IO、阻塞 IO 和非阻塞 IO 的关系"></a>扯清同步 IO、异步 IO、阻塞 IO 和非阻塞 IO 的关系</h3><p>上面的这些名词经常会出现在各种博客，面试问题中。为了让我扯清这几个名词的关系，特意写了这篇博客。<br><strong>POSIX</strong>：可移植操作系统接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POSIX把同步IO操作定义为导致进程阻塞直到IO完成操作，反之则是异步IO</span><br></pre></td></tr></table></figure><p>上面的这个定义非常重要，这个定义是搞清同步非阻塞 IO 的关键。</p><a id="more"></a><h3 id="IO-模型"><a href="#IO-模型" class="headerlink" title="IO 模型"></a>IO 模型</h3><p>Linux 系统调用 recv 的例子，他用于从套接字上接收一个消息，因为是一个系统调用，所以调用时会从用户进程空间切换到内核空间运行一段时间再切换回来。默认情况下 recv 会等到网络数据到达并且复制到用户进程空间或者发生错误时返回。 请主意，这里涉及到 IO 的两个阶段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.数据准备阶段</span><br><span class="line">2.内核空间复制回用户进程缓冲区阶段</span><br></pre></td></tr></table></figure><p>根据 POSIX 的定义阶段 2 是否导致请求进程阻塞来判断是同步 IO 还是异步 IO。而阻塞和非阻塞是对于在数据准备好之前，进程是否可以区干别的事情。一个请求来了，必须一直阻塞等待结果，在这期间不接受新的请求，这个是阻塞。如果一个请求来了，如果数据没有好，等数据准备好了再服务这个请求。再这期间会接受新的请求。</p><ul><li>阻塞 IO 模型<br>使用 recv 的默认参数一直等数据直到拷贝到用户空间，这段时间内进程始终阻塞。A 同学用杯子装水，打开水龙头装满水然后离开。这一过程就可以看成是使用了阻塞 IO 模型，因为如果水龙头没有水，他也要等到有水并装满杯子才能离开去做别的事情。很显然，这种 IO 模型是同步的。</li><li>非阻塞 IO 模型<br>改变 flags，让 recv 不管有没有获取到数据都返回，如果没有数据那么一段时间后再调用 recv 看看，如此循环。B 同学也用杯子装水，打开水龙头后发现没有水，它离开了，过一会他又拿着杯子来看看……在中间离开的这些时间里，B 同学离开了装水现场(回到用户进程空间)，可以做他自己的事情。这就是非阻塞 IO 模型。但是它只有是检查无数据的时候是非阻塞的，在数据到达的时候依然要等待复制数据到用户空间(等着水将水杯装满)，因此它还是同步 IO。</li><li>IO 复用模型<br>这里在调用 recv 前先调用 select 或者 poll，这 2 个系统调用都可以在内核准备好数据(网络数据到达内核)时告知用户进程，这个时候再调用 recv 一定是有数据的。因此这一过程中它是阻塞于 select 或 poll，而没有阻塞于 recv，有人将非阻塞 IO 定义成在读写操作时没有阻塞于系统调用的 IO 操作(不包括数据从内核复制到用户空间时的阻塞，因为这相对于网络 IO 来说确实很短暂)，如果按这样理解，这种 IO 模型也能称之为非阻塞 IO 模型，但是按 POSIX 来看，它也是同步 IO，那么也和楼上一样称之为同步非阻塞 IO 吧。这种 IO 模型比较特别，分个段。因为它能同时监听多个文件描述符(fd)。这个时候 C 同学来装水，发现有一排水龙头，舍管阿姨告诉他这些水龙头都还没有水，等有水了告诉他。于是等啊等(select 调用中)，过了一会阿姨告诉他有水了，但不知道是哪个水龙头有水，自己看吧。于是 C 同学一个个打开，往杯子里装水(recv)。这里再顺便说说鼎鼎大名的 epoll(高性能的代名词啊)，epoll 也属于 IO 复用模型，主要区别在于舍管阿姨会告诉 C 同学哪几个水龙头有水了，不需要一个个打开看(当然还有其它区别)。</li><li>信号驱动 IO 模型<br>通过调用 sigaction 注册信号函数，等内核数据准备好的时候系统中断当前程序，执行信号函数(在这里面调用 recv)。D 同学让舍管阿姨等有水的时候通知他(注册信号函数)，没多久 D 同学得知有水了，跑去装水。是不是很像异步 IO？很遗憾，它还是同步 IO(省不了装水的时间啊)。 这个很容易误判为异步 IO，因为异步 IO 模型实现也是基于信号来通知应用进程来读取数据的。但是真正的异步 IO 模型是把数据从内核复制到用户进程空间这部分的操作也完成来，然后让应用进程来处理数据。所以这个操作依旧是同步 IO</li><li>异步 IO 模型<br>调用 aio_read，让内核等数据准备好，并且复制到用户进程空间后执行事先指定好的函数。E 同学让舍管阿姨将杯子装满水后通知他。整个过程 E 同学都可以做别的事情(没有 recv)，这才是真正的异步 IO。</li></ul><p><strong>ps</strong></p><p>以上内容全部来自于 UNIX 网络编程卷 1</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;扯清同步-IO、异步-IO、阻塞-IO-和非阻塞-IO-的关系&quot;&gt;&lt;a href=&quot;#扯清同步-IO、异步-IO、阻塞-IO-和非阻塞-IO-的关系&quot; class=&quot;headerlink&quot; title=&quot;扯清同步 IO、异步 IO、阻塞 IO 和非阻塞 IO 的关系&quot;&gt;&lt;/a&gt;扯清同步 IO、异步 IO、阻塞 IO 和非阻塞 IO 的关系&lt;/h3&gt;&lt;p&gt;上面的这些名词经常会出现在各种博客，面试问题中。为了让我扯清这几个名词的关系，特意写了这篇博客。&lt;br&gt;&lt;strong&gt;POSIX&lt;/strong&gt;：可移植操作系统接口&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;POSIX把同步IO操作定义为导致进程阻塞直到IO完成操作，反之则是异步IO&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的这个定义非常重要，这个定义是搞清同步非阻塞 IO 的关键。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="unix" scheme="http://linthan.github.io/blog/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>golang并发控制和容错处理</title>
    <link href="http://linthan.github.io/blog/2018/09/11/tech/golang/dairy-2018-0911-0912/"/>
    <id>http://linthan.github.io/blog/2018/09/11/tech/golang/dairy-2018-0911-0912/</id>
    <published>2018-09-11T06:10:00.000Z</published>
    <updated>2020-06-19T08:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>核心思想</strong>：通过 goroutineCnt 控制并发数量，当 channel 的请求超过一定的数量将请求压入 redis 队列。等待数量下降以后再压回队列</p><a id="more"></a><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Service  定义服务</span></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line">ch           <span class="keyword">chan</span> vo.Req</span><br><span class="line">goroutineCnt <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IntService 初始化服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntService</span><span class="params">()</span> *<span class="title">Service</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s := &amp;Service&#123;</span><br><span class="line">ch:           <span class="built_in">make</span>(<span class="keyword">chan</span> vo.Req, <span class="number">6000</span>),</span><br><span class="line">goroutineCnt: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> s.run()</span><br><span class="line"><span class="keyword">go</span> s.popOutRedis()</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> req := &lt;-s.ch:</span><br><span class="line">s.goroutineCnt &lt;- <span class="number">1</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">stack := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>)</span><br><span class="line">length := runtime.Stack(stack, <span class="literal">true</span>)</span><br><span class="line">log.Error(<span class="string">"panic"</span>, <span class="string">"err"</span>, fmt.Sprintf(<span class="string">"%s %s"</span>, err, stack[:length]))</span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&lt;-s.goroutineCnt</span><br><span class="line">&#125;()</span><br><span class="line"> <span class="comment">//运行代码的地方</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Send 记录请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">Send</span><span class="params">(req vspeed.SignForGoldReq)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s.ch) &gt; <span class="number">5000</span> &#123;</span><br><span class="line">s.pushInRedis(req)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">s.send(req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">send</span><span class="params">(req vo.Req)</span></span> &#123;</span><br><span class="line">s.ch &lt;- req</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pushInRedis 将请求输入到redis</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">pushInRedis</span><span class="params">(req vo.Req)</span></span> &#123;</span><br><span class="line">reqByte, _ := json.Marshal(req)</span><br><span class="line">err := redis.Rpush(<span class="keyword">string</span>(reqByte))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">"pushInRedis fails"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//popOutRedis 消费redis里面的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">popOutRedis</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">s.pop()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">pop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">stack := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>)</span><br><span class="line">length := runtime.Stack(stack, <span class="literal">true</span>)</span><br><span class="line">log.Error(<span class="string">"pop panic"</span>, <span class="string">"err"</span>, fmt.Sprintf(<span class="string">"%s %s"</span>, err, stack[:length]))</span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">if</span> redis.Llen() == <span class="number">0</span> || <span class="built_in">len</span>(s.ch) &gt; <span class="number">5000</span> &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">res := redis.Lpop(<span class="number">200</span>)</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> res &#123;</span><br><span class="line">req := vo.Req&#123;&#125;</span><br><span class="line">err := json.Unmarshal(item, &amp;req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">s.send(req)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;核心思想&lt;/strong&gt;：通过 goroutineCnt 控制并发数量，当 channel 的请求超过一定的数量将请求压入 redis 队列。等待数量下降以后再压回队列&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://linthan.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="golang" scheme="http://linthan.github.io/blog/tags/golang/"/>
    
      <category term="并发编程" scheme="http://linthan.github.io/blog/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
